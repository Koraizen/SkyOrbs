{"file_contents":{"src/main/java/com/skyorbs/modifiers/ModifierResolver.java":{"content":"package com.skyorbs.modifiers;\n\nimport java.util.*;\n\n/**\n * Resolves which modifiers apply to a planet\n * Enables massive diversity through modifier combinations\n */\npublic class ModifierResolver {\n    \n    private final Random random;\n    \n    public ModifierResolver(long seed) {\n        this.random = new Random(seed);\n    }\n    \n    /**\n     * Roll for modifiers based on probabilities\n     * Each modifier is rolled independently\n     * @return Set of active modifiers for this planet\n     */\n    public Set<PlanetModifier> resolveModifiers() {\n        Set<PlanetModifier> active = new HashSet<>();\n        \n        for (PlanetModifier modifier : PlanetModifier.values()) {\n            if (random.nextDouble() < modifier.getProbability()) {\n                active.add(modifier);\n            }\n        }\n        \n        // Ensure incompatible modifiers don't coexist\n        resolveConflicts(active);\n        \n        return active;\n    }\n    \n    /**\n     * Remove conflicting modifiers\n     */\n    private void resolveConflicts(Set<PlanetModifier> modifiers) {\n        // MAGMA_CORE and ICY_CORE are mutually exclusive\n        if (modifiers.contains(PlanetModifier.MAGMA_CORE) && \n            modifiers.contains(PlanetModifier.ICY_CORE)) {\n            // Keep random one\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.ICY_CORE);\n            } else {\n                modifiers.remove(PlanetModifier.MAGMA_CORE);\n            }\n        }\n        \n        // DENSE and POROUS are opposite\n        if (modifiers.contains(PlanetModifier.DENSE) && \n            modifiers.contains(PlanetModifier.POROUS)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.POROUS);\n            } else {\n                modifiers.remove(PlanetModifier.DENSE);\n            }\n        }\n    }\n    \n    /**\n     * Get ore density multiplier\n     */\n    public double getOreDensityMultiplier(Set<PlanetModifier> modifiers) {\n        double multiplier = 1.0;\n        \n        if (modifiers.contains(PlanetModifier.ORE_RICH)) {\n            multiplier *= 2.0;\n        }\n        \n        if (modifiers.contains(PlanetModifier.DENSE)) {\n            multiplier *= 1.5;\n        }\n        \n        if (modifiers.contains(PlanetModifier.POROUS)) {\n            multiplier *= 0.7;\n        }\n        \n        return multiplier;\n    }\n    \n    /**\n     * Get shell thickness for hollow planets\n     */\n    public int getShellThickness(Set<PlanetModifier> modifiers, int baseThickness) {\n        if (modifiers.contains(PlanetModifier.HOLLOW)) {\n            if (modifiers.contains(PlanetModifier.DENSE)) {\n                return baseThickness + 2;\n            }\n            return baseThickness;\n        }\n        return -1; // Not hollow\n    }\n    \n    /**\n     * Check if planet should have tunnels\n     */\n    public boolean shouldHaveTunnels(Set<PlanetModifier> modifiers) {\n        return modifiers.contains(PlanetModifier.POROUS) || \n               modifiers.contains(PlanetModifier.HOLLOW);\n    }\n    \n    /**\n     * Get number of tunnels\n     */\n    public int getTunnelCount(Set<PlanetModifier> modifiers) {\n        if (modifiers.contains(PlanetModifier.POROUS)) {\n            return 5 + random.nextInt(5); // 5-10 tunnels\n        }\n        if (modifiers.contains(PlanetModifier.HOLLOW)) {\n            return 2 + random.nextInt(3); // 2-5 tunnels\n        }\n        return 0;\n    }\n}\n","size_bytes":3433},"src/main/java/com/skyorbs/shapes/impl/CrescentShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CrescentShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance > radius) {\n            return false;\n        }\n        \n        int offsetX = (int) (radius * 0.4);\n        double cutDistance = Math.sqrt((dx - offsetX) * (dx - offsetX) + dy * dy + dz * dz);\n        \n        return cutDistance >= radius * 0.7;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CRESCENT\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Hilal\";\n    }\n}\n","size_bytes":832},"src/main/java/com/skyorbs/events/CelestialEvents.java":{"content":"package com.skyorbs.events;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Player;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.*;\n\npublic class CelestialEvents {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n    private final Map<UUID, ActiveEvent> activeEvents = new HashMap<>();\n\n    public CelestialEvents(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startEventScheduler();\n    }\n\n    private void startEventScheduler() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                try {\n                    // Check for new events every 5 minutes\n                    List<Orb> planets = plugin.getDatabaseManager().getAllOrbs();\n                    for (Orb orb : planets) {\n                        if (random.nextDouble() < 0.05) { // 5% chance per planet per check\n                            triggerRandomEvent(orb);\n                        }\n                    }\n                } catch (Exception e) {\n                    plugin.logError(\"Event scheduler error\", e);\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 6000L); // Every 5 minutes\n    }\n\n    public void triggerRandomEvent(Orb orb) {\n        if (activeEvents.containsKey(orb.getId())) {\n            return; // Already has an active event\n        }\n\n        CelestialEventType eventType = getRandomEventType(orb);\n        if (eventType != null) {\n            startEvent(orb, eventType);\n        }\n    }\n\n    public void triggerSpecificEvent(Orb orb, CelestialEventType eventType) {\n        if (!activeEvents.containsKey(orb.getId())) {\n            startEvent(orb, eventType);\n        }\n    }\n\n    private CelestialEventType getRandomEventType(Orb orb) {\n        List<CelestialEventType> availableEvents = new ArrayList<>();\n\n        // Base events for all planets\n        availableEvents.add(CelestialEventType.METEOR_SHOWER);\n        availableEvents.add(CelestialEventType.SOLAR_FLARE);\n\n        // Planet-specific events\n        PlanetType type = orb.getPlanetType();\n        switch (type) {\n            case TERRESTRIAL -> {\n                availableEvents.add(CelestialEventType.RAINFALL);\n                availableEvents.add(CelestialEventType.MAGNETIC_STORM);\n                if (orb.getBiosphereLevel() >= 3) {\n                    availableEvents.add(CelestialEventType.BLOSSOMING);\n                }\n            }\n            case GAS -> {\n                availableEvents.add(CelestialEventType.GAS_STORM);\n                availableEvents.add(CelestialEventType.AURORA);\n            }\n            case LAVA -> {\n                availableEvents.add(CelestialEventType.VOLCANIC_ERUPTION);\n                availableEvents.add(CelestialEventType.LAVA_RAIN);\n            }\n            case ICE -> {\n                availableEvents.add(CelestialEventType.BLIZZARD);\n                availableEvents.add(CelestialEventType.AURORA);\n            }\n            case CRYSTAL -> {\n                availableEvents.add(CelestialEventType.CRYSTAL_STORM);\n                availableEvents.add(CelestialEventType.ENERGY_SURGE);\n            }\n            case SHADOW -> {\n                availableEvents.add(CelestialEventType.SHADOW_FOG);\n                availableEvents.add(CelestialEventType.NEBULA);\n            }\n            case TOXIC -> {\n                availableEvents.add(CelestialEventType.TOXIC_FOG);\n                availableEvents.add(CelestialEventType.ACID_RAIN);\n            }\n        }\n\n        // Core level based events\n        if (orb.getCoreLevel() >= 5) {\n            availableEvents.add(CelestialEventType.CELESTIAL_ALIGNMENT);\n        }\n\n        if (orb.getCoreLevel() >= 8) {\n            availableEvents.add(CelestialEventType.DIMENSIONAL_RIFT);\n        }\n\n        return availableEvents.get(random.nextInt(availableEvents.size()));\n    }\n\n    private void startEvent(Orb orb, CelestialEventType eventType) {\n        ActiveEvent event = new ActiveEvent(orb, eventType);\n        activeEvents.put(orb.getId(), event);\n\n        // Announce event to players on the planet\n        announceEvent(orb, eventType);\n\n        // Start event effects\n        event.start();\n\n        // Schedule event end\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                endEvent(orb.getId());\n            }\n        }.runTaskLater(plugin, eventType.getDuration() * 20L); // Convert seconds to ticks\n    }\n\n    private void announceEvent(Orb orb, CelestialEventType eventType) {\n        String message = String.format(\"§e🌟 Gezegen §b%s §eüzerinde §a%s §eolayı başladı!\",\n                                     orb.getName(), eventType.getDisplayName());\n\n        // Send to all players on the planet\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world != null) {\n            for (Player player : world.getPlayers()) {\n                Location centerLoc = new Location(world, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ());\n                double distance = player.getLocation().distance(centerLoc);\n                if (distance <= orb.getRadius() + 50) {\n                    player.sendMessage(message);\n                    player.sendMessage(\"§7\" + eventType.getDescription());\n                }\n            }\n        }\n    }\n\n    private void endEvent(UUID orbId) {\n        ActiveEvent event = activeEvents.remove(orbId);\n        if (event != null) {\n            event.end();\n            // Announce event end\n            try {\n                Orb orb = plugin.getDatabaseManager().getOrb(orbId);\n                if (orb != null) {\n                    String message = String.format(\"§e🌟 Gezegen §b%s §eüzerindeki §a%s §eolayı sona erdi!\",\n                                                  orb.getName(), event.eventType.getDisplayName());\n                    announceToPlanet(orb, message);\n                }\n            } catch (Exception e) {\n                plugin.logError(\"Event end announcement error\", e);\n            }\n        }\n    }\n\n    private void announceToPlanet(Orb orb, String message) {\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world != null) {\n            for (Player player : world.getPlayers()) {\n                Location centerLoc = new Location(world, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ());\n                double distance = player.getLocation().distance(centerLoc);\n                if (distance <= orb.getRadius() + 50) {\n                    player.sendMessage(message);\n                }\n            }\n        }\n    }\n\n    public boolean hasActiveEvent(UUID orbId) {\n        return activeEvents.containsKey(orbId);\n    }\n\n    public CelestialEventType getActiveEventType(UUID orbId) {\n        ActiveEvent event = activeEvents.get(orbId);\n        return event != null ? event.eventType : null;\n    }\n\n    public enum CelestialEventType {\n        // Universal Events\n        METEOR_SHOWER(\"Göktaşı Yağmuru\", \"Gökyüzünden göktaşları yağyor!\", 300, Material.FIREWORK_ROCKET),\n        SOLAR_FLARE(\"Güneş Patlaması\", \"Güneşten gelen radyasyon dalgası!\", 180, Material.SUNFLOWER),\n\n        // Terrestrial Events\n        RAINFALL(\"Yağmur\", \"Canlandırıcı yağmur başlıyor!\", 600, Material.WATER_BUCKET),\n        MAGNETIC_STORM(\"Manyetik Fırtına\", \"Manyetik alanlar nadir mineraller çıkarıyor!\", 480, Material.IRON_INGOT),\n        BLOSSOMING(\"Çiçek Açma\", \"Gezegen çiçeklerle kaplanıyor!\", 900, Material.POPPY),\n\n        // Gas Events\n        GAS_STORM(\"Gaz Fırtınası\", \"Şiddetli gaz fırtınaları!\", 420, Material.BLUE_WOOL),\n        AURORA(\"Aurora\", \"Kutup ışıkları dans ediyor!\", 720, Material.LIGHT_BLUE_WOOL),\n\n        // Lava Events\n        VOLCANIC_ERUPTION(\"Volkanik Patlama\", \"Volkanlar uyanıyor!\", 360, Material.LAVA_BUCKET),\n        LAVA_RAIN(\"Lav Yağmuru\", \"Gökyüzünden lav damlaları!\", 300, Material.MAGMA_BLOCK),\n\n        // Ice Events\n        BLIZZARD(\"Kar Fırtınası\", \"Şiddetli kar fırtınası!\", 480, Material.SNOW_BLOCK),\n\n        // Crystal Events\n        CRYSTAL_STORM(\"Kristal Fırtınası\", \"Kristaller gökyüzünden yağıyor!\", 540, Material.AMETHYST_SHARD),\n        ENERGY_SURGE(\"Enerji Artışı\", \"Kristal enerji seviyesi yükseliyor!\", 600, Material.AMETHYST_BLOCK),\n\n        // Shadow Events\n        SHADOW_FOG(\"Gölge Sisi\", \"Gölge sisleri her yeri kaplıyor!\", 420, Material.BLACK_WOOL),\n        NEBULA(\"Nebula\", \"Gezegen nebulaya sarılıyor!\", 780, Material.PURPLE_WOOL),\n\n        // Toxic Events\n        TOXIC_FOG(\"Zehirli Sis\", \"Zehirli sisler yayılıyor!\", 360, Material.SLIME_BLOCK),\n        ACID_RAIN(\"Asit Yağmuru\", \"Asit yağmuru başlıyor!\", 480, Material.GREEN_WOOL),\n\n        // Advanced Events\n        CELESTIAL_ALIGNMENT(\"Gök Cisimleri Hizalama\", \"Nadir kozmik olay!\", 1200, Material.NETHER_STAR),\n        DIMENSIONAL_RIFT(\"Boyutsal Yarık\", \"Başka boyutlardan enerji akıyor!\", 900, Material.END_PORTAL_FRAME);\n\n        private final String displayName;\n        private final String description;\n        private final int duration; // in seconds\n        private final Material icon;\n\n        CelestialEventType(String displayName, String description, int duration, Material icon) {\n            this.displayName = displayName;\n            this.description = description;\n            this.duration = duration;\n            this.icon = icon;\n        }\n\n        public String getDisplayName() { return displayName; }\n        public String getDescription() { return description; }\n        public int getDuration() { return duration; }\n        public Material getIcon() { return icon; }\n    }\n\n    private class ActiveEvent {\n        private final Orb orb;\n        private final CelestialEventType eventType;\n        private final long startTime;\n        private BukkitRunnable effectTask;\n\n        public ActiveEvent(Orb orb, CelestialEventType eventType) {\n            this.orb = orb;\n            this.eventType = eventType;\n            this.startTime = System.currentTimeMillis();\n        }\n\n        public void start() {\n            // Start event-specific effects\n            effectTask = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    applyEventEffects();\n                }\n            };\n            effectTask.runTaskTimer(plugin, 0L, 20L); // Every second\n        }\n\n        public void end() {\n            if (effectTask != null) {\n                effectTask.cancel();\n            }\n            // Apply end effects if any\n            applyEventEndEffects();\n        }\n\n        private void applyEventEffects() {\n            World world = Bukkit.getWorld(orb.getWorldName());\n            if (world == null) return;\n\n            switch (eventType) {\n                case METEOR_SHOWER -> {\n                    // Spawn occasional firework effects\n                    if (random.nextDouble() < 0.1) {\n                        // Simulate meteor effects\n                    }\n                }\n                case RAINFALL -> {\n                    // Increase random ticks for plant growth\n                    // This would require custom tick handling\n                }\n                case MAGNETIC_STORM -> {\n                    // Occasionally spawn rare ores\n                    if (random.nextDouble() < 0.05) {\n                        spawnRareOre(orb, world);\n                    }\n                }\n                // Add more event effects...\n            }\n        }\n\n        private void applyEventEndEffects() {\n            // Apply effects when event ends\n            switch (eventType) {\n                case MAGNETIC_STORM -> {\n                    // Give bonus XP for surviving the storm\n                    // plugin.getEvolutionManager().gainXpFromActivity(orb, \"magnetic_storm_survival\", 500);\n                }\n                case BLOSSOMING -> {\n                    // Permanent flora boost\n                    // plugin.getBiosphereManager().updateBiosphere(orb, \"blossoming\");\n                }\n                // Add more end effects...\n            }\n        }\n\n        private void spawnRareOre(Orb orb, World world) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = orb.getCenterY() + random.nextInt(orb.getRadius()) - orb.getRadius() / 2;\n\n            Block block = world.getBlockAt(x, y, z);\n            if (block.getType() == Material.STONE || block.getType() == Material.DEEPSLATE) {\n                Material ore = random.nextDouble() < 0.8 ? Material.DIAMOND_ORE : Material.EMERALD_ORE;\n                block.setType(ore);\n            }\n        }\n    }\n}","size_bytes":12970},"src/main/java/com/skyorbs/core/Orb.java":{"content":"package com.skyorbs.core;\n\nimport java.util.UUID;\nimport java.util.Set;\nimport java.util.HashSet;\nimport com.skyorbs.modifiers.PlanetModifier;\nimport com.skyorbs.atmosphere.AtmosphereType;\n\npublic class Orb {\n\n    private final UUID id;\n    private final String name;\n    private final String worldName;\n    private final int centerX;\n    private final int centerY;\n    private final int centerZ;\n    private final int radius;\n    private final String shapeName;\n    private final String biomeName;\n    private final long seed;\n    private final long createdAt;\n    private final boolean isAsteroid;\n    private final UUID parentId;\n\n    // Dynamic Core System\n    private int coreLevel;\n    private double energyLevel;\n    private long xp;\n    private PlanetType planetType;\n    private int biosphereLevel;\n    private double ecologicalBalance;\n    \n    // Advanced planet features\n    private String paletteId;\n    private Set<PlanetModifier> modifiers;\n    private AtmosphereType atmosphere;\n    \n    public Orb(UUID id, String name, String worldName, int centerX, int centerY, int centerZ,\n               int radius, String shapeName, String biomeName, long seed, long createdAt,\n               boolean isAsteroid, UUID parentId) {\n        this.id = id;\n        this.name = name;\n        this.worldName = worldName;\n        this.centerX = centerX;\n        this.centerY = centerY;\n        this.centerZ = centerZ;\n        this.radius = radius;\n        this.shapeName = shapeName;\n        this.biomeName = biomeName;\n        this.seed = seed;\n        this.createdAt = createdAt;\n        this.isAsteroid = isAsteroid;\n        this.parentId = parentId;\n\n        // Initialize dynamic core system\n        this.coreLevel = 1;\n        this.energyLevel = 100.0;\n        this.xp = 0;\n        this.planetType = PlanetType.TERRESTRIAL; // Default type\n        this.biosphereLevel = 1;\n        this.ecologicalBalance = 1.0;\n        \n        // Initialize advanced features\n        this.paletteId = null;\n        this.modifiers = new HashSet<>();\n        this.atmosphere = AtmosphereType.CLEAR;\n    }\n    \n    public UUID getId() {\n        return id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getWorldName() {\n        return worldName;\n    }\n    \n    public int getCenterX() {\n        return centerX;\n    }\n    \n    public int getCenterY() {\n        return centerY;\n    }\n    \n    public int getCenterZ() {\n        return centerZ;\n    }\n    \n    public int getRadius() {\n        return radius;\n    }\n    \n    public String getShapeName() {\n        return shapeName;\n    }\n    \n    public String getBiomeName() {\n        return biomeName;\n    }\n    \n    public long getSeed() {\n        return seed;\n    }\n    \n    public long getCreatedAt() {\n        return createdAt;\n    }\n    \n    public boolean isAsteroid() {\n        return isAsteroid;\n    }\n    \n    public UUID getParentId() {\n        return parentId;\n    }\n    \n    public double getDistanceFrom(int x, int z) {\n        int dx = x - centerX;\n        int dz = z - centerZ;\n        return Math.sqrt(dx * dx + dz * dz);\n    }\n    \n    public double getDistanceFromSpawn() {\n        return Math.sqrt(centerX * centerX + centerZ * centerZ);\n    }\n\n    // Dynamic Core System Getters and Setters\n    public int getCoreLevel() {\n        return coreLevel;\n    }\n\n    public void setCoreLevel(int coreLevel) {\n        this.coreLevel = Math.max(1, Math.min(10, coreLevel));\n    }\n\n    public double getEnergyLevel() {\n        return energyLevel;\n    }\n\n    public void setEnergyLevel(double energyLevel) {\n        this.energyLevel = Math.max(0.0, Math.min(100.0, energyLevel));\n    }\n\n    public long getXp() {\n        return xp;\n    }\n\n    public void addXp(long xp) {\n        this.xp += xp;\n        // Check for level up\n        int newLevel = calculateCoreLevelFromXp(this.xp);\n        if (newLevel > this.coreLevel) {\n            setCoreLevel(newLevel);\n        }\n    }\n\n    public PlanetType getPlanetType() {\n        return planetType;\n    }\n\n    public void setPlanetType(PlanetType planetType) {\n        this.planetType = planetType;\n    }\n\n    public int getBiosphereLevel() {\n        return biosphereLevel;\n    }\n\n    public void setBiosphereLevel(int biosphereLevel) {\n        this.biosphereLevel = Math.max(1, Math.min(5, biosphereLevel));\n    }\n\n    public double getEcologicalBalance() {\n        return ecologicalBalance;\n    }\n\n    public void setEcologicalBalance(double ecologicalBalance) {\n        this.ecologicalBalance = Math.max(0.0, Math.min(2.0, ecologicalBalance));\n    }\n\n    // Helper methods\n    private int calculateCoreLevelFromXp(long xp) {\n        // Level calculation: level = floor(sqrt(xp / 1000)) + 1\n        return (int) Math.floor(Math.sqrt(xp / 1000.0)) + 1;\n    }\n\n    public long getXpForNextLevel() {\n        int nextLevel = coreLevel + 1;\n        return (long) ((nextLevel - 1) * (nextLevel - 1) * 1000);\n    }\n\n    public double getEnergyRegenRate() {\n        return 0.1 * coreLevel; // Higher levels regenerate faster\n    }\n\n    public boolean canUpgrade() {\n        return xp >= getXpForNextLevel();\n    }\n    \n    // Advanced features getters and setters\n    public String getPaletteId() {\n        return paletteId;\n    }\n    \n    public void setPaletteId(String paletteId) {\n        this.paletteId = paletteId;\n    }\n    \n    public Set<PlanetModifier> getModifiers() {\n        return modifiers;\n    }\n    \n    public void setModifiers(Set<PlanetModifier> modifiers) {\n        this.modifiers = modifiers != null ? modifiers : new HashSet<>();\n    }\n    \n    public void addModifier(PlanetModifier modifier) {\n        this.modifiers.add(modifier);\n    }\n    \n    public boolean hasModifier(PlanetModifier modifier) {\n        return modifiers.contains(modifier);\n    }\n    \n    public AtmosphereType getAtmosphere() {\n        return atmosphere;\n    }\n    \n    public void setAtmosphere(AtmosphereType atmosphere) {\n        this.atmosphere = atmosphere != null ? atmosphere : AtmosphereType.CLEAR;\n    }\n    \n    public boolean isHollow() {\n        return modifiers.contains(PlanetModifier.HOLLOW);\n    }\n    \n    public boolean isOreRich() {\n        return modifiers.contains(PlanetModifier.ORE_RICH);\n    }\n}\n","size_bytes":6241},"src/main/java/com/skyorbs/shapes/impl/DiamondShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class DiamondShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        int manhattan = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n        return manhattan <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"DIAMOND\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Elmas\";\n    }\n}\n","size_bytes":591},"src/main/java/com/skyorbs/shapes/impl/OctahedronShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class OctahedronShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        int manhattan = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n        return manhattan <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"OCTAHEDRON\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Sekizyüzlü\";\n    }\n}\n","size_bytes":604},"src/main/java/com/skyorbs/generation/BiomeBlender.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class BiomeBlender {\n\n    /**\n     * Implement soft biome blending algorithm\n     */\n    public List<AdvancedWorldGen.BlockPlacement> blendBiomes(Orb orb, PlanetType primaryType, List<PlanetType> secondaryTypes) {\n        List<AdvancedWorldGen.BlockPlacement> blendedBlocks = new ArrayList<>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Create noise generators for blending\n        SimplexOctaveGenerator blendNoise = new SimplexOctaveGenerator(seed + 1000, 6);\n        blendNoise.setScale(0.005);\n\n        SimplexOctaveGenerator detailBlend = new SimplexOctaveGenerator(seed + 2000, 4);\n        detailBlend.setScale(0.02);\n\n        // Generate blended terrain\n        for (int x = -radius; x <= radius; x++) {\n            for (int z = -radius; z <= radius; z++) {\n                double distance = Math.sqrt(x * x + z * z);\n                if (distance > radius) continue;\n\n                // Calculate blend factors\n                double blendValue = blendNoise.noise(x, z, 0.5);\n                double detailValue = detailBlend.noise(x, z, 0.5);\n\n                // Determine which biomes to blend at this location\n                BiomeBlend blend = calculateBiomeBlend(primaryType, secondaryTypes, blendValue, detailValue, distance, radius);\n\n                // Generate terrain with blended materials\n                int height = calculateBlendedHeight(orb, x, z, blend, seed);\n                for (int y = -radius; y <= height; y++) {\n                    double verticalDistance = Math.sqrt(x * x + y * y + z * z);\n                    if (verticalDistance <= radius) {\n                        Material material = getBlendedMaterial(blend, y, height, seed + x * 31 + z * 37 + y);\n                        blendedBlocks.add(new AdvancedWorldGen.BlockPlacement(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        return blendedBlocks;\n    }\n\n    private BiomeBlend calculateBiomeBlend(PlanetType primary, List<PlanetType> secondary, double blendValue, double detailValue, double distance, int radius) {\n        // Calculate blend weights based on noise and distance\n        double distanceFactor = distance / radius; // 0 at center, 1 at edge\n\n        // Primary biome weight (stronger at center)\n        double primaryWeight = Math.max(0.3, 1.0 - distanceFactor * 0.7);\n\n        // Secondary biome weights based on noise\n        List<Double> secondaryWeights = new ArrayList<>();\n        double remainingWeight = 1.0 - primaryWeight;\n\n        if (!secondary.isEmpty()) {\n            double totalSecondaryWeight = 0;\n            for (int i = 0; i < secondary.size(); i++) {\n                double weight = Math.abs(blendValue + detailValue * 0.5) * (1.0 / secondary.size());\n                weight = Math.max(0.1, Math.min(0.4, weight));\n                secondaryWeights.add(weight);\n                totalSecondaryWeight += weight;\n            }\n\n            // Normalize secondary weights\n            if (totalSecondaryWeight > 0) {\n                for (int i = 0; i < secondaryWeights.size(); i++) {\n                    secondaryWeights.set(i, secondaryWeights.get(i) / totalSecondaryWeight * remainingWeight);\n                }\n            }\n        }\n\n        return new BiomeBlend(primary, secondary, primaryWeight, secondaryWeights);\n    }\n\n    private int calculateBlendedHeight(Orb orb, int x, int z, BiomeBlend blend, long seed) {\n        // Calculate height based on blended biome characteristics\n        double height = 0;\n        double totalWeight = blend.primaryWeight;\n\n        // Primary biome contribution\n        height += getBiomeBaseHeight(blend.primary) * blend.primaryWeight;\n\n        // Secondary biome contributions\n        for (int i = 0; i < blend.secondaryTypes.size(); i++) {\n            PlanetType secondary = blend.secondaryTypes.get(i);\n            double weight = blend.secondaryWeights.get(i);\n            height += getBiomeBaseHeight(secondary) * weight;\n            totalWeight += weight;\n        }\n\n        // Add noise variation\n        SimplexOctaveGenerator heightNoise = new SimplexOctaveGenerator(seed, 4);\n        heightNoise.setScale(0.01);\n        double noiseVariation = heightNoise.noise(x, z, 0.5) * 10;\n\n        return (int) Math.max(-orb.getRadius(), Math.min(orb.getRadius(), height + noiseVariation));\n    }\n\n    private double getBiomeBaseHeight(PlanetType type) {\n        return switch (type) {\n            case TERRESTRIAL -> 20.0;\n            case GAS -> 15.0;\n            case LAVA -> 25.0;\n            case ICE -> 18.0;\n            case CRYSTAL -> 22.0;\n            case SHADOW -> 12.0;\n            case TOXIC -> 16.0;\n        };\n    }\n\n    private Material getBlendedMaterial(BiomeBlend blend, int y, int surfaceHeight, long seed) {\n        Random random = new Random(seed);\n\n        // Determine material based on depth and blended biome properties\n        boolean isSurface = y == surfaceHeight;\n        boolean isNearSurface = y > surfaceHeight - 3;\n\n        // Calculate which biome's material to use\n        double rand = random.nextDouble();\n        double cumulativeWeight = blend.primaryWeight;\n\n        if (rand <= cumulativeWeight) {\n            // Use primary biome material\n            return getBiomeMaterial(blend.primary, y, surfaceHeight, isSurface, isNearSurface, random);\n        }\n\n        // Check secondary biomes\n        for (int i = 0; i < blend.secondaryTypes.size(); i++) {\n            cumulativeWeight += blend.secondaryWeights.get(i);\n            if (rand <= cumulativeWeight) {\n                return getBiomeMaterial(blend.secondaryTypes.get(i), y, surfaceHeight, isSurface, isNearSurface, random);\n            }\n        }\n\n        // Fallback to primary\n        return getBiomeMaterial(blend.primary, y, surfaceHeight, isSurface, isNearSurface, random);\n    }\n\n    private Material getBiomeMaterial(PlanetType type, int y, int surfaceHeight, boolean isSurface, boolean isNearSurface, Random random) {\n        switch (type) {\n            case TERRESTRIAL -> {\n                if (isSurface) return random.nextDouble() < 0.7 ? Material.GRASS_BLOCK : Material.DIRT;\n                if (isNearSurface) return Material.DIRT;\n                return Material.STONE;\n            }\n            case GAS -> {\n                double layer = (double) y / surfaceHeight;\n                if (layer > 0.8) return Material.BLUE_WOOL;\n                else if (layer > 0.6) return Material.LIGHT_BLUE_WOOL;\n                else if (layer > 0.4) return Material.CYAN_WOOL;\n                else return Material.BLUE_WOOL;\n            }\n            case LAVA -> {\n                if (isSurface || isNearSurface) return Material.MAGMA_BLOCK;\n                return Material.NETHERRACK;\n            }\n            case ICE -> {\n                if (isSurface) return Material.SNOW_BLOCK;\n                if (isNearSurface) return Material.ICE;\n                return Material.PACKED_ICE;\n            }\n            case CRYSTAL -> {\n                if (random.nextDouble() < 0.3) return Material.AMETHYST_BLOCK;\n                return Material.QUARTZ_BLOCK;\n            }\n            case SHADOW -> {\n                return Material.BLACK_CONCRETE;\n            }\n            case TOXIC -> {\n                if (isSurface) return Material.SLIME_BLOCK;\n                return Material.GREEN_CONCRETE;\n            }\n            default -> {\n                return Material.STONE;\n            }\n        }\n    }\n\n    private static class BiomeBlend {\n        final PlanetType primary;\n        final List<PlanetType> secondaryTypes;\n        final double primaryWeight;\n        final List<Double> secondaryWeights;\n\n        BiomeBlend(PlanetType primary, List<PlanetType> secondaryTypes, double primaryWeight, List<Double> secondaryWeights) {\n            this.primary = primary;\n            this.secondaryTypes = secondaryTypes;\n            this.primaryWeight = primaryWeight;\n            this.secondaryWeights = secondaryWeights;\n        }\n    }\n}","size_bytes":8375},"src/main/java/com/skyorbs/generation/GenerationManager.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.features.*;\nimport com.skyorbs.shapes.PlanetShape;\nimport org.bukkit.*;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.boss.BarColor;\nimport org.bukkit.boss.BarStyle;\nimport org.bukkit.boss.BossBar;\nimport org.bukkit.entity.Player;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class GenerationManager {\n    \n    private final SkyOrbs plugin;\n    private final PlacementService placementService;\n    private final PlanetSizeCalculator sizeCalculator;\n    private final AsteroidGenerator asteroidGenerator;\n    private final SatelliteGenerator satelliteGenerator;\n    private final ExecutorService executor;\n    \n    public GenerationManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        this.placementService = new PlacementService(plugin);\n        this.sizeCalculator = new PlanetSizeCalculator(plugin);\n        this.asteroidGenerator = new AsteroidGenerator(plugin);\n        this.satelliteGenerator = new SatelliteGenerator(plugin);\n        this.executor = Executors.newCachedThreadPool(); // Daha hızlı thread yönetimi için cached pool\n    }\n    \n    public void createPlanetAsync(World world, Player player) {\n        createPlanetAsync(world, player, plugin.getConfigManager().generateRandomName());\n    }\n    \n    public void createPlanetAsync(World world, Player player, String name) {\n        player.sendMessage(\"§eGezegen oluşturuluyor...\");\n\n        executor.submit(() -> {\n            try {\n                List<Orb> existingOrbs = plugin.getDatabaseManager().getAllOrbs();\n                int radius = sizeCalculator.calculateRadius(\"RANDOM\");\n                PlacementService.PlacementResult placement = placementService.findPlacement(radius, existingOrbs);\n\n                if (!placement.isSuccess()) {\n                    Bukkit.getScheduler().runTask(plugin, () ->\n                        player.sendMessage(\"§cUygun yer bulunamadı!\")\n                    );\n                    return;\n                }\n\n                // LOCATION RESERVE - Başka gezegen aynı yere oluşmasın\n                // LOCATION RESERVE - Başka gezegen aynı yere oluşmasın\n                placementService.reserveLocation(placement.getX(), placement.getZ());\n\n                long seed = System.currentTimeMillis();\n                Random random = new Random(seed);\n\n                PlanetShape shape = plugin.getShapeRegistry().getRandomShape(\n                    plugin.getConfigManager().getShapeWeights()\n                );\n\n                BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n                \n                // NEW: Select random palette for diversity\n                com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n                \n                // NEW: Resolve modifiers for variety\n                com.skyorbs.modifiers.ModifierResolver modifierResolver = new com.skyorbs.modifiers.ModifierResolver(seed);\n                java.util.Set<com.skyorbs.modifiers.PlanetModifier> modifiers = modifierResolver.resolveModifiers();\n                \n                // NEW: Select atmosphere\n                com.skyorbs.atmosphere.AtmosphereType atmosphere = plugin.getAtmosphereManager().selectRandomAtmosphere(random);\n\n                Orb orb = new Orb(\n                    UUID.randomUUID(),\n                    name,\n                    world.getName(),\n                    placement.getX(),\n                    placement.getY(),\n                    placement.getZ(),\n                    radius,\n                    shape.getName(),\n                    biome.name(),\n                    seed,\n                    System.currentTimeMillis(),\n                    false,\n                    null\n                );\n                \n                // NEW: Set advanced features\n                orb.setPaletteId(palette.getId());\n                orb.setModifiers(modifiers);\n                orb.setAtmosphere(atmosphere);\n                \n                // NEW: Register atmosphere effects\n                plugin.getAtmosphereManager().registerPlanetAtmosphere(orb.getId(), atmosphere);\n\n                // İLK: Hemen teleport et (üst yüzeye) - gerçek konum hesapla\n                Location immediateLoc = new Location(world, placement.getX(), placement.getY() + radius + 10, placement.getZ());\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    player.teleport(immediateLoc);\n                    player.sendMessage(\"§aGezegen yüzeyine ışınlandınız! Oluşturma devam ediyor...\");\n                    player.sendMessage(\"§eİlk bloklar yerleştiriliyor... (Yukarıdan aşağıya)\");\n                });\n\n                // LOCATION RESERVE - ÖNEMLİ: Başka gezegen aynı yere oluşmasın\n                placementService.reserveLocation(placement.getX(), placement.getZ());\n\n                // Progress tracking için toplam adım sayısı\n                final int[] progress = {0};\n                final int totalSteps = 8; // Shell + Ores + Trees + Structures + Treasures + Dungeons + Asteroids + Satellites\n\n                // Progress display type from config\n                String progressType = plugin.getConfig().getString(\"progress_display.type\", \"bossbar\");\n\n                // BossBar oluştur (if enabled)\n                final BossBar[] bossBarRef = new BossBar[1];\n                final String[] actionBarRef = {\"\"};\n\n                if (\"bossbar\".equals(progressType)) {\n                    Bukkit.getScheduler().runTask(plugin, () -> {\n                        BossBar bossBar = Bukkit.createBossBar(\"§eGezegen Oluşturuluyor... §f0%\", BarColor.BLUE, BarStyle.SEGMENTED_10);\n                        bossBar.addPlayer(player);\n                        bossBar.setVisible(true);\n                        bossBarRef[0] = bossBar;\n                    });\n                }\n\n                // Progress mesajı gönderici\n                Runnable sendProgress = () -> {\n                    int percent = (progress[0] * 100) / totalSteps;\n                    double progressValue = (double) progress[0] / totalSteps;\n\n                    Bukkit.getScheduler().runTask(plugin, () -> {\n                        String progressMsg = String.format(\"🌍 Gezegen Oluşturuluyor... %d%%\", percent);\n\n                        if (\"bossbar\".equals(progressType) && bossBarRef[0] != null) {\n                            bossBarRef[0].setProgress(Math.min(progressValue, 1.0));\n                            bossBarRef[0].setTitle(String.format(\"§eGezegen Oluşturuluyor... §f%d%% §7(%d/%d)\", percent, progress[0], totalSteps));\n                        } else if (\"actionbar\".equals(progressType)) {\n                            actionBarRef[0] = progressMsg;\n                            // Send action bar message\n                            player.sendActionBar(progressMsg);\n                        } else if (\"chat\".equals(progressType)) {\n                            player.sendMessage(\"§e\" + progressMsg);\n                        }\n                    });\n                };\n\n                // OPTIMIZE EDILDI: Paralel asteroid/satellite üretimi - PROGRESS İLE\n                generatePlanetShellAsync(world, orb, shape, biome, () -> {\n                    progress[0]++;\n                    sendProgress.run();\n                    player.sendMessage(\"§eGezegen kabuğu tamamlandı! Şimdi özellikler ekleniyor...\");\n\n                    try {\n                        // Paralel asteroid üretimi\n                        List<CompletableFuture<Void>> asteroidFutures = new ArrayList<>();\n                        List<Orb> asteroids = asteroidGenerator.generateAsteroidsForPlanet(orb, world);\n                        for (Orb asteroid : asteroids) {\n                            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n                                try {\n                                    PlanetShape asteroidShape = plugin.getShapeRegistry().getShape(asteroid.getShapeName());\n                                    BiomeType asteroidBiome = BiomeType.valueOf(asteroid.getBiomeName());\n                                    generatePlanetShellAsync(world, asteroid, asteroidShape, asteroidBiome, null);\n                                    plugin.getDatabaseManager().saveOrb(asteroid);\n                                } catch (Exception e) {\n                                    plugin.logError(\"Asteroid hatası\", e);\n                                }\n                            }, executor);\n                            asteroidFutures.add(future);\n                        }\n\n                        // Paralel satellite üretimi\n                        List<CompletableFuture<Void>> satelliteFutures = new ArrayList<>();\n                        List<Orb> satellites = satelliteGenerator.generateSatellitesForPlanet(orb, world);\n                        for (Orb satellite : satellites) {\n                            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n                                try {\n                                    PlanetShape satelliteShape = plugin.getShapeRegistry().getShape(satellite.getShapeName());\n                                    BiomeType satelliteBiome = BiomeType.valueOf(satellite.getBiomeName());\n                                    generatePlanetShellAsync(world, satellite, satelliteShape, satelliteBiome, null);\n                                    plugin.getDatabaseManager().saveOrb(satellite);\n                                } catch (Exception e) {\n                                    plugin.logError(\"Satellite hatası\", e);\n                                }\n                            }, executor);\n                            satelliteFutures.add(future);\n                        }\n\n                        // Generate planetary rings if applicable\n                        satelliteGenerator.generateRingsForPlanet(orb, world);\n\n                        // Tüm paralel işlemleri bekle\n                        CompletableFuture.allOf(\n                            asteroidFutures.toArray(new CompletableFuture[0])\n                        ).join();\n\n                        CompletableFuture.allOf(\n                            satelliteFutures.toArray(new CompletableFuture[0])\n                        ).join();\n\n                        // ORE'LAR EN SON - GEZEGEN BLOKLARINDAN SONRA!\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eMadenciler çalışıyor...\");\n\n                        // ORE GENERATION - GEZEGEN BLOKLARINDAN SONRA!\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eMadenciler çalışıyor...\");\n\n                        List<OreGenerator.BlockData> ores = OreGenerator.generateOres(orb, biome, world);\n                        List<BlockPlacement> oreBlocks = new ArrayList<>();\n                        for (OreGenerator.BlockData ore : ores) {\n                            oreBlocks.add(new BlockPlacement(ore.x, ore.y, ore.z, ore.material));\n                        }\n                        placeBlocksInBatches(world, oreBlocks, null);\n\n                        // AĞAÇ GENERATION\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eAğaçlar büyüyor...\");\n\n                        List<OreGenerator.BlockData> trees = TreeGenerator.generateTrees(orb, biome, world);\n                        List<BlockPlacement> treeBlocks = new ArrayList<>();\n                        for (OreGenerator.BlockData tree : trees) {\n                            treeBlocks.add(new BlockPlacement(tree.x, tree.y, tree.z, tree.material));\n                        }\n                        placeBlocksInBatches(world, treeBlocks, null);\n\n                        // YAPI GENERATION\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eYapılar inşa ediliyor...\");\n\n                        List<OreGenerator.BlockData> structures = StructureGenerator.generateStructures(orb, biome, world);\n                        List<BlockPlacement> structureBlocks = new ArrayList<>();\n                        for (OreGenerator.BlockData structure : structures) {\n                            structureBlocks.add(new BlockPlacement(structure.x, structure.y, structure.z, structure.material));\n                        }\n                        placeBlocksInBatches(world, structureBlocks, null);\n\n                        // HAZİNE GENERATION\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eHazinelar gizleniyor...\");\n\n                        List<TreasureGenerator.TreasureLocation> treasures = TreasureGenerator.generateTreasures(orb, biome, world);\n                        for (TreasureGenerator.TreasureLocation treasure : treasures) {\n                            // Place chest\n                            Block chestBlock = world.getBlockAt(treasure.x, treasure.y, treasure.z);\n                            chestBlock.setType(Material.CHEST, false);\n                            if (chestBlock.getState() instanceof Chest chest) {\n                                TreasureGenerator.fillTreasureChest(chestBlock, treasure.biome, treasure.type, new Random(orb.getSeed() + treasure.x + treasure.y + treasure.z));\n                            }\n                        }\n\n                        // DUNGEON GENERATION\n                        progress[0]++;\n                        sendProgress.run();\n                        player.sendMessage(\"§eZindanlar oluşturuluyor...\");\n\n                        // Generate dungeons inside planet\n                        int dungeonCount = Math.max(1, radius / 8); // 1 dungeon per 8 radius units - DAHA FAZLA DUNGEON\n                        List<com.skyorbs.dungeons.DungeonGenerator.DungeonRoom> dungeons = plugin.getDungeonGenerator().generateDungeons(orb, dungeonCount);\n                        // Dungeons are already generated in the world by the DungeonGenerator\n\n                        // Save main planet\n                        plugin.getDatabaseManager().saveOrb(orb);\n\n                        // Increment planet counter\n                        plugin.incrementPlanetCount();\n\n                        // Debug log\n                        if (plugin.getConfigManager().isDebugEnabled()) {\n                            plugin.logDebug(\"generation\", String.format(\n                                \"Gezegen oluşturuldu: %s | Şekil: %s | Biyom: %s | Yarıçap: %d | Konum: %d,%d,%d\",\n                                orb.getName(), shape.getName(), biome.name(), radius,\n                                orb.getCenterX(), orb.getCenterY(), orb.getCenterZ()\n                            ));\n                        }\n\n                        // Teleport player - gerçek gezegen konumuna ve progress display'ı kaldır\n                        Bukkit.getScheduler().runTaskLater(plugin, () -> {\n                            // Yüzey bulma algoritması - güvenli teleport (first solid block)\n                            Location surfaceLoc = findSafeSurfaceLocation(world, orb);\n                            player.teleport(surfaceLoc);\n\n                            // Progress display'ı kaldır\n                            if (\"bossbar\".equals(progressType) && bossBarRef[0] != null) {\n                                bossBarRef[0].setVisible(false);\n                                bossBarRef[0].removeAll();\n                            }\n\n                            String shapeName = plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName();\n                            player.sendMessage(\"§a§lGezegen Tamamen Oluşturuldu!\");\n                            player.sendMessage(String.format(\"§aGezegen: §e%s §7(%s, %s)\",\n                                orb.getName(), shapeName, orb.getBiomeName()\n                            ));\n                            player.sendMessage(String.format(\"§aKonum: §f%d, %d, %d §7| Yarıçap: §f%d\",\n                                orb.getCenterX(), orb.getCenterY(), orb.getCenterZ(), orb.getRadius()\n                            ));\n\n                            // LOCATION RELEASE - İşlem TAMAMEN bittiğinde serbest bırak\n                            placementService.releaseLocation(placement.getX(), placement.getZ());\n                        }, 5L); // Çok daha erken\n\n                    } catch (Exception e) {\n                        plugin.logError(\"Asteroid/satellite hatası\", e);\n                    }\n                });\n\n                // LOCATION RELEASE - İşlem tamamlandıktan sonra serbest bırak\n                // LOCATION RELEASE - Hata durumunda da serbest bırak\n                placementService.releaseLocation(placement.getX(), placement.getZ());\n\n            } catch (Exception e) {\n                plugin.logError(\"Gezegen oluşturma hatası\", e);\n                Bukkit.getScheduler().runTask(plugin, () ->\n                    player.sendMessage(\"§cHata: \" + e.getMessage())\n                );\n            }\n        });\n    }\n    \n    /**\n     * ÇEŞİTLİ GEZEGEN ÜRETİMİ - Bazı dolu, bazı içi boş!\n     * Rastgele olarak içi boş veya dolu gezegenler oluştur\n     */\n    private void generatePlanetShellAsync(World world, Orb orb, PlanetShape shape, BiomeType biome, Runnable callback) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n        Random random = new Random(seed);\n\n        // GEZEGEN TİPİ BELİRLE - Use modifier system\n        boolean isHollow = orb.isHollow(); // Check if HOLLOW modifier is present\n\n        // 1. PLANET GENERATION (Async) - ÇEŞİTLİ TİPTE GEZEGENLER!\n        CompletableFuture.supplyAsync(() -> {\n            List<BlockPlacement> blocks = new ArrayList<>(500000); // Daha büyük kapasite\n\n            if (isHollow) {\n                // HOLLOW PLANET - İçi boş, kalın kabuk\n                generateHollowPlanet(blocks, cx, cy, cz, radius, seed, shape, biome, random);\n            } else {\n                // SOLID PLANET - Tam dolu, klasik\n                generateSolidPlanet(blocks, cx, cy, cz, radius, seed, shape, biome, random);\n            }\n\n            return blocks;\n        }, executor).thenAcceptAsync(blocks -> {\n\n            // Progress: Shell tamamlandı\n            if (callback != null) {\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    // İlk blokları hemen yerleştir (görsel feedback)\n                    List<BlockPlacement> firstBlocks = blocks.subList(0, Math.min(100, blocks.size()));\n                    for (BlockPlacement bp : firstBlocks) {\n                        try {\n                            Block block = world.getBlockAt(bp.x, bp.y, bp.z);\n                            if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                                block.setType(bp.material, false);\n                            }\n                        } catch (Exception e) {\n                            // Skip\n                        }\n                    }\n                });\n            }\n\n            // 5. PLACE PLANET BLOCKS FIRST\n            placeBlocksInBatches(world, blocks, callback);\n\n        }, executor);\n    }\n\n    /**\n     * SOLID PLANET - Tam dolu klasik gezegen\n     */\n    private void generateSolidPlanet(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, PlanetShape shape, BiomeType biome, Random random) {\n        // NEW: Get palette for diverse blocks\n        com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n        \n        for (int y = radius; y >= -radius; y--) {\n            for (int x = -radius; x <= radius; x++) {\n                for (int z = -radius; z <= radius; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n\n                    if (distance <= radius) {\n                        if (shape.isBlockPart(x, y, z, radius, seed)) {\n                            int depth = (int)(radius - distance);\n                            // NEW: Use palette instead of biome for material selection\n                            Material material = palette.getMaterialByDepth(depth, random);\n                            blocks.add(new BlockPlacement(cx + x, cy + y, cz + z, material));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * HOLLOW PLANET - İçi boş, configurable shell thickness, tunnels, and civilization structures\n     */\n    private void generateHollowPlanet(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, PlanetShape shape, BiomeType biome, Random random) {\n        // Configurable shell thickness\n        int shellThickness = plugin.getConfig().getInt(\"hollow.shell_thickness\", 5);\n        \n        // NEW: Get palette for diverse blocks\n        com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n\n        for (int y = radius; y >= -radius; y--) {\n            for (int x = -radius; x <= radius; x++) {\n                for (int z = -radius; z <= radius; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n\n                    // KALIN KABUK - Yüzeyden shellThickness blok içeriye kadar\n                    if (distance <= radius && distance >= radius - shellThickness) {\n                        if (shape.isBlockPart(x, y, z, radius, seed)) {\n                            int depth = (int)(radius - distance);\n                            // NEW: Use palette instead of biome\n                            Material material = palette.getMaterialByDepth(depth, random);\n                            blocks.add(new BlockPlacement(cx + x, cy + y, cz + z, material));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Generate interior structures for civilization feeling\n        generateInteriorStructures(blocks, cx, cy, cz, radius, seed, biome, random);\n\n        // Generate tunnels connecting structures\n        generateInteriorTunnels(blocks, cx, cy, cz, radius, seed, biome, random);\n    }\n\n    /**\n     * Generate interior structures for civilization feeling in hollow planets\n     */\n    private void generateInteriorStructures(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        int structureCount = Math.max(2, radius / 6); // Structures per planet size\n\n        for (int i = 0; i < structureCount; i++) {\n            // Generate structure positions within the hollow interior\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = (random.nextDouble() - 0.5) * Math.PI / 3; // -30 to +30 degrees\n            double distance = radius * 0.3 + random.nextDouble() * radius * 0.4; // 30-70% from center\n\n            int structX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * distance);\n            int structY = cy + (int)(Math.sin(angle2) * distance);\n            int structZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * distance);\n\n            // Generate different types of interior structures\n            generateInteriorStructure(blocks, structX, structY, structZ, biome, random);\n        }\n    }\n\n    /**\n     * Generate a single interior structure\n     */\n    private void generateInteriorStructure(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        int structureType = random.nextInt(4); // 4 different structure types\n\n        switch (structureType) {\n            case 0 -> generateInteriorRuins(blocks, x, y, z, biome, random);\n            case 1 -> generateInteriorLab(blocks, x, y, z, biome, random);\n            case 2 -> generateInteriorTemple(blocks, x, y, z, biome, random);\n            case 3 -> generateInteriorHabitat(blocks, x, y, z, biome, random);\n        }\n    }\n\n    /**\n     * Generate interior ruins\n     */\n    private void generateInteriorRuins(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material floorMat = getBiomeFloorMaterial(biome);\n\n        // Small ruined room (5x5x3)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                // Floor\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                // Partial walls (some broken)\n                if (random.nextDouble() < 0.7) {\n                    blocks.add(new BlockPlacement(x + dx, y + 1, z + dz, wallMat));\n                }\n                if (random.nextDouble() < 0.5) {\n                    blocks.add(new BlockPlacement(x + dx, y + 2, z + dz, wallMat));\n                }\n            }\n        }\n\n        // Add some debris\n        for (int i = 0; i < 3; i++) {\n            int debrisX = x + random.nextInt(5) - 2;\n            int debrisZ = z + random.nextInt(5) - 2;\n            blocks.add(new BlockPlacement(debrisX, y + 1, debrisZ, Material.COBBLESTONE));\n        }\n    }\n\n    /**\n     * Generate interior lab/research facility\n     */\n    private void generateInteriorLab(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = Material.IRON_BLOCK;\n        Material floorMat = Material.STONE;\n\n        // Lab room (6x6x4)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                if (Math.abs(dx) == 3 || Math.abs(dz) == 3) {\n                    for (int dy = 1; dy <= 3; dy++) {\n                        blocks.add(new BlockPlacement(x + dx, y + dy, z + dz, wallMat));\n                    }\n                }\n            }\n        }\n\n        // Lab equipment\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.CRAFTING_TABLE));\n        blocks.add(new BlockPlacement(x + 1, y + 1, z + 1, Material.BREWING_STAND));\n        blocks.add(new BlockPlacement(x - 1, y + 1, z - 1, Material.FURNACE));\n\n        // Add some glowing elements for atmosphere\n        if (biome == BiomeType.LUMINOUS || biome == BiomeType.GLOWSTONE_CAVERN) {\n            blocks.add(new BlockPlacement(x, y + 3, z, Material.SEA_LANTERN));\n        }\n    }\n\n    /**\n     * Generate interior temple/shrine\n     */\n    private void generateInteriorTemple(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material pillarMat = Material.QUARTZ_BLOCK;\n\n        // Temple platform (7x7)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, Material.QUARTZ_BLOCK));\n            }\n        }\n\n        // Corner pillars\n        int[][] corners = {{-3, -3}, {3, -3}, {-3, 3}, {3, 3}};\n        for (int[] corner : corners) {\n            for (int dy = 1; dy <= 4; dy++) {\n                blocks.add(new BlockPlacement(x + corner[0], y + dy, z + corner[1], pillarMat));\n            }\n        }\n\n        // Central altar\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new BlockPlacement(x, y + 2, z, Material.END_ROD));\n    }\n\n    /**\n     * Generate interior habitat/living quarters\n     */\n    private void generateInteriorHabitat(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material floorMat = getBiomeFloorMaterial(biome);\n\n        // Living quarters (4x6x3)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                if (Math.abs(dx) == 2 || Math.abs(dz) == 3) {\n                    for (int dy = 1; dy <= 2; dy++) {\n                        blocks.add(new BlockPlacement(x + dx, y + dy, z + dz, wallMat));\n                    }\n                }\n            }\n        }\n\n        // Furniture\n        blocks.add(new BlockPlacement(x - 1, y + 1, z - 2, Material.CHEST));\n        blocks.add(new BlockPlacement(x + 1, y + 1, z + 2, Material.CRAFTING_TABLE));\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.RED_BED));\n    }\n\n    /**\n     * Get biome-appropriate wall material\n     */\n    private Material getBiomeWallMaterial(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> Material.AMETHYST_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> Material.NETHER_BRICKS;\n            case VOID -> Material.OBSIDIAN;\n            case CORRUPTED -> Material.WARPED_PLANKS;\n            case TOXIC_SWAMP, TOXIC -> Material.GREEN_CONCRETE;\n            case LUMINOUS -> Material.SEA_LANTERN;\n            default -> Material.STONE_BRICKS;\n        };\n    }\n\n    /**\n     * Get biome-appropriate floor material\n     */\n    private Material getBiomeFloorMaterial(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> Material.PURPUR_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> Material.BLACKSTONE;\n            case VOID -> Material.END_STONE;\n            case CORRUPTED -> Material.CRIMSON_PLANKS;\n            case TOXIC_SWAMP, TOXIC -> Material.LIME_CONCRETE;\n            case LUMINOUS -> Material.GLOWSTONE;\n            default -> Material.STONE;\n        };\n    }\n\n    /**\n     * Generate connecting tunnels between interior structures\n     */\n    private void generateInteriorTunnels(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        int tunnelCount = Math.max(3, radius / 5);\n\n        for (int i = 0; i < tunnelCount; i++) {\n            // Tunnel starting from surface inward\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = random.nextDouble() * Math.PI / 2 - Math.PI / 4;\n            double startDistance = radius - 2;\n\n            int startX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * startDistance);\n            int startY = cy + (int)(Math.sin(angle2) * startDistance);\n            int startZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * startDistance);\n\n            // Tunnel direction\n            double tunnelAngle1 = random.nextDouble() * Math.PI * 2;\n            double tunnelAngle2 = (random.nextDouble() - 0.5) * Math.PI / 3;\n\n            int tunnelLength = 5 + random.nextInt(Math.max(5, radius / 2));\n\n            // Create tunnel\n            for (int step = 0; step < tunnelLength; step++) {\n                int tunnelX = startX + (int)(Math.cos(tunnelAngle1) * Math.cos(tunnelAngle2) * step);\n                int tunnelY = startY + (int)(Math.sin(tunnelAngle2) * step);\n                int tunnelZ = startZ + (int)(Math.sin(tunnelAngle1) * Math.cos(tunnelAngle2) * step);\n\n                int tunnelRadius = 1 + random.nextInt(2);\n\n                for (int dx = -tunnelRadius; dx <= tunnelRadius; dx++) {\n                    for (int dy = -tunnelRadius; dy <= tunnelRadius; dy++) {\n                        for (int dz = -tunnelRadius; dz <= tunnelRadius; dz++) {\n                            double dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                            if (dist <= tunnelRadius) {\n                                double planetDist = Math.sqrt((tunnelX + dx - cx) * (tunnelX + dx - cx) +\n                                                             (tunnelY + dy - cy) * (tunnelY + dy - cy) +\n                                                             (tunnelZ + dz - cz) * (tunnelZ + dz - cz));\n                                if (planetDist <= radius - 1) {\n                                    blocks.add(new BlockPlacement(tunnelX + dx, tunnelY + dy, tunnelZ + dz, Material.AIR));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Blokları batch'ler halinde yerleştirir (chunk-aware) - OPTIMIZE EDILDI\n     */\n    private void placeBlocksInBatches(World world, List<BlockPlacement> blocks, Runnable callback) {\n        int batchSize = plugin.getConfigManager().getBlocksPerBatch(); // Config'den oku\n        int totalBatches = (blocks.size() + batchSize - 1) / batchSize;\n\n        // Chunk'ları önceden yükle (optimize edilmiş)\n        Set<ChunkPos> chunksToLoad = new HashSet<>();\n        for (BlockPlacement bp : blocks) {\n            chunksToLoad.add(new ChunkPos(bp.x >> 4, bp.z >> 4));\n        }\n\n        // Chunk yükleme - paralel yükleme\n        Bukkit.getScheduler().runTask(plugin, () -> {\n            for (ChunkPos pos : chunksToLoad) {\n                if (!world.isChunkLoaded(pos.x, pos.z)) {\n                    world.loadChunk(pos.x, pos.z, false);\n                }\n            }\n        });\n\n        // Batch placement - config'e göre optimize edilmiş\n        int batchesPerTick = plugin.getConfigManager().getBatchesPerTick();\n        for (int i = 0; i < totalBatches; i++) {\n            int start = i * batchSize;\n            int end = Math.min(start + batchSize, blocks.size());\n            List<BlockPlacement> batch = blocks.subList(start, end);\n\n            int delay = i / batchesPerTick + 1; // Config'e göre batch sıklığı\n\n            Bukkit.getScheduler().runTaskLater(plugin, () -> {\n                for (BlockPlacement bp : batch) {\n                    try {\n                        Block block = world.getBlockAt(bp.x, bp.y, bp.z);\n                        if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                            block.setType(bp.material, false);\n                        }\n                    } catch (Exception e) {\n                        // Chunk yüklü değilse skip\n                    }\n                }\n            }, delay);\n        }\n\n        // Run callback after all batches complete - daha erken callback\n        if (callback != null) {\n            Bukkit.getScheduler().runTaskLater(plugin, callback, totalBatches / 2 + 5);\n        }\n    }\n    \n    public CompletableFuture<Void> deletePlanet(Orb orb) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        \n        executor.submit(() -> {\n            try {\n                // Delete children first\n                List<Orb> children = plugin.getDatabaseManager().getChildOrbs(orb.getId());\n                for (Orb child : children) {\n                    clearPlanetBlocks(orb);\n                    plugin.getDatabaseManager().deleteOrb(child.getId());\n                }\n                \n                // Delete main planet\n                clearPlanetBlocks(orb);\n                plugin.getDatabaseManager().deleteOrb(orb.getId());\n                future.complete(null);\n                \n            } catch (Exception e) {\n                future.completeExceptionally(e);\n            }\n        });\n        \n        return future;\n    }\n    \n    /**\n     * Gezegen bloklarını temizler\n     */\n    private void clearPlanetBlocks(Orb orb) {\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world == null) return;\n        \n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        \n        List<BlockPlacement> airBlocks = new ArrayList<>();\n        \n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n                    if (distance <= radius) {\n                        airBlocks.add(new BlockPlacement(cx + x, cy + y, cz + z, Material.AIR));\n                    }\n                }\n            }\n        }\n        \n        placeBlocksInBatches(world, airBlocks, null);\n    }\n    \n    /**\n     * Güvenli yüzey konumu bulma algoritması - First solid block teleport\n     */\n    private Location findSafeSurfaceLocation(World world, Orb orb) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Gezegenin üst kısmından başlayarak aşağı doğru tara - find first solid block\n        for (int y = cy + radius; y >= cy - radius; y--) {\n            for (int x = cx - 3; x <= cx + 3; x++) {\n                for (int z = cz - 3; z <= cz + 3; z++) {\n                    Block block = world.getBlockAt(x, y, z);\n                    Block below = world.getBlockAt(x, y - 1, z);\n\n                    // Katı blok üzerinde hava varsa güvenli konum (first solid block found)\n                    if (block.getType() == Material.AIR && below.getType().isSolid() &&\n                        !isDangerousBlock(below.getType())) {\n                        return new Location(world, x + 0.5, y, z + 0.5);\n                    }\n                }\n            }\n        }\n\n        // Bulunamazsa varsayılan konum (fallback)\n        return new Location(world, cx, cy + radius + 5, cz);\n    }\n\n    /**\n     * Check if block is dangerous for teleportation\n     */\n    private boolean isDangerousBlock(Material material) {\n        return material == Material.LAVA ||\n               material == Material.FIRE ||\n               material == Material.CACTUS ||\n               material == Material.SWEET_BERRY_BUSH ||\n               material.name().contains(\"MAGMA\");\n    }\n\n    public void shutdown() {\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n        }\n    }\n    \n    private static class BlockPlacement {\n        int x, y, z;\n        Material material;\n        \n        BlockPlacement(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n    \n    private static class ChunkPos {\n        int x, z;\n        \n        ChunkPos(int x, int z) {\n            this.x = x;\n            this.z = z;\n        }\n        \n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ChunkPos chunkPos = (ChunkPos) o;\n            return x == chunkPos.x && z == chunkPos.z;\n        }\n        \n        @Override\n        public int hashCode() {\n            return Objects.hash(x, z);\n        }\n    }\n}","size_bytes":39145},"src/main/java/com/skyorbs/features/OreGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class OreGenerator {\n\n    public static List<BlockData> generateOres(Orb orb, BiomeType biome, World world) {\n        List<BlockData> ores = new ArrayList<>();\n        Random random = new Random(orb.getSeed() + 123);\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Configurable ore layers per biome\n        List<OreLayer> layers = getOreLayersForBiome(biome);\n\n        for (OreLayer layer : layers) {\n            for (OreConfig ore : layer.ores) {\n                generateOreType(ores, ore, cx, cy, cz, radius, biome, random, layer.depthRange);\n            }\n        }\n\n        // Core inclusions for solid planets\n        if (!isHollowPlanet(orb)) { // Only for solid planets\n            generateCoreInclusions(ores, cx, cy, cz, radius, biome, random);\n        }\n\n        return ores;\n    }\n    \n    private static void generateOreType(List<BlockData> ores, OreConfig ore,\n                                        int cx, int cy, int cz, int radius,\n                                        BiomeType biome, Random random, double[] depthRange) {\n\n        // Calculate depth-based position within the planet\n        double minDepth = depthRange[0]; // 0.0 = surface, 1.0 = core\n        double maxDepth = depthRange[1];\n\n        int minY = (int)(cy - radius + (radius * 2 * minDepth));\n        int maxY = (int)(cy - radius + (radius * 2 * maxDepth));\n\n        if (maxY <= minY) return;\n\n        int veinCount = (int)(radius * radius * ore.chance * 0.1); // Base count\n\n        for (int i = 0; i < veinCount; i++) {\n            // Generate position within planet volume\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = random.nextDouble() * Math.PI;\n            double distance = minDepth + random.nextDouble() * (maxDepth - minDepth);\n\n            int x = cx + (int)(Math.sin(angle2) * Math.cos(angle1) * radius * distance);\n            int z = cz + (int)(Math.sin(angle2) * Math.sin(angle1) * radius * distance);\n            int y = minY + random.nextInt(maxY - minY + 1);\n\n            // Ensure position is inside solid planet volume (not air/structure blocks)\n            if (!isInsideSolidVolume(x - cx, y - cy, z - cz, radius)) continue;\n\n            // Generate vein\n            generateVein(ores, x, y, z, ore, random, cx, cy, cz, radius);\n        }\n    }\n    \n    /**\n     * Generate ore vein within solid planet volume\n     */\n    private static void generateVein(List<BlockData> ores, int startX, int startY, int startZ,\n                                     OreConfig ore, Random random, int cx, int cy, int cz, int radius) {\n\n        int veinSize = ore.veinSize[0] + random.nextInt(ore.veinSize[1] - ore.veinSize[0] + 1);\n\n        for (int i = 0; i < veinSize; i++) {\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = random.nextDouble() * Math.PI;\n            double distance = random.nextDouble() * 2.0; // Spread within vein\n\n            int x = startX + (int)(Math.sin(angle2) * Math.cos(angle1) * distance);\n            int y = startY + (int)((random.nextDouble() - 0.5) * 2.0);\n            int z = startZ + (int)(Math.sin(angle2) * Math.sin(angle1) * distance);\n\n            // Ensure still within solid volume\n            if (!isInsideSolidVolume(x - cx, y - cy, z - cz, radius)) continue;\n\n            // Deepslate variant for deeper ores\n            Material material = ore.type;\n            double depth = Math.sqrt((x-cx)*(x-cx) + (y-cy)*(y-cy) + (z-cz)*(z-cz)) / radius;\n            if (depth > 0.6 && ore.deepslateVariant != null) {\n                material = ore.deepslateVariant;\n            }\n\n            ores.add(new BlockData(x, y, z, material));\n        }\n    }\n    \n    private static boolean isInsideSolidVolume(int dx, int dy, int dz, int radius) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        // Only generate inside solid volume - never in air or outside planet\n        return distance <= radius - 1; // Leave 1 block surface layer\n    }\n\n    /**\n     * Generate core inclusions (rare ores in planet core)\n     */\n    private static void generateCoreInclusions(List<BlockData> ores, int cx, int cy, int cz,\n                                             int radius, BiomeType biome, Random random) {\n        // Core region: central 20% of planet\n        double coreRadius = radius * 0.2;\n        int inclusionCount = (int)(coreRadius * coreRadius * 0.01); // Rare inclusions\n\n        for (int i = 0; i < inclusionCount; i++) {\n            // Generate within core sphere\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = random.nextDouble() * Math.PI;\n            double distance = random.nextDouble() * coreRadius;\n\n            int x = cx + (int)(Math.sin(angle2) * Math.cos(angle1) * distance);\n            int y = cy + (int)(Math.cos(angle2) * distance);\n            int z = cz + (int)(Math.sin(angle2) * Math.sin(angle1) * distance);\n\n            // Choose rare ore type\n            Material inclusionType = switch (biome) {\n                case LAVA_OCEAN, MAGMA_CAVES -> Material.ANCIENT_DEBRIS;\n                case CRYSTAL_FOREST -> Material.DIAMOND_ORE;\n                default -> random.nextDouble() < 0.5 ? Material.ANCIENT_DEBRIS : Material.DIAMOND_ORE;\n            };\n\n            ores.add(new BlockData(x, y, z, inclusionType));\n        }\n    }\n    \n    /**\n     * Configurable ore configuration\n     */\n    private static class OreConfig {\n        final Material type;\n        final Material deepslateVariant;\n        final double chance;\n        final int[] veinSize;\n\n        OreConfig(Material type, Material deepslateVariant, double chance, int[] veinSize) {\n            this.type = type;\n            this.deepslateVariant = deepslateVariant;\n            this.chance = chance;\n            this.veinSize = veinSize;\n        }\n    }\n\n    /**\n     * Ore layer configuration per biome\n     */\n    private static class OreLayer {\n        final String name;\n        final List<OreConfig> ores;\n        final double[] depthRange; // [min, max] from surface inward (0.0 = surface, 1.0 = core)\n\n        OreLayer(String name, List<OreConfig> ores, double[] depthRange) {\n            this.name = name;\n            this.ores = ores;\n            this.depthRange = depthRange;\n        }\n    }\n\n    /**\n     * Get ore layers configuration for each biome\n     */\n    private static List<OreLayer> getOreLayersForBiome(BiomeType biome) {\n        List<OreLayer> layers = new ArrayList<>();\n\n        // Common layer - all biomes\n        List<OreConfig> commonOres = List.of(\n            new OreConfig(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.3, new int[]{2, 6}),\n            new OreConfig(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.25, new int[]{2, 5}),\n            new OreConfig(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.2, new int[]{3, 7})\n        );\n        layers.add(new OreLayer(\"common\", commonOres, new double[]{0.2, 0.8}));\n\n        // Rare layer - deeper\n        List<OreConfig> rareOres = new ArrayList<>();\n        rareOres.add(new OreConfig(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.08, new int[]{1, 4}));\n        rareOres.add(new OreConfig(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.06, new int[]{2, 5}));\n        rareOres.add(new OreConfig(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.04, new int[]{2, 5}));\n\n        // Biome-specific rare ores\n        switch (biome) {\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                rareOres.add(new OreConfig(Material.ANCIENT_DEBRIS, null, 0.02, new int[]{1, 3}));\n            }\n            case CRYSTAL_FOREST -> {\n                rareOres.add(new OreConfig(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.03, new int[]{1, 4}));\n            }\n            case MEADOW, FOREST, TAIGA -> {\n                rareOres.add(new OreConfig(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.01, new int[]{1, 1}));\n            }\n            case FROZEN_TUNDRA, GLACIER, ICE_SPIKES -> {\n                rareOres.add(new OreConfig(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.04, new int[]{1, 4}));\n            }\n            case BADLANDS, CANYON -> {\n                rareOres.add(new OreConfig(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.15, new int[]{2, 6}));\n            }\n            case JUNGLE, SAVANNA -> {\n                rareOres.add(new OreConfig(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.12, new int[]{3, 8}));\n            }\n        }\n\n        layers.add(new OreLayer(\"rare\", rareOres, new double[]{0.5, 0.9}));\n\n        return layers;\n    }\n\n    /**\n     * Check if planet is hollow (temporary method until Orb class is updated)\n     */\n    private static boolean isHollowPlanet(Orb orb) {\n        // For now, assume planets with certain shapes are hollow\n        // This should be replaced with a proper isHollow() method in Orb class\n        return false; // Default to solid for now\n    }\n\n    public static class BlockData {\n        public final int x, y, z;\n        public final Material material;\n\n        public BlockData(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n}","size_bytes":9589},"src/main/java/com/skyorbs/shapes/impl/FractalShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class FractalShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        double noise1 = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.1);\n        double noise2 = NoiseGenerator.getNoise(dx, dy, dz, seed + 1000, 0.2);\n        double noise3 = NoiseGenerator.getNoise(dx, dy, dz, seed + 2000, 0.4);\n        \n        double fractal = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;\n        double deformation = 1 + 0.4 * fractal;\n        \n        return distance <= radius * deformation;\n    }\n    \n    @Override\n    public String getName() {\n        return \"FRACTAL\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Fraktal\";\n    }\n}\n","size_bytes":1019},"src/main/java/com/skyorbs/shapes/impl/CylinderShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CylinderShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        int height = radius;\n        return distance <= radius && Math.abs(dy) <= height;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CYLINDER\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Silindir\";\n    }\n}\n","size_bytes":638},"src/main/java/com/skyorbs/ecosystem/BiosphereManager.java":{"content":"package com.skyorbs.ecosystem;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class BiosphereManager {\n\n    private final SkyOrbs plugin;\n    private final Map<UUID, BiosphereData> biosphereData = new HashMap<>();\n\n    public BiosphereManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startBiosphereUpdater();\n    }\n\n    public void initializeBiosphere(Orb orb) {\n        BiosphereData data = new BiosphereData(orb);\n        biosphereData.put(orb.getId(), data);\n    }\n\n    public void updateBiosphere(Orb orb, String activity) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data == null) return;\n\n        switch (activity) {\n            case \"mining\" -> {\n                // Mining reduces ecological balance\n                data.ecologicalBalance = Math.max(0.0, data.ecologicalBalance - 0.1);\n                // Reduce flora density\n                data.floraDensity = Math.max(0.0, data.floraDensity - 0.05);\n            }\n            case \"planting\" -> {\n                // Planting improves ecological balance\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.05);\n                // Increase flora density\n                data.floraDensity = Math.min(1.0, data.floraDensity + 0.02);\n            }\n            case \"farming\" -> {\n                // Farming has mixed effects\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.02);\n            }\n            case \"exploration\" -> {\n                // Exploration slightly improves balance through discovery\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.01);\n            }\n        }\n\n        // Update the orb's ecological balance\n        orb.setEcologicalBalance(data.ecologicalBalance);\n\n        // Check for biosphere level changes\n        updateBiosphereLevel(orb, data);\n    }\n\n    private void updateBiosphereLevel(Orb orb, BiosphereData data) {\n        int newLevel = calculateBiosphereLevel(data);\n        if (newLevel != orb.getBiosphereLevel()) {\n            orb.setBiosphereLevel(newLevel);\n            onBiosphereLevelChange(orb, newLevel);\n        }\n    }\n\n    private int calculateBiosphereLevel(BiosphereData data) {\n        double score = (data.floraDensity + data.faunaDensity + data.ecologicalBalance) / 3.0;\n\n        if (score >= 0.8) return 5;\n        else if (score >= 0.6) return 4;\n        else if (score >= 0.4) return 3;\n        else if (score >= 0.2) return 2;\n        else return 1;\n    }\n\n    private void onBiosphereLevelChange(Orb orb, int newLevel) {\n        // Trigger events based on biosphere level changes\n        switch (newLevel) {\n            case 2 -> {\n                // Unlock basic ecosystem features\n                spawnInitialFlora(orb);\n            }\n            case 3 -> {\n                // Unlock intermediate features\n                spawnIntermediateFlora(orb);\n                spawnInitialFauna(orb);\n            }\n            case 4 -> {\n                // Unlock advanced features\n                spawnAdvancedFlora(orb);\n                spawnIntermediateFauna(orb);\n            }\n            case 5 -> {\n                // Unlock maximum ecosystem features\n                spawnMaximumFlora(orb);\n                spawnMaximumFauna(orb);\n                triggerEcosystemEvent(orb, \"blossoming\");\n            }\n        }\n    }\n\n    private void spawnInitialFlora(Orb orb) {\n        // Spawn basic plants and trees\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 100);\n        int spawnCount = orb.getRadius() / 10; // Scale with planet size\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    // Spawn grass or flowers\n                    Material plant = random.nextDouble() < 0.7 ? Material.SHORT_GRASS : Material.DANDELION;\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnIntermediateFlora(Orb orb) {\n        // Spawn bushes, flowers, and small trees\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 200);\n        int spawnCount = orb.getRadius() / 8;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    Material[] plants = {Material.POPPY, Material.BLUE_ORCHID, Material.ALLIUM, Material.AZURE_BLUET,\n                                       Material.RED_TULIP, Material.ORANGE_TULIP, Material.WHITE_TULIP, Material.PINK_TULIP,\n                                       Material.DANDELION};\n                    Material plant = plants[random.nextInt(plants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnAdvancedFlora(Orb orb) {\n        // Spawn rare plants and large vegetation\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 300);\n        int spawnCount = orb.getRadius() / 6;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    Material[] rarePlants = {Material.LILAC, Material.ROSE_BUSH, Material.PEONY, Material.SUNFLOWER,\n                                           Material.LARGE_FERN, Material.TALL_GRASS};\n                    Material plant = rarePlants[random.nextInt(rarePlants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n\n                    // Some plants are 2 blocks tall\n                    if (plant == Material.LILAC || plant == Material.ROSE_BUSH || plant == Material.PEONY ||\n                        plant == Material.SUNFLOWER || plant == Material.LARGE_FERN || plant == Material.TALL_GRASS) {\n                        world.getBlockAt(x, y + 2, z).setType(plant);\n                    }\n                }\n            }\n        }\n    }\n\n    private void spawnMaximumFlora(Orb orb) {\n        // Spawn maximum variety including mushrooms and special plants\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 400);\n        int spawnCount = orb.getRadius() / 4;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK || block.getType() == Material.DIRT) {\n                    Material[] maxPlants = {Material.BROWN_MUSHROOM, Material.RED_MUSHROOM, Material.CRIMSON_FUNGUS,\n                                          Material.WARPED_FUNGUS, Material.WEEPING_VINES, Material.TWISTING_VINES,\n                                          Material.GLOW_LICHEN, Material.SPORE_BLOSSOM};\n                    Material plant = maxPlants[random.nextInt(maxPlants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnInitialFauna(Orb orb) {\n        // This would integrate with Minecraft's mob spawning system\n        // For now, just mark that fauna spawning is available\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.3;\n        }\n    }\n\n    private void spawnIntermediateFauna(Orb orb) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.5;\n        }\n    }\n\n    private void spawnMaximumFauna(Orb orb) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.8;\n        }\n    }\n\n    private void triggerEcosystemEvent(Orb orb, String eventType) {\n        // Trigger special ecosystem events\n        switch (eventType) {\n            case \"blossoming\" -> {\n                // Maximum biosphere achieved - special effects\n                plugin.getLogger().info(\"Planet \" + orb.getName() + \" has achieved maximum biosphere level!\");\n            }\n        }\n    }\n\n    private int findSurfaceY(World world, int x, int z, Orb orb) {\n        int centerY = orb.getCenterY();\n        int radius = orb.getRadius();\n\n        // Search from top to bottom within planet bounds\n        for (int y = centerY + radius; y >= centerY - radius; y--) {\n            Block block = world.getBlockAt(x, y, z);\n            Block above = world.getBlockAt(x, y + 1, z);\n\n            // Check if this is a surface block (solid below, air above)\n            if (block.getType().isSolid() && above.getType() == Material.AIR) {\n                return y;\n            }\n        }\n\n        return -1; // No surface found\n    }\n\n    private void startBiosphereUpdater() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                // Periodic biosphere updates\n                for (BiosphereData data : biosphereData.values()) {\n                    // Natural regeneration\n                    if (data.ecologicalBalance < 1.0) {\n                        data.ecologicalBalance = Math.min(1.0, data.ecologicalBalance + 0.001);\n                        data.orb.setEcologicalBalance(data.ecologicalBalance);\n                    }\n\n                    // Flora/fauna natural growth\n                    if (data.floraDensity < 0.5) {\n                        data.floraDensity = Math.min(0.5, data.floraDensity + 0.0005);\n                    }\n\n                    if (data.faunaDensity < 0.3) {\n                        data.faunaDensity = Math.min(0.3, data.faunaDensity + 0.0002);\n                    }\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 1200L); // Every minute\n    }\n\n    public BiosphereData getBiosphereData(UUID orbId) {\n        return biosphereData.get(orbId);\n    }\n\n    public static class BiosphereData {\n        public final Orb orb;\n        public double floraDensity;\n        public double faunaDensity;\n        public double ecologicalBalance;\n\n        public BiosphereData(Orb orb) {\n            this.orb = orb;\n            this.floraDensity = 0.1; // Start with minimal flora\n            this.faunaDensity = 0.0; // No fauna initially\n            this.ecologicalBalance = 1.0; // Neutral balance\n        }\n    }\n}","size_bytes":12051},"replit.md":{"content":"# SkyOrbs - Minecraft Planet Generation Plugin\n\n## Overview\n\nSkyOrbs is a Minecraft Paper plugin (version 1.21.4) that generates unique planetary worlds within a single Minecraft dimension. The plugin creates diverse planets with different shapes, biomes, and orbital features, all configurable through YAML files. Players can create personal planets, teleport between them, and explore procedurally generated celestial bodies with asteroids and satellites. The entire user interface and configuration is in Turkish (Türkçe).\n\n**Core Purpose:** Provide a skyblock-like experience where instead of traditional islands, players explore and inhabit procedurally generated planets with varied geometries, biome combinations, and orbital mechanics.\n\n**Current Status (Oct 17, 2025):** ✅ Version 2.0.1 Complete - Fully functional with all 17 shapes, 22 biomes, database persistence, and Turkish UI. \n- **Fixed:** Server freeze during planet generation (batch block placement)\n- **Fixed:** Asteroids and satellites now generate with blocks\n- **Fixed:** Ores now spawn inside planets\n- **Fixed:** Auto-teleport after planet creation\n- JAR compiled and ready for deployment (14MB).\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Plugin Architecture\n- **Framework:** Paper API 1.21.4 (Spigot/Bukkit not supported)\n- **Language:** Java 21+\n- **Build System:** Maven 3.8+\n- **Architecture Pattern:** Command-driven with modular generator systems\n\n### Core Components\n\n#### 1. Planet Generation System\n- **PlanetGenerator:** Main orchestrator for planet creation\n  - Selects random planet types, biomes, and dimensions from weighted pools\n  - Coordinates with specialized generators for different planet shapes\n  - Manages planet metadata and persistence\n  \n- **17+ Planet Shape Generators:** Each shape (Sphere, Ameba, Asteroid, Ellipse, Donut, Ring, Cylinder, Cone, Diamond, Cube, Pyramid, Octahedron, Fractal, Spiky, Comet, Crescent, Hybrid) implements unique geometric algorithms\n  - Rationale: Variety creates unique exploration experiences and visual interest\n  - Trade-off: More shapes = more complex codebase, but increases replayability\n\n- **PlanetSizeCalculator:** Determines planet radius based on configurable min/max bounds\n  - Dynamic sizing ensures planets fit within allocated space without collisions\n\n#### 2. Biome and Terrain System\n- **22 Biome Types:** Forest, Desert, Glacier, Volcanic, Crystal Forest, Void, and 16+ others\n- **BiomeManager:** Applies 1-3 biome blends per planet\n  - Creates transition zones between biomes for realistic terrain\n  - Each biome affects block composition and visual aesthetics\n\n- **OreDistributor:** Handles mineral placement within planet structure\n- **StructureGenerator:** Places decorative or functional structures on planet surfaces\n\n#### 3. Orbital Mechanics\n- **Asteroid System:** 1-5 asteroids generated per planet\n  - Positioned in orbital patterns around parent planet\n  - Fully configurable density and distribution\n\n- **Satellite System:** 0-3 satellites per planet (probability-based)\n  - Smaller companion celestial bodies\n  - Can have their own biomes and compositions\n\n#### 4. Spatial Management\n- **Smart Placement Algorithm:**\n  - Planets spawn 800-2000 blocks apart (prevents overlap)\n  - Minimum 1000 blocks from world spawn point\n  - Ensures each planet has adequate \"breathing room\" for asteroids/satellites\n\n- **Coordinate System:** All planets exist in a single world dimension with calculated spacing\n  - Alternative considered: Multi-world approach (rejected due to performance overhead)\n\n#### 5. Player Interaction Layer\n- **Command System:** Turkish-language commands\n  - `/gezegen create` - Generate new planet and teleport player\n  - `/gezegen list` - Display all existing planets\n  - `/gezegen tp <name>` - Teleport to specific planet\n  - `/gezegen info <name>` - Show planet details and distances to nearby planets\n  - `/gezegen sil <name>` - Delete planet (admin only)\n  - `/gezegen reload` - Reload configuration (admin only)\n\n- **TeleportHandler:** Manages player transportation between planets\n  - Proposed: 5-second \"landing animation\" with particle effects and slow fall\n  - Prevents fall damage and provides immersive transition\n\n#### 6. Configuration System\n- **config.yml Driven Design:** All game parameters externalized\n  - Planet size ranges (min/max radius)\n  - Inter-planet distances\n  - Shape weights (probability distribution for each of 17 shapes)\n  - Biome distributions\n  - Asteroid/satellite spawn rates\n  - 1000+ Turkish and sci-fi themed planet name pool\n  - All UI messages in Turkish\n\n- **Hot-Reload Support:** `/gezegen reload` allows runtime configuration updates without server restart\n\n### Data Persistence\n- **SQLite Database:** All planet data stored in `data.db` file\n  - Stores: Planet UUID, name, location, owner, shape type, biomes, dimensions, timestamps\n  - Parent-child relationships for asteroids and satellites (foreign key constraints)\n  - DatabaseManager handles CRUD operations with prepared statements\n  - Async-safe operations using thread pool executor\n\n### Design Patterns Used\n1. **Factory Pattern:** Planet shape generators created based on type selection\n2. **Strategy Pattern:** Different biome application strategies per planet type\n3. **Command Pattern:** Player commands abstracted into discrete handlers\n4. **Builder Pattern:** Implied in complex planet construction process\n\n## External Dependencies\n\n### Core Minecraft Dependencies\n- **Paper API 1.21.4:** Primary server framework\n  - Chosen over Spigot/Bukkit for better performance and modern API features\n  - Provides world manipulation, chunk generation, and event handling\n\n### Build and Development Tools\n- **Maven 3.8+:** Dependency management and build automation\n  - Standard for Minecraft plugin development\n  - Handles Paper API dependency resolution\n\n### Java Runtime\n- **JDK 21:** Modern Java features and performance improvements\n  - Required for Paper 1.21.4 compatibility\n  - Enables use of records, pattern matching, and other modern Java features\n\n### Actual Dependencies\n- **SQLite JDBC 3.44.0.0:** Database persistence layer\n- **Gson 2.10.1:** JSON serialization (future use)\n- **SLF4J 2.0.9:** Logging framework\n\n### Potential Future Integrations\n- **Particle Effects System:** For planet landing animations (planned)\n- **Economy Integration:** Planet trading/claiming (planned)\n- **Vault Permission System:** Enhanced permission control (planned)\n\n### Configuration Format\n- **YAML:** Primary configuration and data storage format\n  - Human-readable for server administrators\n  - Nested structure supports complex planet definitions and name pools","size_bytes":6714},"src/main/java/com/skyorbs/palettes/PlanetPalette.java":{"content":"package com.skyorbs.palettes;\n\nimport org.bukkit.Material;\nimport java.util.Random;\n\n/**\n * Defines a planet's block composition for diverse visual variety\n * Enables 2000+ planet combinations through modular palette system\n */\npublic class PlanetPalette {\n    \n    private final String id;\n    private final String displayName;\n    private final Material[] surfaceBlocks;\n    private final Material[] subsurfaceBlocks;\n    private final Material[] coreBlocks;\n    private final Material[] decorationBlocks;\n    private final double weight;\n    \n    public PlanetPalette(String id, String displayName, \n                        Material[] surfaceBlocks, \n                        Material[] subsurfaceBlocks,\n                        Material[] coreBlocks,\n                        Material[] decorationBlocks,\n                        double weight) {\n        this.id = id;\n        this.displayName = displayName;\n        this.surfaceBlocks = surfaceBlocks;\n        this.subsurfaceBlocks = subsurfaceBlocks;\n        this.coreBlocks = coreBlocks;\n        this.decorationBlocks = decorationBlocks;\n        this.weight = weight;\n    }\n    \n    public String getId() {\n        return id;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getWeight() {\n        return weight;\n    }\n    \n    /**\n     * Get material based on depth from surface\n     * @param depth 0 = surface, higher = deeper\n     * @param random Random for variation\n     * @return Material for this depth\n     */\n    public Material getMaterialByDepth(int depth, Random random) {\n        if (depth == 0) {\n            // Surface layer\n            return surfaceBlocks[random.nextInt(surfaceBlocks.length)];\n        } else if (depth < 5) {\n            // Subsurface layer (0-5 blocks deep)\n            return subsurfaceBlocks[random.nextInt(subsurfaceBlocks.length)];\n        } else {\n            // Core layer (5+ blocks deep)\n            return coreBlocks[random.nextInt(coreBlocks.length)];\n        }\n    }\n    \n    /**\n     * Get random decoration block for surface features\n     */\n    public Material getDecorationBlock(Random random) {\n        if (decorationBlocks.length == 0) return null;\n        return decorationBlocks[random.nextInt(decorationBlocks.length)];\n    }\n    \n    /**\n     * Get surface material\n     */\n    public Material getPrimarySurface() {\n        return surfaceBlocks[0];\n    }\n    \n    /**\n     * Get core material\n     */\n    public Material getPrimaryCore() {\n        return coreBlocks[0];\n    }\n}\n","size_bytes":2544},"src/main/java/com/skyorbs/features/StructureGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class StructureGenerator {\n    \n    public static List<OreGenerator.BlockData> generateStructures(Orb orb, BiomeType biome, World world) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        // Use deterministic seed based on biome + planet seed for consistent structures\n        Random random = new Random(orb.getSeed() + biome.name().hashCode());\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Get biome-specific structure configuration\n        StructureConfig config = getStructureConfig(biome);\n        if (config == null) return blocks;\n\n        // Configurable structure density\n        double densityMultiplier = com.skyorbs.SkyOrbs.getInstance().getConfigManager().getStructureDensityMultiplier();\n        int structureCount = (int)(radius * config.density * densityMultiplier);\n\n        for (int i = 0; i < structureCount; i++) {\n            // Generate positions within planet bounds\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n            int y = cy + radius; // Surface level\n\n            // Select structure type based on biome\n            StructureType type = config.getRandomType(random);\n\n            // Generate the structure\n            generateStructure(blocks, x, y, z, type, random, biome);\n        }\n\n        return blocks;\n    }\n    \n    /**\n     * Generate a single structure with biome-specific variations\n     */\n    private static void generateStructure(List<OreGenerator.BlockData> blocks, int x, int y, int z,\n                                          StructureType type, Random random, BiomeType biome) {\n        \n        switch (type) {\n            case DESERT_TEMPLE -> generateDesertTemple(blocks, x, y, z, random, biome);\n            case JUNGLE_TEMPLE -> generateJungleTemple(blocks, x, y, z, random, biome);\n            case VILLAGE_HOUSE -> generateVillageHouse(blocks, x, y, z, random, biome);\n            case IGLOO -> generateIgloo(blocks, x, y, z, random, biome);\n            case NETHER_FORTRESS -> generateNetherFortress(blocks, x, y, z, random, biome);\n            case END_TOWER -> generateEndTower(blocks, x, y, z, random, biome);\n            case CRYSTAL_SPIRE -> generateCrystalSpire(blocks, x, y, z, random, biome);\n            case MUSHROOM_HUT -> generateMushroomHut(blocks, x, y, z, random, biome);\n            case RUINS -> generateRuins(blocks, x, y, z, random, biome);\n            case ALTAR -> generateAltar(blocks, x, y, z, random, biome);\n        }\n    }\n    \n    /**\n     * Desert temple with biome-specific variations\n     */\n    private static void generateDesertTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Temel (9x9)\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.SANDSTONE));\n            }\n        }\n        \n        // Duvarlar\n        for (int dy = 1; dy <= 5; dy++) {\n            for (int dx = -4; dx <= 4; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 4, Material.SANDSTONE));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 4, Material.SANDSTONE));\n            }\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 4, y + dy, z + dz, Material.SANDSTONE));\n                blocks.add(new OreGenerator.BlockData(x + 4, y + dy, z + dz, Material.SANDSTONE));\n            }\n        }\n        \n        // Çatı\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 6, z + dz, Material.ORANGE_TERRACOTTA));\n            }\n        }\n        \n        // Hazine odası (yeraltı)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y - 3, z + dz, Material.STONE_BRICKS));\n            }\n        }\n        \n        // Treasure chest with biome-specific loot\n        blocks.add(new OreGenerator.BlockData(x, y - 2, z, Material.CHEST));\n\n        // Biome-specific traps and decorations\n        if (biome == BiomeType.TOXIC_SWAMP || biome == BiomeType.TOXIC) {\n            // Toxic biome - poison traps\n            blocks.add(new OreGenerator.BlockData(x + 1, y - 2, z + 1, Material.POISONOUS_POTATO));\n            blocks.add(new OreGenerator.BlockData(x - 1, y - 2, z - 1, Material.POISONOUS_POTATO));\n        } else {\n            // Standard traps\n            blocks.add(new OreGenerator.BlockData(x + 1, y - 2, z + 1, Material.TNT));\n            blocks.add(new OreGenerator.BlockData(x - 1, y - 2, z - 1, Material.TNT));\n        }\n    }\n    \n    /**\n     * Orman tapınağı\n     */\n    private static void generateJungleTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Piramit tabanı (11x11)\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.MOSSY_COBBLESTONE));\n            }\n        }\n        \n        // Piramit katları\n        for (int level = 1; level <= 6; level++) {\n            int size = 6 - level;\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    Material mat = random.nextBoolean() ? Material.MOSSY_COBBLESTONE : Material.COBBLESTONE;\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + level, z + dz, mat));\n                }\n            }\n        }\n        \n        // Hazine sandığı\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.CHEST));\n        \n        // Asma yapraklar\n        for (int i = 0; i < 10; i++) {\n            int vineX = x + random.nextInt(11) - 5;\n            int vineZ = z + random.nextInt(11) - 5;\n            int vineLength = 2 + random.nextInt(4);\n            for (int vl = 0; vl < vineLength; vl++) {\n                blocks.add(new OreGenerator.BlockData(vineX, y + 7 - vl, vineZ, Material.VINE));\n            }\n        }\n    }\n    \n    /**\n     * Köy evi\n     */\n    private static void generateVillageHouse(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Temel (7x7)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.OAK_PLANKS));\n            }\n        }\n        \n        // Duvarlar\n        for (int dy = 1; dy <= 3; dy++) {\n            for (int dx = -3; dx <= 3; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 3, Material.OAK_LOG));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 3, Material.OAK_LOG));\n            }\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 3, y + dy, z + dz, Material.OAK_LOG));\n                blocks.add(new OreGenerator.BlockData(x + 3, y + dy, z + dz, Material.OAK_LOG));\n            }\n        }\n        \n        // Çatı\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 4, z + dz, Material.OAK_STAIRS));\n            }\n        }\n        \n        // Kapı\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z - 3, Material.OAK_DOOR));\n        blocks.add(new OreGenerator.BlockData(x, y + 2, z - 3, Material.OAK_DOOR));\n        \n        // İç mobilyalar\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.CRAFTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.RED_BED));\n    }\n    \n    /**\n     * İglo\n     */\n    private static void generateIgloo(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Kubbe şekli (6x6 taban)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                double distance = Math.sqrt(dx * dx + dz * dz);\n                if (distance <= 3) {\n                    blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.SNOW_BLOCK));\n                    \n                    if (distance <= 2.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + 1, z + dz, Material.SNOW_BLOCK));\n                    }\n                    if (distance <= 1.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + 2, z + dz, Material.SNOW_BLOCK));\n                    }\n                }\n            }\n        }\n        \n        // Giriş\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z - 3, Material.AIR));\n        \n        // İçeride mobilya\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.FURNACE));\n        blocks.add(new OreGenerator.BlockData(x - 1, y + 1, z + 1, Material.CHEST));\n    }\n    \n    /**\n     * Nether kalesi\n     */\n    private static void generateNetherFortress(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Temel platform\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.NETHER_BRICKS));\n            }\n        }\n        \n        // Kuleler (4 köşe)\n        int[][] corners = {{-5, -5}, {5, -5}, {-5, 5}, {5, 5}};\n        for (int[] corner : corners) {\n            for (int dy = 1; dy <= 8; dy++) {\n                blocks.add(new OreGenerator.BlockData(x + corner[0], y + dy, z + corner[1], Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + corner[0] + (corner[0] > 0 ? -1 : 1), y + dy, z + corner[1], Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + corner[0], y + dy, z + corner[1] + (corner[1] > 0 ? -1 : 1), Material.NETHER_BRICKS));\n            }\n            // Kule tepesi\n            blocks.add(new OreGenerator.BlockData(x + corner[0], y + 9, z + corner[1], Material.NETHER_BRICK_FENCE));\n        }\n        \n        // Merkez yapı\n        for (int dy = 1; dy <= 5; dy++) {\n            for (int dx = -2; dx <= 2; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 2, Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 2, Material.NETHER_BRICKS));\n            }\n        }\n        \n        // Spawner\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.SPAWNER));\n        \n        // Lava dekorasyonu\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z, Material.LAVA));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z, Material.LAVA));\n    }\n    \n    /**\n     * End kulesi\n     */\n    private static void generateEndTower(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Yüksek kule (15 blok)\n        for (int dy = 0; dy <= 15; dy++) {\n            for (int dx = -2; dx <= 2; dx++) {\n                for (int dz = -2; dz <= 2; dz++) {\n                    if (Math.abs(dx) == 2 || Math.abs(dz) == 2) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, Material.END_STONE_BRICKS));\n                    }\n                }\n            }\n        }\n        \n        // Tepe kristali\n        blocks.add(new OreGenerator.BlockData(x, y + 16, z, Material.END_ROD));\n        blocks.add(new OreGenerator.BlockData(x, y + 17, z, Material.PURPUR_BLOCK));\n        \n        // Chorus bitkileri\n        for (int i = 0; i < 5; i++) {\n            int chX = x + random.nextInt(9) - 4;\n            int chZ = z + random.nextInt(9) - 4;\n            int height = 2 + random.nextInt(4);\n            for (int h = 0; h < height; h++) {\n                blocks.add(new OreGenerator.BlockData(chX, y + h, chZ, Material.CHORUS_PLANT));\n            }\n        }\n    }\n    \n    /**\n     * Kristal diken\n     */\n    private static void generateCrystalSpire(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        int height = 10 + random.nextInt(8);\n        \n        for (int dy = 0; dy < height; dy++) {\n            int size = Math.max(1, 3 - dy / 3);\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    Material mat = random.nextBoolean() ? Material.AMETHYST_BLOCK : Material.BUDDING_AMETHYST;\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, mat));\n                }\n            }\n        }\n        \n        // Parlayan tepe\n        blocks.add(new OreGenerator.BlockData(x, y + height, z, Material.SEA_LANTERN));\n    }\n    \n    /**\n     * Mantar kulübesi\n     */\n    private static void generateMushroomHut(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Kök\n        blocks.add(new OreGenerator.BlockData(x, y, z, Material.MUSHROOM_STEM));\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.MUSHROOM_STEM));\n        blocks.add(new OreGenerator.BlockData(x, y + 2, z, Material.MUSHROOM_STEM));\n        \n        // Şapka\n        Material capMaterial = random.nextBoolean() ? Material.RED_MUSHROOM_BLOCK : Material.BROWN_MUSHROOM_BLOCK;\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 3, z + dz, capMaterial));\n            }\n        }\n    }\n    \n    /**\n     * Harabeler\n     */\n    private static void generateRuins(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Yarım duvarlar\n        for (int i = 0; i < 10; i++) {\n            int rX = x + random.nextInt(9) - 4;\n            int rZ = z + random.nextInt(9) - 4;\n            int height = 1 + random.nextInt(3);\n            \n            Material mat = random.nextBoolean() ? Material.STONE_BRICKS : Material.CRACKED_STONE_BRICKS;\n            for (int dy = 0; dy < height; dy++) {\n                blocks.add(new OreGenerator.BlockData(rX, y + dy, rZ, mat));\n            }\n        }\n        \n        // Sandık\n        blocks.add(new OreGenerator.BlockData(x, y, z, Material.CHEST));\n    }\n    \n    /**\n     * Sunak\n     */\n    private static void generateAltar(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome) {\n        // Platform (5x5)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.QUARTZ_BLOCK));\n            }\n        }\n        \n        // Merkez sütun\n        for (int dy = 1; dy <= 3; dy++) {\n            blocks.add(new OreGenerator.BlockData(x, y + dy, z, Material.QUARTZ_PILLAR));\n        }\n        \n        // Ateş\n        blocks.add(new OreGenerator.BlockData(x, y + 4, z, Material.FIRE));\n        \n        // Köşe meşaleler\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z - 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z + 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.TORCH));\n    }\n    \n    /**\n     * Biyom bazlı yapı konfigürasyonu\n     */\n    private static StructureConfig getStructureConfig(BiomeType biome) {\n        return switch (biome) {\n            case DESERT, BADLANDS -> new StructureConfig(0.015,\n                new StructureType[]{StructureType.DESERT_TEMPLE, StructureType.RUINS},\n                new double[]{0.7, 0.3});\n            \n            case JUNGLE -> new StructureConfig(0.012,\n                new StructureType[]{StructureType.JUNGLE_TEMPLE, StructureType.RUINS},\n                new double[]{0.8, 0.2});\n            \n            case PLAINS, SAVANNA, MEADOW -> new StructureConfig(0.020,\n                new StructureType[]{StructureType.VILLAGE_HOUSE, StructureType.RUINS},\n                new double[]{0.6, 0.4});\n            \n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> new StructureConfig(0.010,\n                new StructureType[]{StructureType.IGLOO},\n                new double[]{1.0});\n            \n            case LAVA_OCEAN, MAGMA_CAVES, OBSIDIAN_PLAINS -> new StructureConfig(0.008,\n                new StructureType[]{StructureType.NETHER_FORTRESS, StructureType.RUINS},\n                new double[]{0.7, 0.3});\n            \n            case VOID, CHORUS_LAND -> new StructureConfig(0.010,\n                new StructureType[]{StructureType.END_TOWER},\n                new double[]{1.0});\n            \n            case CRYSTAL_FOREST -> new StructureConfig(0.025,\n                new StructureType[]{StructureType.CRYSTAL_SPIRE, StructureType.ALTAR},\n                new double[]{0.7, 0.3});\n            \n            case MUSHROOM_GIANT -> new StructureConfig(0.030,\n                new StructureType[]{StructureType.MUSHROOM_HUT},\n                new double[]{1.0});\n            \n            default -> null;\n        };\n    }\n    \n    /**\n     * Yapı türleri\n     */\n    private enum StructureType {\n        DESERT_TEMPLE,\n        JUNGLE_TEMPLE,\n        VILLAGE_HOUSE,\n        IGLOO,\n        NETHER_FORTRESS,\n        END_TOWER,\n        CRYSTAL_SPIRE,\n        MUSHROOM_HUT,\n        RUINS,\n        ALTAR\n    }\n    \n    /**\n     * Biyom yapı konfigürasyonu\n     */\n    private static class StructureConfig {\n        final double density;\n        final StructureType[] types;\n        final double[] weights;\n        \n        StructureConfig(double density, StructureType[] types, double[] weights) {\n            this.density = density;\n            this.types = types;\n            this.weights = weights;\n        }\n        \n        StructureType getRandomType(Random random) {\n            double total = 0;\n            for (double w : weights) total += w;\n            \n            double rand = random.nextDouble() * total;\n            double current = 0;\n            \n            for (int i = 0; i < types.length; i++) {\n                current += weights[i];\n                if (rand <= current) {\n                    return types[i];\n                }\n            }\n            \n            return types[0];\n        }\n    }\n}","size_bytes":18991},"src/main/java/com/skyorbs/features/SatelliteGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class SatelliteGenerator {\n\n    private final SkyOrbs plugin;\n\n    public SatelliteGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Ana gezegen için uydular üretir\n     */\n    public List<Orb> generateSatellitesForPlanet(Orb planet, World world) {\n        List<Orb> satellites = new ArrayList<>();\n        Random random = new Random(planet.getSeed() + 777);\n\n        int minCount = plugin.getConfigManager().getMinSatellitesPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxSatellitesPerPlanet();\n\n        // Olasılık kontrolü\n        double probability = plugin.getConfigManager().getSatelliteProbability();\n        if (random.nextDouble() > probability) {\n            return satellites; // Uydu yok\n        }\n\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            Orb satellite = createSatellite(planet, world, random);\n            if (satellite != null) {\n                satellites.add(satellite);\n            }\n        }\n\n        return satellites;\n    }\n\n    /**\n     * Tek bir uydu oluşturur\n     */\n    private Orb createSatellite(Orb parentPlanet, World world, Random random) {\n        // Uydu boyutu ana gezegenden küçük\n        int parentRadius = parentPlanet.getRadius();\n        int minRadius = Math.max(15, parentRadius / 4);\n        int maxRadius = Math.max(25, parentRadius / 2);\n        int radius = minRadius + random.nextInt(maxRadius - minRadius + 1);\n\n        // Şekil seçimi (daha yuvarlak uydular)\n        String shapeName;\n        double shapeRand = random.nextDouble();\n        if (shapeRand < 0.5) {\n            shapeName = \"SPHERE\";\n        } else if (shapeRand < 0.8) {\n            shapeName = \"ELLIPSOID\";\n        } else {\n            shapeName = \"BLOB\";\n        }\n\n        // Biyom seçimi (uzay temalı)\n        BiomeType biome = getRandomSatelliteBiome(random);\n\n        // Pozisyon hesaplama (daha uzak)\n        int[] position = calculateSatellitePosition(parentPlanet, random);\n        int centerX = position[0];\n        int centerY = position[1];\n        int centerZ = position[2];\n\n        // İsim oluşturma\n        String name = \"Satellite-\" + UUID.randomUUID().toString().substring(0, 6);\n\n        // Seed oluşturma\n        long seed = random.nextLong();\n\n        return new Orb(\n            UUID.randomUUID(),\n            name,\n            world.getName(),\n            centerX,\n            centerY,\n            centerZ,\n            radius,\n            shapeName,\n            biome.name(),\n            seed,\n            System.currentTimeMillis(),\n            false, // isAsteroid = false (uydu)\n            parentPlanet.getId()\n        );\n    }\n\n    /**\n     * Uydu pozisyonunu hesaplar (asteroidlerden daha uzak)\n     */\n    private int[] calculateSatellitePosition(Orb parentPlanet, Random random) {\n        int parentX = parentPlanet.getCenterX();\n        int parentY = parentPlanet.getCenterY();\n        int parentZ = parentPlanet.getCenterZ();\n\n        // Uydular daha uzak (800-1500 blok)\n        int minDistance = 800;\n        int maxDistance = 1500;\n        int distance = minDistance + random.nextInt(maxDistance - minDistance + 1);\n\n        // Rastgele açı\n        double angle = random.nextDouble() * 2 * Math.PI;\n\n        int x = parentX + (int)(Math.cos(angle) * distance);\n        int z = parentZ + (int)(Math.sin(angle) * distance);\n        int y = parentY + random.nextInt(101) - 50; // ±50 varyasyon\n\n        return new int[]{x, y, z};\n    }\n\n    /**\n     * Uydu için uygun biyom seçer\n     */\n    private BiomeType getRandomSatelliteBiome(Random random) {\n        // Uydular için daha egzotik biyomlar\n        BiomeType[] satelliteBiomes = {\n            BiomeType.CRYSTAL_FOREST,\n            BiomeType.VOID,\n            BiomeType.ICE_SPIKES,\n            BiomeType.LAVA_OCEAN\n        };\n\n        return satelliteBiomes[random.nextInt(satelliteBiomes.length)];\n    }\n\n    /**\n     * Uydu bloklarını üretir\n     */\n    public List<OreGenerator.BlockData> generateSatelliteBlocks(Orb satellite, BiomeType biome) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(satellite.getSeed());\n\n        int cx = satellite.getCenterX();\n        int cy = satellite.getCenterY();\n        int cz = satellite.getCenterZ();\n        int radius = satellite.getRadius();\n\n        // Uydu şekli için shape al\n        var shape = plugin.getShapeRegistry().getShape(satellite.getShapeName());\n        if (shape == null) {\n            shape = plugin.getShapeRegistry().getShape(\"SPHERE\");\n        }\n\n        // Ana bloklar\n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    if (shape.isBlockPart(x, y, z, radius, satellite.getSeed())) {\n                        Material material = getSatelliteMaterial(biome, random);\n                        blocks.add(new OreGenerator.BlockData(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        // Uydu özellikleri (daha nadir)\n        generateSatelliteFeatures(blocks, satellite, biome, random);\n\n        return blocks;\n    }\n\n    /**\n     * Uydu malzemesi seçer\n     */\n    private Material getSatelliteMaterial(BiomeType biome, Random random) {\n        // Biyom bazlı egzotik malzemeler\n        Material[] materials = switch (biome) {\n            case CRYSTAL_FOREST -> new Material[]{Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.PURPUR_BLOCK};\n            case VOID -> new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.PURPUR_BLOCK};\n            case ICE_SPIKES -> new Material[]{Material.PACKED_ICE, Material.BLUE_ICE, Material.ICE};\n            case LAVA_OCEAN -> new Material[]{Material.MAGMA_BLOCK, Material.OBSIDIAN, Material.BLACKSTONE};\n            default -> new Material[]{Material.STONE, Material.ANDESITE, Material.DIORITE};\n        };\n\n        return materials[random.nextInt(materials.length)];\n    }\n\n    /**\n     * Uydu özel özellikleri üretir\n     */\n    private void generateSatelliteFeatures(List<OreGenerator.BlockData> blocks, Orb satellite, BiomeType biome, Random random) {\n        int cx = satellite.getCenterX();\n        int cy = satellite.getCenterY();\n        int cz = satellite.getCenterZ();\n        int radius = satellite.getRadius();\n\n        // Özel yapılar (çok nadir)\n        int featureCount = Math.max(1, radius / 10);\n\n        for (int i = 0; i < featureCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int y = cy + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Sadece uydu içinde ise\n            double distance = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n            if (distance <= radius - 1) {\n                Material feature = getSatelliteFeature(biome, random);\n                if (feature != null) {\n                    blocks.add(new OreGenerator.BlockData(x, y, z, feature));\n                }\n            }\n        }\n    }\n\n    /**\n     * Uydu özel malzemesi seçer\n     */\n    private Material getSatelliteFeature(BiomeType biome, Random random) {\n        // Özel malzemeler\n        Material[] features = switch (biome) {\n            case CRYSTAL_FOREST -> new Material[]{Material.AMETHYST_CLUSTER, Material.SMALL_AMETHYST_BUD};\n            case VOID -> new Material[]{Material.END_ROD, Material.CHORUS_PLANT};\n            case ICE_SPIKES -> new Material[]{Material.BLUE_ICE, Material.PACKED_ICE};\n            case LAVA_OCEAN -> new Material[]{Material.LAVA, Material.MAGMA_BLOCK};\n            default -> null;\n        };\n\n        return features != null ? features[random.nextInt(features.length)] : null;\n    }\n}","size_bytes":8185},"src/main/java/com/skyorbs/shapes/impl/RingShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class RingShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        int thickness = 3;\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        return Math.abs(dy) <= thickness && distance <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"RING\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Halka\";\n    }\n}\n","size_bytes":628},"src/main/java/com/skyorbs/shapes/impl/CubeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CubeShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        return Math.abs(dx) <= radius && Math.abs(dy) <= radius && Math.abs(dz) <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CUBE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Küp\";\n    }\n}\n","size_bytes":571},"src/main/java/com/skyorbs/shapes/PlanetShape.java":{"content":"package com.skyorbs.shapes;\n\npublic interface PlanetShape {\n    \n    boolean isBlockPart(int dx, int dy, int dz, int radius, long seed);\n    \n    String getName();\n    \n    double getDeformationFactor();\n    \n    String getDisplayName();\n}\n","size_bytes":240},"src/main/java/com/skyorbs/shapes/ShapeRegistry.java":{"content":"package com.skyorbs.shapes;\n\nimport com.skyorbs.shapes.impl.*;\n\nimport java.util.*;\n\npublic class ShapeRegistry {\n    \n    private final Map<String, PlanetShape> shapes = new HashMap<>();\n    private final Random random = new Random();\n    \n    public void registerAllShapes() {\n        // Basic shapes (10)\n        register(new SphereShape());\n        register(new HemisphereShape());\n        register(new BlobShape());\n        register(new AsteroidShape());\n        register(new EllipsoidShape());\n        register(new TorusShape());\n        register(new RingShape());\n        register(new CylinderShape());\n        register(new ConeShape());\n        register(new DiamondShape());\n\n        // Advanced shapes (8)\n        register(new CubeShape());\n        register(new PyramidShape());\n        register(new OctahedronShape());\n        register(new FractalShape());\n        register(new SpikyShape());\n        register(new CometShape());\n        register(new CrescentShape());\n        register(new HybridShape());\n    }\n    \n    public void register(PlanetShape shape) {\n        shapes.put(shape.getName(), shape);\n    }\n    \n    public PlanetShape getShape(String name) {\n        return shapes.getOrDefault(name, shapes.get(\"SPHERE\"));\n    }\n    \n    public PlanetShape getRandomShape(Map<String, Double> weights) {\n        double total = 0.0;\n        for (double weight : weights.values()) {\n            total += weight;\n        }\n        \n        double rand = random.nextDouble() * total;\n        double current = 0.0;\n        \n        for (Map.Entry<String, Double> entry : weights.entrySet()) {\n            current += entry.getValue();\n            if (rand <= current) {\n                PlanetShape shape = shapes.get(entry.getKey());\n                if (shape != null) {\n                    return shape;\n                }\n            }\n        }\n        \n        return shapes.get(\"SPHERE\");\n    }\n    \n    public Set<String> getShapeNames() {\n        return shapes.keySet();\n    }\n    \n    public int getShapeCount() {\n        return shapes.size();\n    }\n}\n","size_bytes":2067},"src/main/java/com/skyorbs/generation/AsteroidGenerator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class AsteroidGenerator {\n\n    private final SkyOrbs plugin;\n\n    public AsteroidGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public List<Orb> generateAsteroidsForPlanet(Orb planet, World world) {\n        List<Orb> asteroids = new ArrayList<>();\n\n        if (!plugin.getConfigManager().isAsteroidsEnabled()) {\n            return asteroids;\n        }\n\n        Random random = new Random(planet.getSeed() + 12345);\n\n        int minCount = plugin.getConfigManager().getMinAsteroidsPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxAsteroidsPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            int radius = plugin.getConfigManager().getMinAsteroidRadius() +\n                        random.nextInt(plugin.getConfigManager().getMaxAsteroidRadius() -\n                                     plugin.getConfigManager().getMinAsteroidRadius() + 1);\n\n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = plugin.getConfigManager().getMinAsteroidDistance() +\n                          random.nextInt(plugin.getConfigManager().getMaxAsteroidDistance() -\n                                       plugin.getConfigManager().getMinAsteroidDistance());\n\n            int x = planet.getCenterX() + (int)(Math.cos(angle) * distance);\n            int z = planet.getCenterZ() + (int)(Math.sin(angle) * distance);\n            int y = planet.getCenterY() + random.nextInt(41) - 20;\n\n            BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n\n            // Select asteroid shape and add visual effects\n            String shapeName = getAsteroidShapeForBiome(biome, random);\n\n            Orb asteroid = new Orb(\n                UUID.randomUUID(),\n                planet.getName() + \"_Asteroid_\" + (i + 1),\n                world.getName(),\n                x, y, z,\n                radius,\n                shapeName,\n                biome.name(),\n                planet.getSeed() + i + 1000,\n                System.currentTimeMillis(),\n                true,\n                planet.getId()\n            );\n\n            asteroids.add(asteroid);\n\n            // Add asteroid field effects (debris around asteroid)\n            if (random.nextDouble() < 0.3) { // 30% chance for asteroid field\n                generateAsteroidField(planet, world, x, y, z, radius, random);\n            }\n        }\n\n        return asteroids;\n    }\n\n    /**\n     * Generate asteroid field debris around asteroid\n     */\n    private void generateAsteroidField(Orb planet, World world, int ax, int ay, int az, int asteroidRadius, Random random) {\n        int debrisCount = 5 + random.nextInt(15); // 5-20 debris pieces\n\n        for (int i = 0; i < debrisCount; i++) {\n            // Generate debris within 50-100 blocks of asteroid\n            double angle = random.nextDouble() * 2 * Math.PI;\n            double distance = 50 + random.nextDouble() * 50;\n\n            int x = ax + (int)(Math.cos(angle) * distance);\n            int z = az + (int)(Math.sin(angle) * distance);\n            int y = ay + random.nextInt(21) - 10; // ±10 blocks\n\n            // Only place if not too close to planet\n            double planetDist = Math.sqrt((x - planet.getCenterX()) * (x - planet.getCenterX()) +\n                                        (y - planet.getCenterY()) * (y - planet.getCenterY()) +\n                                        (z - planet.getCenterZ()) * (z - planet.getCenterZ()));\n\n            if (planetDist > planet.getRadius() + 20) { // At least 20 blocks from planet surface\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                    Material debrisMaterial = getDebrisMaterial(random);\n                    block.setType(debrisMaterial, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get appropriate asteroid shape for biome\n     */\n    private String getAsteroidShapeForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> random.nextBoolean() ? \"DIAMOND\" : \"OCTAHEDRON\";\n            case LAVA_OCEAN, MAGMA_CAVES -> \"SPHERE\"; // Smooth volcanic asteroids\n            case VOID -> \"CUBE\"; // Geometric void asteroids\n            case CORRUPTED -> \"SPIKY\"; // Spiky corrupted asteroids\n            case FROZEN_TUNDRA, GLACIER -> \"FRACTAL\"; // Irregular ice asteroids\n            default -> \"ASTEROID\"; // Default irregular shape\n        };\n    }\n\n    /**\n     * Get random debris material for asteroid fields\n     */\n    private Material getDebrisMaterial(Random random) {\n        Material[] debrisMaterials = {\n            Material.STONE, Material.COBBLESTONE, Material.ANDESITE, Material.DIORITE, Material.GRANITE,\n            Material.IRON_ORE, Material.COAL_ORE, Material.GOLD_ORE, Material.REDSTONE_ORE\n        };\n        return debrisMaterials[random.nextInt(debrisMaterials.length)];\n    }\n}\n","size_bytes":5349},"src/main/java/com/skyorbs/effects/PlanetEffectManager.java":{"content":"package com.skyorbs.effects;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class PlanetEffectManager {\n\n    private final SkyOrbs plugin;\n    private final Map<UUID, PlanetAura> activeAuras = new HashMap<>();\n    private final Map<UUID, PlanetSoundscape> activeSoundscapes = new HashMap<>();\n    private final Random random = new Random();\n\n    public PlanetEffectManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startEffectUpdater();\n    }\n\n    public void applyPlanetEffects(Player player, Orb orb) {\n        UUID playerId = player.getUniqueId();\n\n        // Remove old effects\n        removePlanetEffects(playerId);\n\n        // Apply new effects based on biome and atmosphere\n        BiomeType biome = BiomeType.valueOf(orb.getBiomeName());\n        applyAtmosphericEffects(player, biome);\n        applyAura(player, orb);\n        applySoundscape(player, orb);\n        applyParticles(player, biome);\n        applySkyEffects(player, biome);\n    }\n\n    public void removePlanetEffects(UUID playerId) {\n        if (activeAuras.containsKey(playerId)) {\n            activeAuras.get(playerId).stop();\n            activeAuras.remove(playerId);\n        }\n\n        if (activeSoundscapes.containsKey(playerId)) {\n            activeSoundscapes.get(playerId).stop();\n            activeSoundscapes.remove(playerId);\n        }\n    }\n\n    private void applyAura(Player player, Orb orb) {\n        PlanetAura aura = new PlanetAura(player, orb);\n        activeAuras.put(player.getUniqueId(), aura);\n        aura.start();\n    }\n\n    private void applySoundscape(Player player, Orb orb) {\n        PlanetSoundscape soundscape = new PlanetSoundscape(player, orb);\n        activeSoundscapes.put(player.getUniqueId(), soundscape);\n        soundscape.start();\n    }\n\n    private void applyAtmosphericEffects(Player player, BiomeType biome) {\n        // Apply atmosphere effects based on biome\n        switch (biome) {\n            case TOXIC_SWAMP, TOXIC -> {\n                // Toxic atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.POISON, 100, 1, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.SLOWNESS, 100, 0, false, false, false));\n            }\n            case LUMINOUS, GLOWSTONE_CAVERN -> {\n                // Glowing atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.NIGHT_VISION, 300, 0, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING, 300, 0, false, false, false));\n            }\n            case STORMY -> {\n                // Stormy atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.SLOWNESS, 80, 1, false, false, false));\n            }\n            case CORROSIVE -> {\n                // Corrosive atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.WITHER, 60, 0, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.POISON, 100, 2, false, false, false));\n            }\n            case AURORA -> {\n                // Aurora atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 120, 0, false, false, false));\n            }\n            case FOGGY -> {\n                // Foggy atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 40, 0, false, false, false));\n            }\n        }\n    }\n\n    private void applyParticles(Player player, BiomeType biome) {\n        Location loc = player.getLocation();\n\n        new BukkitRunnable() {\n            int ticks = 0;\n\n            @Override\n            public void run() {\n                if (!player.isOnline() || ticks >= 1200) { // 60 seconds\n                    cancel();\n                    return;\n                }\n\n                // Biome-specific atmospheric particles\n                switch (biome) {\n                    case TOXIC_SWAMP, TOXIC -> {\n                        // Toxic green particles\n                        player.getWorld().spawnParticle(Particle.DRIPPING_LAVA,\n                            loc.clone().add(0, 1, 0), 3, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case LUMINOUS, GLOWSTONE_CAVERN -> {\n                        // Glowing particles\n                        player.getWorld().spawnParticle(Particle.END_ROD,\n                            loc.clone().add(0, 1, 0), 5, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case STORMY -> {\n                        // Storm particles\n                        player.getWorld().spawnParticle(Particle.CLOUD,\n                            loc.clone().add(0, 1, 0), 10, 0.5, 0.5, 0.5, 0.1);\n                    }\n                    case CORROSIVE -> {\n                        // Corrosive particles\n                        player.getWorld().spawnParticle(Particle.PORTAL,\n                            loc.clone().add(0, 1, 0), 3, 0.3, 0.3, 0.3, 0.01);\n                    }\n                    case AURORA -> {\n                        // Aurora particles\n                        player.getWorld().spawnParticle(Particle.END_ROD,\n                            loc.clone().add(0, 1, 0), 8, 0.5, 0.5, 0.5, 0.02);\n                    }\n                    case FOGGY -> {\n                        // Fog particles\n                        player.getWorld().spawnParticle(Particle.WHITE_ASH,\n                            loc.clone().add(0, 1, 0), 15, 0.5, 0.5, 0.5, 0.05);\n                    }\n                    case CRYSTAL_FOREST, CRYSTALLINE -> {\n                        // Crystal particles\n                        player.getWorld().spawnParticle(Particle.DRAGON_BREATH,\n                            loc.clone().add(0, 1, 0), 5, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case LAVA_OCEAN, MAGMA_CAVES -> {\n                        // Lava particles\n                        player.getWorld().spawnParticle(Particle.FLAME,\n                            loc.clone().add(0, 0.5, 0), 3, 0.3, 0.3, 0.3, 0.01);\n                    }\n                    case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                        // Ice particles\n                        player.getWorld().spawnParticle(Particle.SNOWFLAKE,\n                            loc.clone().add(0, 1, 0), 10, 0.5, 0.5, 0.5, 0.1);\n                    }\n                }\n\n                ticks += 20; // Every second\n            }\n        }.runTaskTimer(plugin, 0L, 20L);\n    }\n\n    private void applySkyEffects(Player player, BiomeType biome) {\n        // Apply atmospheric sky effects based on biome\n        switch (biome) {\n            case TOXIC_SWAMP, TOXIC, CORROSIVE -> {\n                // Toxic/corrosive atmosphere - fog and weather\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n                // Fog effect (would need client mods for full effect)\n            }\n            case STORMY -> {\n                // Stormy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case FOGGY -> {\n                // Foggy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case LUMINOUS, AURORA -> {\n                // Clear glowing atmosphere\n                player.setPlayerWeather(WeatherType.CLEAR);\n            }\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                // Volcanic atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                // Icy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            default -> {\n                // Clear atmosphere for other biomes\n                player.setPlayerWeather(WeatherType.CLEAR);\n            }\n        }\n    }\n\n    private void startEffectUpdater() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                // Update effects for all online players\n                for (Player player : Bukkit.getOnlinePlayers()) {\n                    // Check if player is on a planet\n                    // This would need integration with player location tracking\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 100L); // Every 5 seconds\n    }\n\n    // Inner classes for effect management\n    private static class PlanetAura {\n        private final Player player;\n        private final Orb orb;\n        private BukkitRunnable task;\n\n        public PlanetAura(Player player, Orb orb) {\n            this.player = player;\n            this.orb = orb;\n        }\n\n        public void start() {\n            task = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (!player.isOnline()) {\n                        stop();\n                        return;\n                    }\n\n                    // Apply aura effects based on biome\n                    try {\n                        BiomeType biome = BiomeType.valueOf(orb.getBiomeName());\n\n                        switch (biome) {\n                            case CRYSTAL_FOREST, CRYSTALLINE -> {\n                                // Crystal aura - night vision\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.NIGHT_VISION, 300, 0, false, false, false));\n                            }\n                            case LUMINOUS, GLOWSTONE_CAVERN -> {\n                                // Luminous aura - glowing effect\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING, 300, 0, false, false, false));\n                            }\n                            case AURORA -> {\n                                // Aurora aura - regeneration\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 120, 0, false, false, false));\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // Invalid biome name, skip aura effects\n                    }\n                }\n            };\n            task.runTaskTimer(SkyOrbs.getInstance(), 0L, 200L); // Every 10 seconds\n        }\n\n        public void stop() {\n            if (task != null) {\n                task.cancel();\n            }\n        }\n    }\n\n    private static class PlanetSoundscape {\n        private final Player player;\n        private final Orb orb;\n        private BukkitRunnable task;\n\n        public PlanetSoundscape(Player player, Orb orb) {\n            this.player = player;\n            this.orb = orb;\n        }\n\n        public void start() {\n            task = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (!player.isOnline()) {\n                        stop();\n                        return;\n                    }\n\n                    // Play ambient sounds based on biome\n                    BiomeType biome;\n                    try {\n                        biome = BiomeType.valueOf(orb.getBiomeName());\n                    } catch (IllegalArgumentException e) {\n                        return; // Invalid biome, skip sound\n                    }\n                    Location loc = player.getLocation();\n\n                    Sound sound = getAmbientSound(biome);\n                    if (sound != null) {\n                        player.playSound(loc, sound, SoundCategory.AMBIENT, 0.3f, 1.0f);\n                    }\n                }\n            };\n            task.runTaskTimer(SkyOrbs.getInstance(), 0L, 400L); // Every 20 seconds\n        }\n\n        public void stop() {\n            if (task != null) {\n                task.cancel();\n            }\n        }\n\n        private Sound getAmbientSound(BiomeType biome) {\n            return switch (biome) {\n                case CRYSTAL_FOREST, CRYSTALLINE -> Sound.BLOCK_AMETHYST_BLOCK_CHIME;\n                case LAVA_OCEAN, MAGMA_CAVES -> Sound.BLOCK_LAVA_AMBIENT;\n                case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> Sound.BLOCK_SNOW_BREAK;\n                case TOXIC_SWAMP, TOXIC -> Sound.BLOCK_SLIME_BLOCK_BREAK;\n                case CORRUPTED -> Sound.AMBIENT_NETHER_WASTES_LOOP;\n                case GLOWSTONE_CAVERN, LUMINOUS -> Sound.BLOCK_AMETHYST_BLOCK_RESONATE;\n                case AURORA -> Sound.BLOCK_BELL_RESONATE;\n                case STORMY -> Sound.WEATHER_RAIN;\n                case FOGGY -> Sound.AMBIENT_NETHER_WASTES_LOOP;\n                case CORROSIVE -> Sound.BLOCK_LAVA_POP;\n                case CHORUS_LAND -> Sound.BLOCK_CHORUS_FLOWER_GROW;\n                default -> null;\n            };\n        }\n    }\n}","size_bytes":13030},"src/main/java/com/skyorbs/shapes/impl/CometShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CometShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double headDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (headDistance <= radius * 0.6) {\n            return true;\n        }\n        \n        if (dx > 0) {\n            double tailLength = radius * 2;\n            double tailWidth = radius * 0.3 * (1 - dx / tailLength);\n            \n            if (dx <= tailLength) {\n                double crossDist = Math.sqrt(dy * dy + dz * dz);\n                return crossDist <= tailWidth;\n            }\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public String getName() {\n        return \"COMET\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Kuyruklu Yıldız\";\n    }\n}\n","size_bytes":1013},"src/main/java/com/skyorbs/generation/PlacementService.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class PlacementService {\n    \n    private final SkyOrbs plugin;\n    private final Set<String> reservedLocations = new HashSet<>();\n    private final Random random = new Random();\n    \n    public PlacementService(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    public PlacementResult findPlacement(int radius, List<Orb> existingOrbs) {\n        int maxDistance = plugin.getConfigManager().getMaxDistance();\n        int centerX = plugin.getConfigManager().getCenterX();\n        int centerZ = plugin.getConfigManager().getCenterZ();\n        int minFromSpawn = plugin.getConfigManager().getMinDistanceFromSpawn();\n        \n        if (plugin.getConfigManager().isClusteringEnabled() && !existingOrbs.isEmpty()) {\n            PlacementResult cluster = tryClusterPlacement(radius, existingOrbs, maxDistance, centerX, centerZ, minFromSpawn);\n            if (cluster != null) {\n                return cluster;\n            }\n        }\n        \n        return trySpiralPlacement(radius, existingOrbs, maxDistance, centerX, centerZ, minFromSpawn);\n    }\n    \n    private PlacementResult tryClusterPlacement(int radius, List<Orb> existingOrbs, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int minDist = plugin.getConfigManager().getClusterMinDistance();\n        int maxDist = plugin.getConfigManager().getClusterMaxDistance();\n        double centerAttraction = plugin.getConfigManager().getCenterAttraction();\n        \n        for (int attempt = 0; attempt < 50; attempt++) {\n            Orb parent = existingOrbs.get(random.nextInt(existingOrbs.size()));\n            \n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = minDist + random.nextInt(maxDist - minDist);\n            \n            int candidateX = parent.getCenterX() + (int)(Math.cos(angle) * distance);\n            int candidateZ = parent.getCenterZ() + (int)(Math.sin(angle) * distance);\n            \n            if (centerAttraction > 0) {\n                candidateX = (int)(candidateX * (1 - centerAttraction) + centerX * centerAttraction);\n                candidateZ = (int)(candidateZ * (1 - centerAttraction) + centerZ * centerAttraction);\n            }\n            \n            if (!validateDistance(candidateX, candidateZ, maxDistance, centerX, centerZ, minFromSpawn)) {\n                continue;\n            }\n            \n            if (!checkOverlap(candidateX, candidateZ, radius, existingOrbs)) {\n                int y = 120 + random.nextInt(41) - 20;\n                return new PlacementResult(candidateX, y, candidateZ, true);\n            }\n        }\n        \n        return null;\n    }\n    \n    private PlacementResult trySpiralPlacement(int radius, List<Orb> existingOrbs, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int ringStep = 200;\n        int angleStep = 15;\n        \n        for (int ring = 5; ring <= 15; ring++) {\n            int ringDist = ring * ringStep;\n            if (ringDist > maxDistance) {\n                break;\n            }\n            \n            for (int angle = 0; angle < 360; angle += angleStep) {\n                double rad = Math.toRadians(angle);\n                int candidateX = centerX + (int)(Math.cos(rad) * ringDist);\n                int candidateZ = centerZ + (int)(Math.sin(rad) * ringDist);\n                \n                if (!validateDistance(candidateX, candidateZ, maxDistance, centerX, centerZ, minFromSpawn)) {\n                    continue;\n                }\n                \n                if (!checkOverlap(candidateX, candidateZ, radius, existingOrbs)) {\n                    int y = 120 + random.nextInt(41) - 20;\n                    return new PlacementResult(candidateX, y, candidateZ, true);\n                }\n            }\n        }\n        \n        return new PlacementResult(0, 0, 0, false);\n    }\n    \n    private boolean validateDistance(int x, int z, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int dx = x - centerX;\n        int dz = z - centerZ;\n        double distFromCenter = Math.sqrt(dx * dx + dz * dz);\n        return distFromCenter <= maxDistance && distFromCenter >= minFromSpawn;\n    }\n    \n    private boolean checkOverlap(int x, int z, int newRadius, List<Orb> existingOrbs) {\n        // İlk olarak diğer gezegenlerle çakışma kontrolü\n        for (Orb orb : existingOrbs) {\n            double distance = orb.getDistanceFrom(x, z);\n            int safeDistance = orb.getRadius() + newRadius + 800; // DAHA FAZLA MESAFE - 800 blok güvenli mesafe\n\n            if (distance < safeDistance) {\n                return true;\n            }\n        }\n\n        // Rezerve edilmiş konum kontrolü\n        String key = x + \",\" + z;\n        if (reservedLocations.contains(key)) {\n            return true;\n        }\n\n        // BLOK KONTROLÜ - Oluşacak yerde blok varsa oluşmasın\n        return hasBlocksAtLocation(x, z, newRadius);\n    }\n\n    /**\n     * Belirtilen konumda blok olup olmadığını kontrol eder\n     */\n    private boolean hasBlocksAtLocation(int x, int z, int radius) {\n        // Gezegen oluşacak alanda örnekleme yap\n        int samplePoints = Math.min(10, radius / 5 + 1); // Radius'a göre örnek sayısı\n        int step = Math.max(1, radius / samplePoints);\n\n        for (int dx = -radius; dx <= radius; dx += step) {\n            for (int dz = -radius; dz <= radius; dz += step) {\n                double distance = Math.sqrt(dx * dx + dz * dz);\n                if (distance <= radius) {\n                    // Bu konumda blok kontrolü yap\n                    int checkX = x + dx;\n                    int checkZ = z + dz;\n\n                    // Yükseklik aralığında kontrol et (yeryüzü seviyesinde)\n                    for (int y = 50; y <= 150; y += 10) { // 50-150 arası 10'ar blok kontrol\n                        // World instance'ı plugin'den al\n                        if (plugin.getServer().getWorlds().size() > 0) {\n                            var world = plugin.getServer().getWorlds().get(0); // Ana dünya\n                            if (world != null) {\n                                var block = world.getBlockAt(checkX, y, checkZ);\n                                var type = block.getType();\n                                // Hava veya su dışında blok varsa çakışma var\n                                if (!type.isAir() && type != org.bukkit.Material.WATER && type != org.bukkit.Material.LAVA) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false; // Blok bulunamadı, güvenli\n    }\n    \n    public void reserveLocation(int x, int z) {\n        reservedLocations.add(x + \",\" + z);\n    }\n    \n    public void releaseLocation(int x, int z) {\n        reservedLocations.remove(x + \",\" + z);\n    }\n    \n    public static class PlacementResult {\n        private final int x, y, z;\n        private final boolean success;\n        \n        public PlacementResult(int x, int y, int z, boolean success) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.success = success;\n        }\n        \n        public int getX() { return x; }\n        public int getY() { return y; }\n        public int getZ() { return z; }\n        public boolean isSuccess() { return success; }\n    }\n}\n","size_bytes":7596},"src/main/java/com/skyorbs/features/TreasureGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.enchantments.Enchantment;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class TreasureGenerator {\n    \n    public static List<TreasureLocation> generateTreasures(Orb orb, BiomeType biome, World world) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n\n        // Config kontrolü\n        if (!plugin.getConfigManager().isTreasureGenerationEnabled()) {\n            return new ArrayList<>();\n        }\n\n        List<TreasureLocation> treasures = new ArrayList<>();\n        // Use deterministic seed based on biome + planet seed for consistent loot\n        Random random = new Random(orb.getSeed() + biome.name().hashCode() + 999);\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Biome-aware treasure density\n        double densityMultiplier = plugin.getConfigManager().getTreasureDensityMultiplier();\n        double biomeMultiplier = getBiomeTreasureMultiplier(biome);\n        int treasureCount = Math.max(1, (int)(radius * 0.015 * densityMultiplier * biomeMultiplier));\n\n        for (int i = 0; i < treasureCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Underground spawn (5-15 blocks below surface)\n            int y = cy + radius - (5 + random.nextInt(10));\n\n            // Determine treasure type based on biome\n            TreasureType type = getTreasureType(biome, random);\n\n            treasures.add(new TreasureLocation(x, y, z, biome, type));\n        }\n\n        return treasures;\n    }\n    \n    /**\n     * Hazine sandığını doldur\n     */\n    public static void fillTreasureChest(Block block, BiomeType biome, TreasureType type, Random random) {\n        if (!(block.getState() instanceof Chest chest)) return;\n        \n        Inventory inv = chest.getInventory();\n        inv.clear();\n        \n        // Loot tablosuna göre item ekle\n        List<ItemStack> loot = generateLoot(biome, type, random);\n        \n        for (ItemStack item : loot) {\n            int slot = random.nextInt(27);\n            while (inv.getItem(slot) != null) {\n                slot = random.nextInt(27);\n            }\n            inv.setItem(slot, item);\n        }\n        \n        chest.update();\n    }\n    \n    /**\n     * Loot oluştur\n     */\n    private static List<ItemStack> generateLoot(BiomeType biome, TreasureType type, Random random) {\n        List<ItemStack> loot = new ArrayList<>();\n        \n        switch (type) {\n            case COMMON -> {\n                // Temel itemler - AMOUNT EN AZ 1 OLACAK\n                loot.add(new ItemStack(Material.IRON_INGOT, Math.max(1, 3 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, 1 + random.nextInt(4))));\n                loot.add(new ItemStack(Material.COAL, Math.max(1, 5 + random.nextInt(15))));\n                loot.add(new ItemStack(Material.BREAD, Math.max(1, 2 + random.nextInt(6))));\n\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.IRON_SWORD, 1));\n                }\n                if (random.nextDouble() < 0.3) {\n                    loot.add(new ItemStack(Material.IRON_PICKAXE, 1));\n                }\n            }\n            \n            case UNCOMMON -> {\n                // Daha iyi itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, 4 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 1 + random.nextInt(3))));\n                if (random.nextInt(3) > 0) { // 66% şans\n                    loot.add(new ItemStack(Material.EMERALD, Math.max(1, random.nextInt(3))));\n                }\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n\n                if (random.nextDouble() < 0.6) {\n                    ItemStack sword = new ItemStack(Material.IRON_SWORD, 1);\n                    sword.addEnchantment(Enchantment.SHARPNESS, 1 + random.nextInt(2));\n                    loot.add(sword);\n                }\n\n                if (random.nextDouble() < 0.4) {\n                    loot.add(new ItemStack(Material.GOLDEN_APPLE, Math.max(1, 1 + random.nextInt(2))));\n                }\n            }\n            \n            case RARE -> {\n                // Nadir itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 3 + random.nextInt(5))));\n                loot.add(new ItemStack(Material.EMERALD, Math.max(1, 2 + random.nextInt(4))));\n                if (random.nextInt(2) > 0) { // 50% şans\n                    loot.add(new ItemStack(Material.NETHERITE_SCRAP, Math.max(1, random.nextInt(2))));\n                }\n\n                if (random.nextDouble() < 0.7) {\n                    ItemStack armor = new ItemStack(\n                        random.nextBoolean() ? Material.DIAMOND_CHESTPLATE : Material.DIAMOND_HELMET, 1\n                    );\n                    armor.addEnchantment(Enchantment.PROTECTION, 2 + random.nextInt(2));\n                    loot.add(armor);\n                }\n\n                if (random.nextDouble() < 0.5) {\n                    ItemStack pickaxe = new ItemStack(Material.DIAMOND_PICKAXE, 1);\n                    pickaxe.addEnchantment(Enchantment.EFFICIENCY, 2 + random.nextInt(3));\n                    pickaxe.addEnchantment(Enchantment.FORTUNE, 1 + random.nextInt(2));\n                    loot.add(pickaxe);\n                }\n\n                loot.add(new ItemStack(Material.GOLDEN_APPLE, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n            \n            case EPIC -> {\n                // Epik itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 5 + random.nextInt(10))));\n                loot.add(new ItemStack(Material.EMERALD, Math.max(1, 4 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, 1 + random.nextInt(2))));\n                if (random.nextInt(2) > 0) { // 50% şans\n                    loot.add(new ItemStack(Material.ENCHANTED_GOLDEN_APPLE, Math.max(1, random.nextInt(2))));\n                }\n\n                // Tam set zırh\n                ItemStack helmet = new ItemStack(Material.DIAMOND_HELMET, 1);\n                helmet.addEnchantment(Enchantment.PROTECTION, 3 + random.nextInt(2));\n                helmet.addEnchantment(Enchantment.UNBREAKING, 2 + random.nextInt(2));\n                loot.add(helmet);\n\n                ItemStack chestplate = new ItemStack(Material.DIAMOND_CHESTPLATE, 1);\n                chestplate.addEnchantment(Enchantment.PROTECTION, 3 + random.nextInt(2));\n                loot.add(chestplate);\n\n                // Güçlü silah\n                ItemStack sword = new ItemStack(Material.DIAMOND_SWORD, 1);\n                sword.addEnchantment(Enchantment.SHARPNESS, 3 + random.nextInt(2));\n                sword.addEnchantment(Enchantment.LOOTING, 1 + random.nextInt(2));\n                loot.add(sword);\n\n                // Enchanted book\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n            \n            case LEGENDARY -> {\n                // Efsanevi itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND_BLOCK, Math.max(1, 2 + random.nextInt(4))));\n                loot.add(new ItemStack(Material.EMERALD_BLOCK, Math.max(1, 1 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.ENCHANTED_GOLDEN_APPLE, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.TOTEM_OF_UNDYING, 1));\n\n                // Netherite ekipman\n                ItemStack netheriteHelmet = new ItemStack(Material.NETHERITE_HELMET, 1);\n                netheriteHelmet.addEnchantment(Enchantment.PROTECTION, 4);\n                netheriteHelmet.addEnchantment(Enchantment.UNBREAKING, 3);\n                netheriteHelmet.addEnchantment(Enchantment.MENDING, 1);\n                loot.add(netheriteHelmet);\n\n                ItemStack netheriteChest = new ItemStack(Material.NETHERITE_CHESTPLATE, 1);\n                netheriteChest.addEnchantment(Enchantment.PROTECTION, 4);\n                netheriteChest.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheriteChest);\n\n                ItemStack netheriteSword = new ItemStack(Material.NETHERITE_SWORD, 1);\n                netheriteSword.addEnchantment(Enchantment.SHARPNESS, 5);\n                netheriteSword.addEnchantment(Enchantment.LOOTING, 3);\n                netheriteSword.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheriteSword);\n\n                ItemStack netheritePickaxe = new ItemStack(Material.NETHERITE_PICKAXE, 1);\n                netheritePickaxe.addEnchantment(Enchantment.EFFICIENCY, 5);\n                netheritePickaxe.addEnchantment(Enchantment.FORTUNE, 3);\n                netheritePickaxe.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheritePickaxe);\n\n                // Özel itemler\n                loot.add(new ItemStack(Material.ELYTRA, 1));\n                loot.add(new ItemStack(Material.TRIDENT, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n        }\n        \n        // Biyom özel bonuslar\n        if (SkyOrbs.getInstance().getConfigManager().areBiomeSpecificTreasuresEnabled()) {\n            addBiomeSpecificLoot(loot, biome, random);\n        }\n        \n        return loot;\n    }\n    \n    /**\n     * Add biome-specific loot items deterministically\n     */\n    private static void addBiomeSpecificLoot(List<ItemStack> loot, BiomeType biome, Random random) {\n        switch (biome) {\n            case DESERT, BADLANDS -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.SAND, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.CACTUS, 4 + random.nextInt(8)));\n                }\n            }\n\n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.PACKED_ICE, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.BLUE_ICE, 2 + random.nextInt(6)));\n                }\n            }\n\n            case JUNGLE -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.BAMBOO, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.COCOA_BEANS, 8 + random.nextInt(16)));\n                }\n            }\n\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.MAGMA_BLOCK, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.FIRE_CHARGE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case CRYSTAL_FOREST -> {\n                if (random.nextDouble() < 0.8) {\n                    loot.add(new ItemStack(Material.AMETHYST_SHARD, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.AMETHYST_BLOCK, 2 + random.nextInt(4)));\n                }\n            }\n\n            case MUSHROOM_GIANT -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.RED_MUSHROOM, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.BROWN_MUSHROOM, 8 + random.nextInt(16)));\n                }\n            }\n\n            case GLOWSTONE_CAVERN -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.GLOWSTONE_DUST, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.GLOWSTONE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case CHORUS_LAND -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.CHORUS_FRUIT, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.ENDER_PEARL, 2 + random.nextInt(4)));\n                }\n            }\n\n            // Additional biome-specific loot for new biomes\n            case BASALTIC -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.BASALT, 12 + random.nextInt(24)));\n                    loot.add(new ItemStack(Material.BLACKSTONE, 8 + random.nextInt(16)));\n                }\n            }\n\n            case CORAL -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.BRAIN_CORAL, 4 + random.nextInt(8)));\n                    loot.add(new ItemStack(Material.TUBE_CORAL, 4 + random.nextInt(8)));\n                }\n            }\n\n            case TOXIC -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.POISONOUS_POTATO, 6 + random.nextInt(12)));\n                    loot.add(new ItemStack(Material.SPIDER_EYE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case AURORA -> {\n                if (random.nextDouble() < 0.4) {\n                    loot.add(new ItemStack(Material.PRISMARINE_CRYSTALS, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.PRISMARINE_SHARD, 6 + random.nextInt(12)));\n                }\n            }\n\n            case STORMY -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.NAUTILUS_SHELL, 1));\n                    loot.add(new ItemStack(Material.HEART_OF_THE_SEA, 1));\n                }\n            }\n\n            case FOGGY -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.PHANTOM_MEMBRANE, 2 + random.nextInt(4)));\n                }\n            }\n\n            case CORROSIVE -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.WITHER_ROSE, 3 + random.nextInt(6)));\n                    loot.add(new ItemStack(Material.WITHER_SKELETON_SKULL, 1));\n                }\n            }\n\n            case LUMINOUS -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.SEA_LANTERN, 4 + random.nextInt(8)));\n                    loot.add(new ItemStack(Material.SHROOMLIGHT, 3 + random.nextInt(6)));\n                }\n            }\n        }\n    }\n    \n    /**\n     * Get biome-specific treasure multiplier\n     */\n    private static double getBiomeTreasureMultiplier(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, VOID, LAVA_OCEAN, GLOWSTONE_CAVERN -> 2.0; // Rich biomes\n            case TOXIC_SWAMP, CORRUPTED, CHORUS_LAND -> 1.5; // Moderate\n            default -> 1.0; // Standard\n        };\n    }\n\n    /**\n     * Determine treasure type based on biome with deterministic seeding\n     */\n    private static TreasureType getTreasureType(BiomeType biome, Random random) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        double rand = random.nextDouble();\n\n        // Biome-specific legendary chances\n        double legendaryMult = plugin.getConfigManager().getLegendaryChanceMultiplier();\n        double biomeLegendaryBonus = getBiomeLegendaryBonus(biome);\n\n        if (rand < (0.02 * legendaryMult * biomeLegendaryBonus)) return TreasureType.LEGENDARY;\n        if (rand < 0.08) return TreasureType.EPIC;\n        if (rand < 0.20) return TreasureType.RARE;\n        if (rand < 0.45) return TreasureType.UNCOMMON;\n        return TreasureType.COMMON;\n    }\n\n    /**\n     * Get biome-specific legendary treasure bonus\n     */\n    private static double getBiomeLegendaryBonus(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST -> 3.0; // Crystal planets have best loot\n            case VOID, LAVA_OCEAN, GLOWSTONE_CAVERN -> 2.5;\n            case CORRUPTED, CHORUS_LAND -> 2.0;\n            case TOXIC_SWAMP, MAGMA_CAVES -> 1.5;\n            default -> 1.0;\n        };\n    }\n    \n    /**\n     * Hazine türleri\n     */\n    public enum TreasureType {\n        COMMON,      // %55 - Temel itemler\n        UNCOMMON,    // %25 - İyi itemler\n        RARE,        // %12 - Nadir itemler\n        EPIC,        // %6 - Epik itemler\n        LEGENDARY    // %2 - Efsanevi itemler\n    }\n    \n    /**\n     * Hazine lokasyonu\n     */\n    public static class TreasureLocation {\n        public final int x, y, z;\n        public final BiomeType biome;\n        public final TreasureType type;\n        \n        public TreasureLocation(int x, int y, int z, BiomeType biome, TreasureType type) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.biome = biome;\n            this.type = type;\n        }\n    }\n}","size_bytes":17494},"src/test/java/com/skyorbs/BiomeTypeTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.biomes.BiomeType;\nimport org.bukkit.Material;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Random;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BiomeTypeTest {\n\n    @Test\n    public void testBiomeTypeCount() {\n        BiomeType[] biomes = BiomeType.values();\n        assertTrue(biomes.length >= 22, \"Should have at least 22 biome types\");\n    }\n\n    @Test\n    public void testBiomeMaterialGeneration() {\n        Random random = new Random(12345);\n        BiomeType forest = BiomeType.FOREST;\n\n        // Test surface material\n        Material surface = forest.getMaterial(0, random);\n        assertNotNull(surface);\n\n        // Test subsurface material\n        Material subsurface = forest.getMaterial(3, random);\n        assertNotNull(subsurface);\n\n        // Test core material\n        Material core = forest.getMaterial(10, random);\n        assertNotNull(core);\n    }\n\n    @Test\n    public void testRandomBiomeSelection() {\n        Random random = new Random(54321);\n        BiomeType randomBiome = BiomeType.getRandomBiome(random);\n        assertNotNull(randomBiome);\n        assertTrue(randomBiome.name().length() > 0);\n    }\n\n    @Test\n    public void testWeightedBiomeSelection() {\n        Random random = new Random(11111);\n        BiomeType weightedBiome = BiomeType.getRandomBiomeWeighted(random);\n        assertNotNull(weightedBiome);\n        assertTrue(weightedBiome.name().length() > 0);\n    }\n\n    @Test\n    public void testBiomeDisplayNames() {\n        for (BiomeType biome : BiomeType.values()) {\n            assertNotNull(biome.getDisplayName());\n            assertTrue(biome.getDisplayName().length() > 0);\n        }\n    }\n}","size_bytes":1711},"src/main/java/com/skyorbs/generation/SatelliteGenerator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class SatelliteGenerator {\n\n    private final SkyOrbs plugin;\n\n    public SatelliteGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public List<Orb> generateSatellitesForPlanet(Orb planet, World world) {\n        List<Orb> satellites = new ArrayList<>();\n\n        if (!plugin.getConfigManager().isSatellitesEnabled()) {\n            return satellites;\n        }\n\n        Random random = new Random(planet.getSeed() + 54321);\n\n        if (random.nextDouble() > plugin.getConfigManager().getSatelliteProbability()) {\n            return satellites;\n        }\n\n        int minCount = plugin.getConfigManager().getMinSatellitesPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxSatellitesPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            int radius = 30 + random.nextInt(41); // 30-70 radius\n\n            int safetyBuffer = 100;\n            int minDist = planet.getRadius() + radius + safetyBuffer;\n            int maxDist = planet.getRadius() + radius + safetyBuffer + 300;\n\n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = minDist + random.nextInt(Math.max(1, maxDist - minDist));\n\n            int x = planet.getCenterX() + (int)(Math.cos(angle) * distance);\n            int z = planet.getCenterZ() + (int)(Math.sin(angle) * distance);\n            int y = planet.getCenterY() + random.nextInt(61) - 30;\n\n            BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n\n            // Select satellite shape based on biome\n            String shapeName = getSatelliteShapeForBiome(biome, random);\n\n            Orb satellite = new Orb(\n                UUID.randomUUID(),\n                planet.getName() + \"_Satellite_\" + (i + 1),\n                world.getName(),\n                x, y, z,\n                radius,\n                shapeName,\n                biome.name(),\n                planet.getSeed() + i + 5000,\n                System.currentTimeMillis(),\n                true,\n                planet.getId()\n            );\n\n            satellites.add(satellite);\n        }\n\n        return satellites;\n    }\n\n    /**\n     * Generate planetary rings around planets\n     */\n    public void generateRingsForPlanet(Orb planet, World world) {\n        Random random = new Random(planet.getSeed() + 99999);\n\n        // Configurable ring chance\n        double ringChance = plugin.getConfig().getDouble(\"satellites.ring_chance\", 0.2);\n        if (random.nextDouble() > ringChance) {\n            return;\n        }\n\n        int ringCount = 1 + random.nextInt(3); // 1-3 rings\n        int ringRadius = planet.getRadius() + 50 + random.nextInt(100); // 50-150 blocks from planet surface\n\n        for (int ring = 0; ring < ringCount; ring++) {\n            int ringY = planet.getCenterY() + random.nextInt(21) - 10; // ±10 blocks from center\n            int ringThickness = 2 + random.nextInt(4); // 2-5 blocks thick\n\n            // Generate ring particles/blocks\n            generateRingParticles(planet, world, ringRadius + ring * 20, ringY, ringThickness, random);\n        }\n    }\n\n    /**\n     * Generate ring visual effects\n     */\n    private void generateRingParticles(Orb planet, World world, int ringRadius, int ringY, int thickness, Random random) {\n        int cx = planet.getCenterX();\n        int cy = planet.getCenterY();\n        int cz = planet.getCenterZ();\n\n        // Create ring blocks for visual effect (sparse for performance)\n        int particleCount = Math.min(200, ringRadius * 4); // Limit particles for performance\n\n        for (int i = 0; i < particleCount; i++) {\n            double angle = random.nextDouble() * 2 * Math.PI;\n            double radiusVariation = ringRadius + random.nextInt(11) - 5; // ±5 variation\n\n            int x = cx + (int)(Math.cos(angle) * radiusVariation);\n            int z = cz + (int)(Math.sin(angle) * radiusVariation);\n            int y = ringY + random.nextInt(thickness * 2) - thickness;\n\n            // Only place if in air (don't overwrite planet blocks)\n            Block block = world.getBlockAt(x, y, z);\n            if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                // Choose ring material based on planet biome\n                Material ringMaterial = getRingMaterialForBiome(BiomeType.valueOf(planet.getBiomeName()), random);\n                block.setType(ringMaterial, false);\n            }\n        }\n    }\n\n    /**\n     * Get appropriate satellite shape for biome\n     */\n    private String getSatelliteShapeForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> \"DIAMOND\"; // Crystal satellites\n            case LAVA_OCEAN, MAGMA_CAVES -> \"SPHERE\"; // Smooth volcanic satellites\n            case VOID -> \"CUBE\"; // Geometric void satellites\n            case CORRUPTED -> \"SPIKY\"; // Spiky corrupted satellites\n            case FROZEN_TUNDRA, GLACIER -> \"OCTAHEDRON\"; // Geometric ice satellites\n            default -> random.nextBoolean() ? \"SPHERE\" : \"ASTEROID\";\n        };\n    }\n\n    /**\n     * Get ring material based on planet biome\n     */\n    private Material getRingMaterialForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> random.nextBoolean() ? Material.AMETHYST_BLOCK : Material.QUARTZ_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> random.nextBoolean() ? Material.OBSIDIAN : Material.BLACKSTONE;\n            case VOID -> Material.END_STONE;\n            case CORRUPTED -> random.nextBoolean() ? Material.WARPED_NYLIUM : Material.CRIMSON_NYLIUM;\n            case FROZEN_TUNDRA, GLACIER -> random.nextBoolean() ? Material.PACKED_ICE : Material.BLUE_ICE;\n            case LUMINOUS -> random.nextBoolean() ? Material.SEA_LANTERN : Material.GLOWSTONE;\n            default -> random.nextBoolean() ? Material.STONE : Material.ANDESITE;\n        };\n    }\n}\n","size_bytes":6297},"src/main/java/com/skyorbs/gui/PlanetPanelGUI.java":{"content":"package com.skyorbs.gui;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetEvolution;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PlanetPanelGUI {\n\n    private final SkyOrbs plugin;\n\n    public PlanetPanelGUI(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public void openPlanetPanel(Player player, Orb orb) {\n        Inventory gui = Bukkit.createInventory(null, 54, \"§8[§bGezegen Paneli§8] §f\" + orb.getName());\n\n        // Core Information Section (Top Row)\n        gui.setItem(4, createCoreInfoItem(orb));\n        gui.setItem(3, createEvolutionInfoItem(orb));\n        gui.setItem(5, createEnergyInfoItem(orb));\n\n        // Planet Stats Section (Second Row)\n        gui.setItem(9, createTypeInfoItem(orb));\n        gui.setItem(10, createBiosphereInfoItem(orb));\n        gui.setItem(11, createEcologyInfoItem(orb));\n        gui.setItem(12, createSizeInfoItem(orb));\n\n        // Actions Section (Third Row)\n        gui.setItem(18, createTeleportItem(orb));\n        gui.setItem(19, createLaboratoryItem(orb));\n        gui.setItem(20, createAchievementsItem(orb));\n        gui.setItem(21, createSettingsItem(orb));\n\n        // Quick Actions (Fourth Row)\n        gui.setItem(27, createRenameItem(orb));\n        gui.setItem(28, createShareItem(orb));\n        gui.setItem(29, createBackupItem(orb));\n        gui.setItem(30, createDeleteItem(orb));\n\n        // Planet Theme Section (Fifth Row)\n        gui.setItem(36, createThemeItem(orb));\n        gui.setItem(37, createEffectsItem(orb));\n        gui.setItem(38, createEventsItem(orb));\n\n        // Admin Section (Bottom Row - if player has permission)\n        if (player.hasPermission(\"skyorbs.admin\")) {\n            gui.setItem(45, createAdminScanItem(orb));\n            gui.setItem(46, createAdminRepairItem(orb));\n            gui.setItem(47, createAdminDebugItem(orb));\n        }\n\n        // Close button\n        gui.setItem(49, createCloseItem());\n\n        player.openInventory(gui);\n    }\n\n    private ItemStack createCoreInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(getCoreMaterial(orb.getCoreLevel()));\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lÇekirdek Bilgileri\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Seviye: §e\" + orb.getCoreLevel() + \" §7/ §e10\");\n        lore.add(\"§7XP: §a\" + orb.getXp() + \" §7/ §a\" + orb.getXpForNextLevel());\n        lore.add(\"\");\n        lore.add(\"§7Sonraki seviye için gereken XP:\");\n        lore.add(\"§c\" + (orb.getXpForNextLevel() - orb.getXp()));\n        if (orb.canUpgrade()) {\n            lore.add(\"\");\n            lore.add(\"§a§lYükseltmeye hazır!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEvolutionInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ENCHANTED_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lEvrim Bilgileri\");\n        List<String> lore = new ArrayList<>();\n        PlanetEvolution evolution = new PlanetEvolution(orb);\n        lore.add(\"§7\" + evolution.getEvolutionDescription());\n        lore.add(\"\");\n        Map<String, Object> reqs = evolution.getEvolutionRequirements();\n        lore.add(\"§7İlerleme: §e\" + String.format(\"%.1f\", reqs.get(\"progressPercent\")) + \"%\");\n        if ((Boolean) reqs.get(\"canUpgrade\")) {\n            lore.add(\"\");\n            lore.add(\"§a§lTıklayarak yükselt!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEnergyInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.REDSTONE);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lEnerji Seviyesi\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Enerji: §c\" + String.format(\"%.1f\", orb.getEnergyLevel()) + \"%\");\n        lore.add(\"§7Rejenerasyon: §a+\" + String.format(\"%.2f\", orb.getEnergyRegenRate()) + \"/dk\");\n        double energyPercent = orb.getEnergyLevel() / 100.0;\n        if (energyPercent > 0.8) {\n            lore.add(\"§aEnerji dolu!\");\n        } else if (energyPercent > 0.5) {\n            lore.add(\"§eOrta seviye enerji\");\n        } else if (energyPercent > 0.2) {\n            lore.add(\"§6Düşük enerji\");\n        } else {\n            lore.add(\"§cKritik enerji seviyesi!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createTypeInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(orb.getPlanetType().getIconMaterial());\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lGezegen Tipi\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Tip: §9\" + orb.getPlanetType().getDisplayName());\n        lore.add(\"\");\n        lore.add(\"§7\" + orb.getPlanetType().getDescription());\n        lore.add(\"\");\n        lore.add(\"§7Enerji Çarpanı: §e\" + String.format(\"%.1f\", orb.getPlanetType().getEnergyMultiplier()) + \"x\");\n        lore.add(\"§7Max Biyosfer: §a\" + orb.getPlanetType().getMaxBiosphereLevel());\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createBiosphereInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.OAK_SAPLING);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§2§lBiyosfer\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Seviye: §2\" + orb.getBiosphereLevel() + \" §7/ §25\");\n        lore.add(\"\");\n        String levelDesc = switch (orb.getBiosphereLevel()) {\n            case 1 -> \"§7Temel yaşam formları\";\n            case 2 -> \"§7Gelişen ekosistem\";\n            case 3 -> \"§7Çeşitli flora ve fauna\";\n            case 4 -> \"§7Zengin biyolojik çeşitlilik\";\n            case 5 -> \"§7Maksimum ekolojik denge\";\n            default -> \"§7Bilinmeyen seviye\";\n        };\n        lore.add(levelDesc);\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEcologyInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMPOSTER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§a§lEkolojik Denge\");\n        List<String> lore = new ArrayList<>();\n        double balance = orb.getEcologicalBalance();\n        lore.add(\"§7Denge: §a\" + String.format(\"%.2f\", balance));\n        lore.add(\"\");\n        if (balance > 1.5) {\n            lore.add(\"§aMükemmel ekolojik denge!\");\n        } else if (balance > 1.0) {\n            lore.add(\"§eİyi ekolojik durum\");\n        } else if (balance > 0.8) {\n            lore.add(\"§6Denge bozuluyor\");\n        } else if (balance > 0.5) {\n            lore.add(\"§cKritik ekolojik durum!\");\n        } else {\n            lore.add(\"§4Çevresel felaket!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSizeInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§f§lGezegen Boyutu\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Yarıçap: §f\" + orb.getRadius() + \" blok\");\n        lore.add(\"§7Hacim: §f\" + String.format(\"%.0f\", (4.0/3.0) * Math.PI * Math.pow(orb.getRadius(), 3)) + \" blok³\");\n        lore.add(\"§7Konum: §f\" + orb.getCenterX() + \", \" + orb.getCenterY() + \", \" + orb.getCenterZ());\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createTeleportItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ENDER_PEARL);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§5§lIşınlanma\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegene ışınlan\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak ışınlan!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createLaboratoryItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BREWING_STAND);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§d§lLaboratuvar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen laboratuvarı\");\n        lore.add(\"§7Yükseltmeler ve araştırmalar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAchievementsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.GOLDEN_APPLE);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lBaşarımlar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen başarımları\");\n        lore.add(\"§7Özel ödüller ve unvanlar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSettingsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMPARATOR);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§3§lAyarlar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen ayarları\");\n        lore.add(\"§7İsim, izinler, tema\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createRenameItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.NAME_TAG);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§f§lYeniden Adlandır\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen adını değiştir\");\n        lore.add(\"§7Token gerektirir\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createShareItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.WRITABLE_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lPaylaş\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni diğer oyuncularla paylaş\");\n        lore.add(\"§7Davetiye gönder\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createBackupItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BOOKSHELF);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§8§lYedekle\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni yedekle\");\n        lore.add(\"§7Veri kaybına karşı koru\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak yedekle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createDeleteItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.TNT);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§4§lSil\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni sil\");\n        lore.add(\"§4§lBu işlem geri alınamaz!\");\n        lore.add(\"\");\n        lore.add(\"§cSağ tıkla onay için\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createThemeItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.PAINTING);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§d§lTema\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen temasını değiştir\");\n        lore.add(\"§7Renkler, efektler, müzik\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEffectsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BEACON);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lEfektler\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Aktif gezegen efektleri\");\n        lore.add(\"§7Aura, partiküller, sesler\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEventsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.FIREWORK_ROCKET);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§e§lOlaylar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Aktif gök olayları\");\n        lore.add(\"§7Fırtınalar, yağmurlar, patlamalar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminScanItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.SPYGLASS);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Tara\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Bozuk chunkları tara\");\n        lore.add(\"§7Sorunları tespit et\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminRepairItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ANVIL);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Onar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni onar\");\n        lore.add(\"§7Biyom ve ore rejenerasyonu\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminDebugItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMMAND_BLOCK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Debug\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Debug bilgileri\");\n        lore.add(\"§7Detaylı loglar\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createCloseItem() {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lKapat\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Paneli kapat\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private Material getCoreMaterial(int level) {\n        return switch (level) {\n            case 1 -> Material.COAL_BLOCK;\n            case 2 -> Material.IRON_BLOCK;\n            case 3 -> Material.GOLD_BLOCK;\n            case 4 -> Material.DIAMOND_BLOCK;\n            case 5 -> Material.EMERALD_BLOCK;\n            case 6 -> Material.NETHERITE_BLOCK;\n            case 7 -> Material.AMETHYST_BLOCK;\n            case 8 -> Material.CRYING_OBSIDIAN;\n            case 9 -> Material.ANCIENT_DEBRIS;\n            case 10 -> Material.NETHER_STAR;\n            default -> Material.STONE;\n        };\n    }\n}","size_bytes":15848},"README.md":{"content":"# SkyOrbs 2.0.0 - Türkçe Minecraft Gezegen Oluşturma Eklentisi\n\n[![Paper](https://img.shields.io/badge/Paper-1.21.4-blue.svg)](https://papermc.io/)\n[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://www.oracle.com/java/)\n[![Maven](https://img.shields.io/badge/Maven-3.8+-red.svg)](https://maven.apache.org/)\n\n## 📖 Açıklama\n\nSkyOrbs, Minecraft sunucularınızda **benzersiz gezegen dünyaları** oluşturmanıza olanak tanıyan, tamamen Türkçe bir Paper eklentisidir. 17 farklı gezegen şekli, 22 biyom tipi, asteroid ve uydu sistemiyle gezegeninizi özelleştirin!\n\n## ✨ Özellikler\n\n### 🌍 Gezegen Sistemi\n- **17+ Gezegen Şekli:** Küre, Ameba, Asteroid, Elips, Çörek, Halka, Silindir, Koni, Elmas, Küp, Piramit, Sekizyüzlü, Fraktal, Dikenli, Kuyruklu Yıldız, Hilal, Karma\n- **22 Biyom Tipi:** Orman, Çöl, Buzul, Volkanik, Kristal Ormanı, Boşluk, ve daha fazlası\n- **Akıllı Yerleştirme:** Gezegenler birbirine 800-2000 blok mesafede, spawn'dan minimum 1000 blok uzakta\n- **1000+ Rastgele İsim:** Türkçe ve bilimkurgu tarzı benzersiz gezegen isimleri\n\n### 🪐 Asteroid & Uydu Sistemi\n- Gezegen başına 1-5 asteroid\n- Gezegen başına 0-3 uydu (olasılığa dayalı)\n- Tamamen config'den özelleştirilebilir\n\n### 🎮 Komutlar (Tamamen Türkçe)\n```\n/gezegen create          - Yeni gezegen oluştur\n/gezegen list            - Tüm gezegenleri listele\n/gezegen tp <isim>       - Gezegene ışınlan\n/gezegen info <isim>     - Gezegen bilgilerini göster (yakındaki gezegenlerle mesafe)\n/gezegen sil <isim>      - Gezegeni sil (sadece Admin)\n/gezegen reload          - Konfigürasyonu yenile (sadece Admin)\n```\n\n### ⚙️ Config-Driven Sistem\n**Her şey config.yml'den düzenlenebilir:**\n- Gezegen boyutları (min/max radius)\n- Gezegenler arası mesafeler\n- Her şekil için ağırlıklar\n- Biyom dağılımları\n- Asteroid/Uydu sayıları\n- 1000+ isim havuzu\n- Tüm mesajlar (Türkçe)\n\n## 📦 Kurulum\n\n### Gereksinimler\n- **Minecraft:** 1.21.4\n- **Server:** Paper (Spigot/Bukkit **desteklenmez**)\n- **Java:** JDK 21+\n- **Maven:** 3.8+ (sadece compile için)\n\n### Adım 1: JAR Dosyasını Derle\n\n```bash\nmvn clean package\n```\n\nDerlenmiş JAR dosyası `target/SkyOrbs-2.0.0.jar` konumunda oluşacaktır.\n\n### Adım 2: Sunucuya Yükle\n\n1. `SkyOrbs-2.0.0.jar` dosyasını sunucunuzun `plugins/` klasörüne kopyalayın\n2. Sunucuyu başlatın veya `/reload confirm` komutunu çalıştırın\n3. `plugins/SkyOrbs/config.yml` dosyası otomatik oluşturulacaktır\n\n### Adım 3: Konfigürasyonu Düzenle (İsteğe Bağlı)\n\n`config.yml` dosyasını açıp tüm ayarları ihtiyacınıza göre değiştirin:\n\n```yaml\n# Gezegen boyutları\ngeneration:\n  planetSize:\n    minRadius: 80\n    maxRadius: 250\n\n# Gezegenler arası mesafe\nplacement:\n  clustering:\n    clusterMinDistance: 800    # Minimum mesafe\n    clusterMaxDistance: 2000   # Maximum mesafe\n```\n\n### Adım 4: İlk Gezegeni Oluştur\n\nOyuna girin ve komutu çalıştırın:\n\n```\n/gezegen create\n```\n\n## 🛠️ Geliştirme\n\n### Proje Yapısı\n\n```\nskyorbs/\n├── src/main/java/com/skyorbs/\n│   ├── core/              # Temel sınıflar (Orb)\n│   ├── commands/          # Komut sistemi\n│   ├── generation/        # Gezegen üretimi\n│   ├── shapes/            # 17 gezegen şekli\n│   ├── biomes/            # 22 biyom tipi\n│   ├── storage/           # SQLite veritabanı\n│   ├── utils/             # Yardımcı araçlar\n│   ├── config/            # Config yönetimi\n│   └── features/          # Ore, Tree, Structure, Treasure\n├── src/main/resources/\n│   ├── config.yml         # Ultra detaylı config (1000+ isim)\n│   └── plugin.yml         # Türkçe plugin tanımı\n├── pom.xml\n└── README.md\n```\n\n### Build\n\n```bash\n# Temizle ve derle\nmvn clean package\n\n# Sadece compile\nmvn compile\n\n# Test et (varsa)\nmvn test\n```\n\n### Bağımlılıklar\n\n- **Paper API:** 1.21.4-R0.1-SNAPSHOT\n- **SQLite JDBC:** 3.44.0.0\n- **Gson:** 2.10.1\n\n## 📝 Config Ayarları\n\n### Gezegen Boyutları\n\n```yaml\ngeneration:\n  planetSize:\n    minRadius: 80\n    maxRadius: 250\n    averageRadius: 150\n```\n\n### Yerleştirme\n\n```yaml\nplacement:\n  worldBounds:\n    maxDistance: 3000              # Spawn'dan max uzaklık\n    minDistanceFromSpawn: 1000     # Spawn'dan min uzaklık\n  \n  clustering:\n    clusterMinDistance: 800        # Gezegenler arası min\n    clusterMaxDistance: 2000       # Gezegenler arası max\n```\n\n### Şekil Ağırlıkları\n\n```yaml\nshapes:\n  weights:\n    SPHERE: 15.0\n    BLOB: 12.0\n    ASTEROID: 10.0\n    # ... 14 şekil daha\n```\n\n### İsim Sistemi\n\n```yaml\nplanetNames:\n  prefixes:\n    - \"Zyr\"\n    - \"Kry\"\n    - \"Vel\"\n    # ... 200+ önek\n  \n  suffixes:\n    - \"ion\"\n    - \"ara\"\n    - \"eon\"\n    # ... 200+ sonek\n  \n  postfixes:\n    - \"Prime\"\n    - \"Alpha\"\n    - \"Beta\"\n    # ... 50+ takı\n```\n\n## 🎯 İzinler\n\n```yaml\nskyorbs.*           # Tüm izinler (op)\nskyorbs.use         # Temel komutlar (herkes)\nskyorbs.create      # Gezegen oluşturma (herkes)\nskyorbs.list        # Liste görme (herkes)\nskyorbs.tp          # Işınlanma (herkes)\nskyorbs.info        # Bilgi görme (herkes)\nskyorbs.admin       # Admin komutları (op)\n```\n\n## 🐛 Sorun Giderme\n\n### JAR Derlenmiyor\n\n```bash\n# Java 21 kurulu mu kontrol edin\njava -version\n\n# Maven kurulu mu kontrol edin\nmvn -version\n\n# Bağımlılıkları güncelleyin\nmvn clean install -U\n```\n\n### Gezegen Oluşturulmuyor\n\n1. Konsol loglarını kontrol edin\n2. `config.yml` dosyasının düzgün olduğundan emin olun\n3. Veritabanı (`data.db`) dosyası erişilebilir mi kontrol edin\n4. Sunucunun Paper olduğundan emin olun (Spigot/Bukkit desteklenmez)\n\n### Performans Sorunları\n\n`config.yml` dosyasında performans ayarlarını düzenleyin:\n\n```yaml\nperformance:\n  asyncGeneration: true\n  threadPool:\n    coreSize: 4\n    maxSize: 8\n  batching:\n    blocksPerBatch: 500\n    batchesPerTick: 5\n```\n\n## 📄 Lisans\n\nBu proje MIT lisansı altında lisanslanmıştır.\n\n## 🤝 Katkıda Bulunma\n\n1. Fork edin\n2. Feature branch oluşturun (`git checkout -b feature/AmazingFeature`)\n3. Commit edin (`git commit -m 'Add some AmazingFeature'`)\n4. Push edin (`git push origin feature/AmazingFeature`)\n5. Pull Request açın\n\n## 📧 İletişim\n\nSorularınız için Issue açabilirsiniz.\n\n## 🙏 Teşekkürler\n\n- Paper ekibine harika API için\n- Minecraft topluluğuna ilham için\n- Türkçe plugin ekosistemini destekleyen herkese\n\n---\n\n**SkyOrbs 2.0.0** - Uzayda kendi gezegeni ni oluştur! 🌍✨\n","size_bytes":6542},"src/main/java/com/skyorbs/shapes/impl/ConeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ConeShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        int height = radius;\n        \n        if (dy < -height || dy > height) {\n            return false;\n        }\n        \n        double factor = 1.0 - (Math.abs(dy) / (double) height);\n        return distance <= radius * factor;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CONE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Koni\";\n    }\n}\n","size_bytes":770},"src/main/java/com/skyorbs/generation/AdvancedWorldGen.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.*;\n\npublic class AdvancedWorldGen {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n\n    public AdvancedWorldGen(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Advanced procedural generation using Perlin + Voronoi hybrid\n     */\n    public List<BlockPlacement> generateAdvancedTerrain(Orb orb, PlanetType planetType) {\n        List<BlockPlacement> blocks = new ArrayList<>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Initialize noise generators\n        SimplexOctaveGenerator perlinNoise = new SimplexOctaveGenerator(seed, 8);\n        perlinNoise.setScale(0.01);\n\n        SimplexOctaveGenerator detailNoise = new SimplexOctaveGenerator(seed + 1, 4);\n        detailNoise.setScale(0.05);\n\n        // Generate terrain using hybrid approach\n        for (int x = -radius; x <= radius; x++) {\n            for (int z = -radius; z <= radius; z++) {\n                // Check if within planet bounds (basic sphere)\n                double distance = Math.sqrt(x * x + z * z);\n                if (distance > radius) continue;\n\n                // Calculate height using Perlin noise\n                double perlinValue = perlinNoise.noise(x, z, 0.5);\n                double detailValue = detailNoise.noise(x, z, 0.5);\n                double combinedNoise = (perlinValue * 0.7) + (detailValue * 0.3);\n\n                // Apply Voronoi-like features for interesting terrain\n                double voronoiFeature = calculateVoronoiFeature(x, z, seed);\n\n                // Calculate final height\n                int height = (int) (combinedNoise * radius * 0.5);\n                height = Math.max(-radius, Math.min(radius, height));\n\n                // Add voronoi influence\n                height += (int) (voronoiFeature * radius * 0.2);\n\n                // Generate vertical column\n                for (int y = -radius; y <= height; y++) {\n                    double verticalDistance = Math.sqrt(x * x + y * y + z * z);\n                    if (verticalDistance <= radius) {\n                        Material material = getTerrainMaterial(planetType, y, height, combinedNoise, seed);\n                        blocks.add(new BlockPlacement(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Calculate Voronoi-like features for terrain variation\n     */\n    private double calculateVoronoiFeature(int x, int z, long seed) {\n        // Simple voronoi-like calculation for terrain features\n        double minDistance = Double.MAX_VALUE;\n\n        // Sample nearby points\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                int px = (x / 16) * 16 + dx * 8;\n                int pz = (z / 16) * 16 + dz * 8;\n\n                Random pointRandom = new Random(seed + px * 31 + pz);\n                int offsetX = pointRandom.nextInt(8) - 4;\n                int offsetZ = pointRandom.nextInt(8) - 4;\n\n                double distance = Math.sqrt((x - (px + offsetX)) * (x - (px + offsetX)) +\n                                          (z - (pz + offsetZ)) * (z - (pz + offsetZ)));\n                minDistance = Math.min(minDistance, distance);\n            }\n        }\n\n        return Math.max(0, 1.0 - minDistance / 8.0);\n    }\n\n    /**\n     * Get terrain material based on planet type and depth\n     */\n    private Material getTerrainMaterial(PlanetType planetType, int y, int surfaceHeight, double noise, long seed) {\n        Random materialRandom = new Random(seed + y * 17 + surfaceHeight);\n\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                if (y == surfaceHeight) {\n                    return materialRandom.nextDouble() < 0.7 ? Material.GRASS_BLOCK : Material.DIRT;\n                } else if (y > surfaceHeight - 3) {\n                    return Material.DIRT;\n                } else {\n                    return Material.STONE;\n                }\n            }\n            case GAS -> {\n                // Gas planets have layered gas materials\n                double layer = (double) y / surfaceHeight;\n                if (layer > 0.8) return Material.BLUE_WOOL;\n                else if (layer > 0.6) return Material.LIGHT_BLUE_WOOL;\n                else if (layer > 0.4) return Material.CYAN_WOOL;\n                else return Material.BLUE_WOOL;\n            }\n            case LAVA -> {\n                if (y >= surfaceHeight - 2) {\n                    return materialRandom.nextDouble() < 0.8 ? Material.MAGMA_BLOCK : Material.LAVA;\n                } else {\n                    return Material.NETHERRACK;\n                }\n            }\n            case ICE -> {\n                if (y == surfaceHeight) {\n                    return Material.SNOW_BLOCK;\n                } else if (y > surfaceHeight - 5) {\n                    return Material.ICE;\n                } else {\n                    return Material.PACKED_ICE;\n                }\n            }\n            case CRYSTAL -> {\n                double crystalChance = Math.abs(noise) * 0.5;\n                if (materialRandom.nextDouble() < crystalChance) {\n                    return Material.AMETHYST_BLOCK;\n                } else {\n                    return Material.QUARTZ_BLOCK;\n                }\n            }\n            case SHADOW -> {\n                return Material.BLACK_CONCRETE;\n            }\n            case TOXIC -> {\n                if (y == surfaceHeight) {\n                    return Material.SLIME_BLOCK;\n                } else {\n                    return Material.GREEN_CONCRETE;\n                }\n            }\n            default -> {\n                return Material.STONE;\n            }\n        }\n    }\n\n    /**\n     * Generate multi-layered ore maps\n     */\n    public List<BlockPlacement> generateOreLayers(Orb orb, PlanetType planetType) {\n        List<BlockPlacement> ores = new ArrayList<>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Define ore layers with depth ranges\n        Map<OreLayer, Double> oreLayers = getOreConfiguration(planetType);\n\n        for (Map.Entry<OreLayer, Double> entry : oreLayers.entrySet()) {\n            OreLayer layer = entry.getKey();\n            double density = entry.getValue();\n\n            SimplexOctaveGenerator oreNoise = new SimplexOctaveGenerator(seed + layer.hashCode(), 4);\n            oreNoise.setScale(0.02);\n\n            // Generate ores within the layer's depth range\n            for (int x = -radius; x <= radius; x++) {\n                for (int z = -radius; z <= radius; z++) {\n                    for (int y = layer.minDepth; y <= layer.maxDepth; y++) {\n                        double distance = Math.sqrt(x * x + y * y + z * z);\n                        if (distance > radius) continue;\n\n                        // Check if we're in the right material\n                        if (!isValidOreLocation(planetType, y)) continue;\n\n                        // Use noise to determine ore placement\n                        double noiseValue = oreNoise.noise(x, y, z);\n                        if (Math.abs(noiseValue) < density) {\n                            ores.add(new BlockPlacement(cx + x, cy + y, cz + z, layer.material));\n                        }\n                    }\n                }\n            }\n        }\n\n        return ores;\n    }\n\n    /**\n     * Check if location is valid for ore placement\n     */\n    private boolean isValidOreLocation(PlanetType planetType, int y) {\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                return y < 0; // Underground only\n            }\n            case LAVA -> {\n                return y < 10; // Near surface in lava planets\n            }\n            case CRYSTAL -> {\n                return true; // Crystals can be anywhere\n            }\n            case ICE -> {\n                return y < -5; // Deep under ice\n            }\n            default -> {\n                return y < 0; // Underground by default\n            }\n        }\n    }\n\n    /**\n     * Get ore configuration for planet type\n     */\n    private Map<OreLayer, Double> getOreConfiguration(PlanetType planetType) {\n        Map<OreLayer, Double> layers = new HashMap<>();\n\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                layers.put(new OreLayer(Material.COAL_ORE, -64, 128), 0.15);\n                layers.put(new OreLayer(Material.IRON_ORE, -64, 72), 0.12);\n                layers.put(new OreLayer(Material.COPPER_ORE, 0, 96), 0.10);\n                layers.put(new OreLayer(Material.GOLD_ORE, -64, 32), 0.04);\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, 16), 0.008);\n                layers.put(new OreLayer(Material.EMERALD_ORE, -16, 320), 0.005);\n            }\n            case LAVA -> {\n                layers.put(new OreLayer(Material.NETHERITE_BLOCK, -64, -32), 0.02);\n                layers.put(new OreLayer(Material.ANCIENT_DEBRIS, -64, -16), 0.01);\n                layers.put(new OreLayer(Material.GOLD_ORE, -32, 64), 0.08);\n            }\n            case CRYSTAL -> {\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, 64), 0.05);\n                layers.put(new OreLayer(Material.EMERALD_ORE, -32, 96), 0.03);\n                layers.put(new OreLayer(Material.LAPIS_ORE, 0, 32), 0.10);\n            }\n            case ICE -> {\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, -16), 0.015);\n                layers.put(new OreLayer(Material.GOLD_ORE, -32, 16), 0.06);\n            }\n            // Add more planet-specific ore configs...\n        }\n\n        return layers;\n    }\n\n    /**\n     * Ore layer definition\n     */\n    private static class OreLayer {\n        final Material material;\n        final int minDepth;\n        final int maxDepth;\n\n        OreLayer(Material material, int minDepth, int maxDepth) {\n            this.material = material;\n            this.minDepth = minDepth;\n            this.maxDepth = maxDepth;\n        }\n\n        @Override\n        public int hashCode() {\n            return material.hashCode() + minDepth * 31 + maxDepth * 37;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof OreLayer)) return false;\n            OreLayer other = (OreLayer) obj;\n            return material == other.material && minDepth == other.minDepth && maxDepth == other.maxDepth;\n        }\n    }\n\n    /**\n     * Block placement helper class\n     */\n    public static class BlockPlacement {\n        public final int x, y, z;\n        public final Material material;\n\n        public BlockPlacement(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n}","size_bytes":11281},"src/main/java/com/skyorbs/shapes/impl/TorusShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TorusShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double majorRadius = radius * 0.7;\n        double minorRadius = radius * 0.3;\n        \n        double horizontalDist = Math.sqrt(dx * dx + dz * dz);\n        double torusCenterDist = Math.sqrt((horizontalDist - majorRadius) * (horizontalDist - majorRadius) + dy * dy);\n        \n        return torusCenterDist <= minorRadius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"TORUS\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Çörek\";\n    }\n}\n","size_bytes":817},"src/main/java/com/skyorbs/atmosphere/AtmosphereType.java":{"content":"package com.skyorbs.atmosphere;\n\nimport org.bukkit.Color;\nimport org.bukkit.Particle;\nimport org.bukkit.potion.PotionEffectType;\n\n/**\n * Different atmosphere types for planets\n * Provides visual and gameplay effects\n */\npublic enum AtmosphereType {\n    \n    CLEAR(\"Clear\", \"Temiz\", 0.4, \n        null, null, false, false),\n    \n    LUMINOUS(\"Luminous\", \"Parlak\", 0.2,\n        Particle.END_ROD, PotionEffectType.NIGHT_VISION, false, true),\n    \n    TOXIC(\"Toxic\", \"Zehirli\", 0.15,\n        Particle.DRIPPING_LAVA, PotionEffectType.POISON, true, false),\n    \n    STORMY(\"Stormy\", \"Fırtınalı\", 0.1,\n        Particle.CLOUD, PotionEffectType.SLOWNESS, true, false),\n    \n    FOGGY(\"Foggy\", \"Sisli\", 0.08,\n        Particle.CLOUD, PotionEffectType.BLINDNESS, true, false),\n    \n    CORROSIVE(\"Corrosive\", \"Aşındırıcı\", 0.05,\n        Particle.PORTAL, PotionEffectType.WITHER, true, false),\n    \n    AURORA(\"Aurora\", \"Aurora\", 0.03,\n        Particle.END_ROD, PotionEffectType.REGENERATION, false, true),\n    \n    RADIOACTIVE(\"Radioactive\", \"Radyoaktif\", 0.02,\n        Particle.ELECTRIC_SPARK, PotionEffectType.WITHER, true, false);\n    \n    private final String name;\n    private final String displayName;\n    private final double probability;\n    private final Particle particleType;\n    private final PotionEffectType effectType;\n    private final boolean hasFog;\n    private final boolean hasGlow;\n    \n    AtmosphereType(String name, String displayName, double probability,\n                   Particle particleType, PotionEffectType effectType,\n                   boolean hasFog, boolean hasGlow) {\n        this.name = name;\n        this.displayName = displayName;\n        this.probability = probability;\n        this.particleType = particleType;\n        this.effectType = effectType;\n        this.hasFog = hasFog;\n        this.hasGlow = hasGlow;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getProbability() {\n        return probability;\n    }\n    \n    public Particle getParticleType() {\n        return particleType;\n    }\n    \n    public PotionEffectType getEffectType() {\n        return effectType;\n    }\n    \n    public boolean hasFog() {\n        return hasFog;\n    }\n    \n    public boolean hasGlow() {\n        return hasGlow;\n    }\n    \n    public boolean hasEffects() {\n        return effectType != null;\n    }\n    \n    public boolean hasParticles() {\n        return particleType != null;\n    }\n    \n    /**\n     * Get color for atmosphere particles\n     */\n    public Color getAtmosphereColor() {\n        return switch (this) {\n            case LUMINOUS, AURORA -> Color.fromRGB(200, 220, 255);\n            case TOXIC -> Color.fromRGB(100, 255, 100);\n            case STORMY -> Color.fromRGB(128, 128, 128);\n            case FOGGY -> Color.fromRGB(200, 200, 200);\n            case CORROSIVE -> Color.fromRGB(255, 200, 50);\n            case RADIOACTIVE -> Color.fromRGB(0, 255, 0);\n            default -> Color.WHITE;\n        };\n    }\n}\n","size_bytes":3069},"src/main/java/com/skyorbs/shapes/impl/SphereShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SphereShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        return dx * dx + dy * dy + dz * dz <= radius * radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"SPHERE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Küre\";\n    }\n}\n","size_bytes":548},"src/main/java/com/skyorbs/shapes/impl/HemisphereShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HemisphereShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Küre formülü + yarım küre için y <= 0 koşulu (YUKARIDAN AŞAĞI!)\n        // ÜST TARAFI DA DOLDUR - tam yarım küre!\n        return dx * dx + dy * dy + dz * dz <= radius * radius && dy <= radius/2;\n    }\n\n    @Override\n    public String getName() {\n        return \"HEMISPHERE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Yarım Küre\";\n    }\n}","size_bytes":701},"src/main/java/com/skyorbs/generation/PlanetSizeCalculator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\n\nimport java.util.Random;\n\npublic class PlanetSizeCalculator {\n    \n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n    \n    public PlanetSizeCalculator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    public int calculateRadius(String sizeCategory) {\n        int minRadius = plugin.getConfigManager().getMinRadius();\n        int maxRadius = plugin.getConfigManager().getMaxRadius();\n        \n        return switch (sizeCategory.toUpperCase()) {\n            case \"SMALL\" -> minRadius + random.nextInt(40);\n            case \"MEDIUM\" -> 120 + random.nextInt(60);\n            case \"LARGE\" -> 180 + random.nextInt(70);\n            default -> {\n                double rand = random.nextDouble();\n                if (rand < 0.4) {\n                    yield minRadius + random.nextInt(40);\n                } else if (rand < 0.8) {\n                    yield 120 + random.nextInt(60);\n                } else {\n                    yield 180 + random.nextInt(70);\n                }\n            }\n        };\n    }\n    \n    public long estimateBlockCount(int radius) {\n        int shellThickness = 7;\n        double outerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius, 3);\n        double innerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius - shellThickness, 3);\n        return (long)((outerVolume - innerVolume) * 1.1);\n    }\n    \n    public boolean validateSize(int radius) {\n        int minRadius = plugin.getConfigManager().getMinRadius();\n        int maxRadius = plugin.getConfigManager().getMaxRadius();\n        return radius >= minRadius && radius <= maxRadius;\n    }\n}\n","size_bytes":1676},"src/main/java/com/skyorbs/palettes/PaletteRegistry.java":{"content":"package com.skyorbs.palettes;\n\nimport org.bukkit.Material;\nimport java.util.*;\n\n/**\n * Registry for planet palettes - enables 2000+ diverse planet combinations\n * Combines with shapes, modifiers, and atmospheres for massive variety\n */\npublic class PaletteRegistry {\n    \n    private final Map<String, PlanetPalette> palettes = new HashMap<>();\n    private final List<PlanetPalette> weightedList = new ArrayList<>();\n    private double totalWeight = 0.0;\n    \n    public PaletteRegistry() {\n        registerDefaultPalettes();\n        buildWeightedList();\n    }\n    \n    /**\n     * Register 20+ diverse palettes for maximum variety\n     */\n    private void registerDefaultPalettes() {\n        // Basaltic (volcanic, dark)\n        register(new PlanetPalette(\"basaltic\", \"Bazaltik\",\n            new Material[]{Material.BASALT, Material.BLACKSTONE, Material.SMOOTH_BASALT},\n            new Material[]{Material.BLACKSTONE, Material.DEEPSLATE, Material.BASALT},\n            new Material[]{Material.DEEPSLATE, Material.BLACKSTONE, Material.MAGMA_BLOCK},\n            new Material[]{Material.MAGMA_BLOCK, Material.LAVA},\n            10.0));\n        \n        // Crystalline (shiny, precious)\n        register(new PlanetPalette(\"crystalline\", \"Kristal\",\n            new Material[]{Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.PURPUR_BLOCK},\n            new Material[]{Material.QUARTZ_BLOCK, Material.CALCITE, Material.DRIPSTONE_BLOCK},\n            new Material[]{Material.DIAMOND_BLOCK, Material.EMERALD_BLOCK, Material.AMETHYST_BLOCK},\n            new Material[]{Material.GLOWSTONE, Material.SEA_LANTERN},\n            8.0));\n        \n        // Fungal (mushroom, organic)\n        register(new PlanetPalette(\"fungal\", \"Mantarlı\",\n            new Material[]{Material.MYCELIUM, Material.BROWN_MUSHROOM_BLOCK, Material.RED_MUSHROOM_BLOCK},\n            new Material[]{Material.DIRT, Material.PODZOL, Material.MYCELIUM},\n            new Material[]{Material.STONE, Material.DIRT, Material.COARSE_DIRT},\n            new Material[]{Material.MUSHROOM_STEM, Material.SHROOMLIGHT},\n            9.0));\n        \n        // Coral (aquatic, vibrant)\n        register(new PlanetPalette(\"coral\", \"Mercan\",\n            new Material[]{Material.BRAIN_CORAL_BLOCK, Material.TUBE_CORAL_BLOCK, Material.BUBBLE_CORAL_BLOCK},\n            new Material[]{Material.HORN_CORAL_BLOCK, Material.FIRE_CORAL_BLOCK, Material.PRISMARINE},\n            new Material[]{Material.PRISMARINE, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.SEA_LANTERN, Material.PRISMARINE_BRICKS},\n            7.0));\n        \n        // Toxic (poisonous, dangerous)\n        register(new PlanetPalette(\"toxic\", \"Zehirli\",\n            new Material[]{Material.GREEN_CONCRETE, Material.LIME_CONCRETE, Material.SLIME_BLOCK},\n            new Material[]{Material.GREEN_TERRACOTTA, Material.LIME_TERRACOTTA, Material.MOSS_BLOCK},\n            new Material[]{Material.STONE, Material.DEEPSLATE, Material.SCULK},\n            new Material[]{Material.SLIME_BLOCK, Material.HONEY_BLOCK},\n            6.0));\n        \n        // Frozen (ice, snow)\n        register(new PlanetPalette(\"frozen\", \"Donmuş\",\n            new Material[]{Material.SNOW_BLOCK, Material.PACKED_ICE, Material.ICE},\n            new Material[]{Material.PACKED_ICE, Material.BLUE_ICE, Material.ICE},\n            new Material[]{Material.BLUE_ICE, Material.PACKED_ICE, Material.STONE},\n            new Material[]{Material.FROSTED_ICE, Material.POWDER_SNOW},\n            8.0));\n        \n        // Volcanic (lava, heat)\n        register(new PlanetPalette(\"volcanic\", \"Volkanik\",\n            new Material[]{Material.MAGMA_BLOCK, Material.NETHERRACK, Material.BLACKSTONE},\n            new Material[]{Material.NETHERRACK, Material.BASALT, Material.BLACKSTONE},\n            new Material[]{Material.LAVA, Material.MAGMA_BLOCK, Material.NETHERRACK},\n            new Material[]{Material.FIRE, Material.LAVA},\n            7.0));\n        \n        // Verdant (lush, green)\n        register(new PlanetPalette(\"verdant\", \"Yeşil\",\n            new Material[]{Material.GRASS_BLOCK, Material.MOSS_BLOCK, Material.FLOWERING_AZALEA_LEAVES},\n            new Material[]{Material.DIRT, Material.ROOTED_DIRT, Material.MOSS_BLOCK},\n            new Material[]{Material.STONE, Material.DIRT, Material.CLAY},\n            new Material[]{Material.AZALEA, Material.FLOWERING_AZALEA},\n            10.0));\n        \n        // Desert (sandy, dry)\n        register(new PlanetPalette(\"desert\", \"Çöl\",\n            new Material[]{Material.SAND, Material.RED_SAND, Material.SANDSTONE},\n            new Material[]{Material.SANDSTONE, Material.RED_SANDSTONE, Material.SAND},\n            new Material[]{Material.STONE, Material.SANDSTONE, Material.TERRACOTTA},\n            new Material[]{Material.DEAD_BUSH, Material.CACTUS},\n            9.0));\n        \n        // Metallic (iron, copper)\n        register(new PlanetPalette(\"metallic\", \"Metalik\",\n            new Material[]{Material.IRON_BLOCK, Material.COPPER_BLOCK, Material.WEATHERED_COPPER},\n            new Material[]{Material.IRON_BLOCK, Material.EXPOSED_COPPER, Material.OXIDIZED_COPPER},\n            new Material[]{Material.IRON_BLOCK, Material.GOLD_BLOCK, Material.NETHERITE_BLOCK},\n            new Material[]{Material.IRON_BARS, Material.CHAIN},\n            5.0));\n        \n        // Void (dark, mysterious)\n        register(new PlanetPalette(\"void\", \"Boşluk\",\n            new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.CRYING_OBSIDIAN},\n            new Material[]{Material.OBSIDIAN, Material.END_STONE, Material.BLACKSTONE},\n            new Material[]{Material.OBSIDIAN, Material.CRYING_OBSIDIAN, Material.NETHERITE_BLOCK},\n            new Material[]{Material.ENDER_CHEST, Material.END_ROD},\n            4.0));\n        \n        // Luminous (glowing, bright)\n        register(new PlanetPalette(\"luminous\", \"Parlak\",\n            new Material[]{Material.GLOWSTONE, Material.SEA_LANTERN, Material.SHROOMLIGHT},\n            new Material[]{Material.GLOWSTONE, Material.OCHRE_FROGLIGHT, Material.VERDANT_FROGLIGHT},\n            new Material[]{Material.GLOWSTONE, Material.PEARLESCENT_FROGLIGHT, Material.QUARTZ_BLOCK},\n            new Material[]{Material.TORCH, Material.LANTERN},\n            5.0));\n        \n        // Warped (nether, alien)\n        register(new PlanetPalette(\"warped\", \"Çarpık\",\n            new Material[]{Material.WARPED_NYLIUM, Material.WARPED_WART_BLOCK, Material.WARPED_STEM},\n            new Material[]{Material.WARPED_NYLIUM, Material.NETHERRACK, Material.SOUL_SOIL},\n            new Material[]{Material.NETHERRACK, Material.SOUL_SOIL, Material.BLACKSTONE},\n            new Material[]{Material.WARPED_ROOTS, Material.WARPED_FUNGUS},\n            6.0));\n        \n        // Crimson (nether, red)\n        register(new PlanetPalette(\"crimson\", \"Kızıl\",\n            new Material[]{Material.CRIMSON_NYLIUM, Material.CRIMSON_STEM, Material.NETHER_WART_BLOCK},\n            new Material[]{Material.CRIMSON_NYLIUM, Material.NETHERRACK, Material.SOUL_SAND},\n            new Material[]{Material.NETHERRACK, Material.SOUL_SAND, Material.BLACKSTONE},\n            new Material[]{Material.CRIMSON_ROOTS, Material.CRIMSON_FUNGUS},\n            6.0));\n        \n        // Sandstone (ancient, carved)\n        register(new PlanetPalette(\"sandstone\", \"Kumtaşı\",\n            new Material[]{Material.SANDSTONE, Material.SMOOTH_SANDSTONE, Material.CHISELED_SANDSTONE},\n            new Material[]{Material.SANDSTONE, Material.CUT_SANDSTONE, Material.SAND},\n            new Material[]{Material.STONE, Material.SANDSTONE, Material.TERRACOTTA},\n            new Material[]{Material.SANDSTONE_STAIRS, Material.SANDSTONE_SLAB},\n            7.0));\n        \n        // Terracotta (colorful, layered)\n        register(new PlanetPalette(\"terracotta\", \"Kil\",\n            new Material[]{Material.ORANGE_TERRACOTTA, Material.RED_TERRACOTTA, Material.YELLOW_TERRACOTTA},\n            new Material[]{Material.BROWN_TERRACOTTA, Material.WHITE_TERRACOTTA, Material.LIGHT_GRAY_TERRACOTTA},\n            new Material[]{Material.TERRACOTTA, Material.CLAY, Material.STONE},\n            new Material[]{Material.FLOWER_POT, Material.BRICK},\n            8.0));\n        \n        // Concrete (modern, smooth)\n        register(new PlanetPalette(\"concrete\", \"Beton\",\n            new Material[]{Material.LIGHT_GRAY_CONCRETE, Material.GRAY_CONCRETE, Material.WHITE_CONCRETE},\n            new Material[]{Material.GRAY_CONCRETE, Material.STONE, Material.ANDESITE},\n            new Material[]{Material.STONE, Material.DEEPSLATE, Material.STONE},\n            new Material[]{Material.GRAVEL, Material.COBBLESTONE},\n            6.0));\n        \n        // Prismarine (ocean, ancient)\n        register(new PlanetPalette(\"prismarine\", \"Prizmarin\",\n            new Material[]{Material.PRISMARINE, Material.PRISMARINE_BRICKS, Material.DARK_PRISMARINE},\n            new Material[]{Material.PRISMARINE, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.OBSIDIAN, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.SEA_LANTERN, Material.PRISMARINE_SLAB},\n            5.0));\n        \n        // Sculk (deep dark, mysterious)\n        register(new PlanetPalette(\"sculk\", \"Sculk\",\n            new Material[]{Material.SCULK, Material.SCULK_VEIN, Material.SCULK_CATALYST},\n            new Material[]{Material.SCULK, Material.DEEPSLATE, Material.SCULK_CATALYST},\n            new Material[]{Material.DEEPSLATE, Material.REINFORCED_DEEPSLATE, Material.SCULK_SHRIEKER},\n            new Material[]{Material.SCULK_SENSOR, Material.SCULK_CATALYST},\n            3.0));\n        \n        // Mud (swamp, wet)\n        register(new PlanetPalette(\"mud\", \"Çamur\",\n            new Material[]{Material.MUD, Material.MUDDY_MANGROVE_ROOTS, Material.MUD_BRICKS},\n            new Material[]{Material.MUD, Material.CLAY, Material.PACKED_MUD},\n            new Material[]{Material.CLAY, Material.DIRT, Material.STONE},\n            new Material[]{Material.MANGROVE_ROOTS, Material.MOSS_CARPET},\n            7.0));\n    }\n    \n    private void register(PlanetPalette palette) {\n        palettes.put(palette.getId(), palette);\n    }\n    \n    private void buildWeightedList() {\n        weightedList.clear();\n        totalWeight = 0.0;\n        \n        for (PlanetPalette palette : palettes.values()) {\n            totalWeight += palette.getWeight();\n            weightedList.add(palette);\n        }\n    }\n    \n    /**\n     * Get random palette based on weights\n     */\n    public PlanetPalette getRandomPalette(Random random) {\n        double value = random.nextDouble() * totalWeight;\n        double current = 0.0;\n        \n        for (PlanetPalette palette : weightedList) {\n            current += palette.getWeight();\n            if (value <= current) {\n                return palette;\n            }\n        }\n        \n        return weightedList.get(0);\n    }\n    \n    /**\n     * Get palette by ID\n     */\n    public PlanetPalette getPalette(String id) {\n        return palettes.get(id);\n    }\n    \n    /**\n     * Get all palette IDs\n     */\n    public Set<String> getPaletteIds() {\n        return palettes.keySet();\n    }\n    \n    /**\n     * Get total number of palettes\n     */\n    public int getPaletteCount() {\n        return palettes.size();\n    }\n}\n","size_bytes":11305},"src/main/java/com/skyorbs/shapes/impl/HybridShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\nimport java.util.Random;\n\npublic class HybridShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        Random rand = new Random(seed);\n        double choice = rand.nextDouble();\n        \n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.15);\n        \n        if (choice < 0.5) {\n            double sphereDeform = 1 + 0.2 * noise;\n            return distance <= radius * sphereDeform;\n        } else {\n            int manhattan = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n            double cubeDeform = 1 + 0.15 * noise;\n            return manhattan <= radius * cubeDeform;\n        }\n    }\n    \n    @Override\n    public String getName() {\n        return \"HYBRID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Karma\";\n    }\n}\n","size_bytes":1126},"src/main/java/com/skyorbs/config/ConfigManager.java":{"content":"package com.skyorbs.config;\n\nimport com.skyorbs.SkyOrbs;\nimport org.bukkit.configuration.ConfigurationSection;\n\nimport java.util.*;\n\npublic class ConfigManager {\n    \n    private final SkyOrbs plugin;\n    \n    public ConfigManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    // ============================================\n    // GEZEGEN BOYUT AYARLARI\n    // ============================================\n    \n    public int getMinRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.minRadius\", 80);\n    }\n    \n    public int getMaxRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.maxRadius\", 250);\n    }\n    \n    public int getAverageRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.averageRadius\", 150);\n    }\n    \n    // ============================================\n    // YERLEŞTİRME AYARLARI\n    // ============================================\n    \n    public int getMaxDistance() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.maxDistance\", 3000);\n    }\n    \n    public int getCenterX() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.centerX\", 0);\n    }\n    \n    public int getCenterZ() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.centerZ\", 0);\n    }\n    \n    public int getMinDistanceFromSpawn() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.minDistanceFromSpawn\", 1000);\n    }\n    \n    public boolean isClusteringEnabled() {\n        return plugin.getConfig().getBoolean(\"placement.clustering.enabled\", true);\n    }\n    \n    public int getClusterMinDistance() {\n        return plugin.getConfig().getInt(\"placement.clustering.clusterMinDistance\", 800);\n    }\n    \n    public int getClusterMaxDistance() {\n        return plugin.getConfig().getInt(\"placement.clustering.clusterMaxDistance\", 2000);\n    }\n    \n    public double getCenterAttraction() {\n        return plugin.getConfig().getDouble(\"placement.attractToCenter.centerAttraction\", 0.3);\n    }\n    \n    // ============================================\n    // ŞEKİL AĞIRLIKLARI\n    // ============================================\n    \n    public Map<String, Double> getShapeWeights() {\n        Map<String, Double> weights = new HashMap<>();\n        ConfigurationSection section = plugin.getConfig().getConfigurationSection(\"shapes.weights\");\n        if (section != null) {\n            for (String key : section.getKeys(false)) {\n                weights.put(key, section.getDouble(key));\n            }\n        }\n        return weights;\n    }\n    \n    // ============================================\n    // ASTEROID AYARLARI\n    // ============================================\n    \n    public boolean isAsteroidsEnabled() {\n        return plugin.getConfig().getBoolean(\"asteroids.enabled\", true);\n    }\n    \n    public int getMinAsteroidsPerPlanet() {\n        return plugin.getConfig().getInt(\"asteroids.perPlanet.minCount\", 1);\n    }\n    \n    public int getMaxAsteroidsPerPlanet() {\n        return plugin.getConfig().getInt(\"asteroids.perPlanet.maxCount\", 5);\n    }\n    \n    public int getMinAsteroidRadius() {\n        return plugin.getConfig().getInt(\"asteroids.size.minRadius\", 20);\n    }\n    \n    public int getMaxAsteroidRadius() {\n        return plugin.getConfig().getInt(\"asteroids.size.maxRadius\", 50);\n    }\n    \n    public int getMinAsteroidDistance() {\n        return plugin.getConfig().getInt(\"asteroids.placement.minDistanceFromPlanet\", 300);\n    }\n    \n    public int getMaxAsteroidDistance() {\n        return plugin.getConfig().getInt(\"asteroids.placement.maxDistanceFromPlanet\", 800);\n    }\n    \n    // ============================================\n    // UYDU AYARLARI\n    // ============================================\n    \n    public boolean isSatellitesEnabled() {\n        return plugin.getConfig().getBoolean(\"satellites.enabled\", true);\n    }\n    \n    public int getMinSatellitesPerPlanet() {\n        return plugin.getConfig().getInt(\"satellites.perPlanet.minCount\", 0);\n    }\n    \n    public int getMaxSatellitesPerPlanet() {\n        return plugin.getConfig().getInt(\"satellites.perPlanet.maxCount\", 3);\n    }\n    \n    public double getSatelliteProbability() {\n        return plugin.getConfig().getDouble(\"satellites.perPlanet.probability\", 0.6);\n    }\n    \n    // ============================================\n    // PERFORMANS AYARLARI\n    // ============================================\n    \n    public boolean isAsyncGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"performance.asyncGeneration\", true);\n    }\n    \n    public int getThreadPoolCoreSize() {\n        return plugin.getConfig().getInt(\"performance.threadPool.coreSize\", 4);\n    }\n    \n    public int getThreadPoolMaxSize() {\n        return plugin.getConfig().getInt(\"performance.threadPool.maxSize\", 8);\n    }\n    \n    public int getBlocksPerBatch() {\n        return plugin.getConfig().getInt(\"performance.batching.blocksPerBatch\", 250);\n    }\n    \n    public int getBatchesPerTick() {\n        return plugin.getConfig().getInt(\"performance.batching.batchesPerTick\", 1);\n    }\n    \n    public int getShellThickness() {\n        return plugin.getConfig().getInt(\"performance.generation.shellThickness\", 7);\n    }\n    \n    public boolean isChunkPreloadEnabled() {\n        return plugin.getConfig().getBoolean(\"performance.generation.chunkPreload\", true);\n    }\n    \n    // ============================================\n    // ORE SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isOreGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.enabled\", true);\n    }\n    \n    public double getOreMultiplier() {\n        return plugin.getConfig().getDouble(\"features.ores.densityMultiplier\", 1.0);\n    }\n    \n    public boolean isDeepslateEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.deepslateVariants\", true);\n    }\n    \n    public boolean areBiomeBonusesEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.biomeBonuses\", true);\n    }\n    \n    // ============================================\n    // AĞAÇ SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isTreeGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.trees.enabled\", true);\n    }\n    \n    public double getTreeDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.trees.densityMultiplier\", 1.0);\n    }\n    \n    public boolean areTreeSpecialFeaturesEnabled() {\n        return plugin.getConfig().getBoolean(\"features.trees.specialFeatures\", true);\n    }\n    \n    // ============================================\n    // YAPI SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isStructureGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.structures.enabled\", true);\n    }\n    \n    public double getStructureDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.structures.densityMultiplier\", 1.0);\n    }\n    \n    public boolean areStructureChestsEnabled() {\n        return plugin.getConfig().getBoolean(\"features.structures.includeChests\", true);\n    }\n    \n    // ============================================\n    // HAZİNE SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isTreasureGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.treasures.enabled\", true);\n    }\n    \n    public double getTreasureDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.treasures.densityMultiplier\", 1.0);\n    }\n    \n    public double getLegendaryChanceMultiplier() {\n        return plugin.getConfig().getDouble(\"features.treasures.legendaryChanceMultiplier\", 1.0);\n    }\n    \n    public boolean areBiomeSpecificTreasuresEnabled() {\n        return plugin.getConfig().getBoolean(\"features.treasures.biomeSpecific\", true);\n    }\n    \n    // ============================================\n    // DEBUG AYARLARI\n    // ============================================\n    \n    public boolean isDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.enabled\", false);\n    }\n    \n    public boolean isOreDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.enabled\", false);\n    }\n    \n    public boolean showOreCoordinates() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.showCoordinates\", true);\n    }\n    \n    public boolean showVeinSize() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.showVeinSize\", true);\n    }\n    \n    public boolean isTreeDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.treeGeneration.enabled\", false);\n    }\n    \n    public boolean isStructureDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.structureGeneration.enabled\", false);\n    }\n    \n    public boolean isPerformanceMonitorEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.performanceMonitor.enabled\", false);\n    }\n    \n    public int getPerformanceLogInterval() {\n        return plugin.getConfig().getInt(\"debug.performanceMonitor.logInterval\", 100);\n    }\n    \n    // ============================================\n    // LİMİT AYARLARI\n    // ============================================\n    \n    public int getPlanetsPerPlayer() {\n        return plugin.getConfig().getInt(\"limits.planetsPerPlayer\", 2);\n    }\n    \n    public boolean canDeleteOwnPlanet() {\n        return plugin.getConfig().getBoolean(\"limits.deleteOwnPlanet\", false);\n    }\n    \n    public int getMaxPlanetsPerWorld() {\n        return plugin.getConfig().getInt(\"limits.maxPlanetsPerWorld\", 100);\n    }\n    \n    public long getGenerationCooldown() {\n        return plugin.getConfig().getLong(\"limits.generationCooldown\", 300);\n    }\n    \n    // ============================================\n    // DÜNYA YÖNETİMİ\n    // ============================================\n    \n    public boolean isAutoSaveEnabled() {\n        return plugin.getConfig().getBoolean(\"worldManagement.autoSave.enabled\", true);\n    }\n    \n    public int getAutoSaveInterval() {\n        return plugin.getConfig().getInt(\"worldManagement.autoSave.interval\", 600);\n    }\n    \n    public boolean isChunkUnloadOptimization() {\n        return plugin.getConfig().getBoolean(\"worldManagement.chunkUnload.enabled\", true);\n    }\n    \n    public int getChunkUnloadDelay() {\n        return plugin.getConfig().getInt(\"worldManagement.chunkUnload.delay\", 200);\n    }\n    \n    // ============================================\n    // ENTEGRASYONLAR\n    // ============================================\n    \n    public boolean isVaultEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.vault.enabled\", false);\n    }\n    \n    public double getPlanetCreationCost() {\n        return plugin.getConfig().getDouble(\"integrations.vault.planetCreationCost\", 1000.0);\n    }\n    \n    public boolean isWorldGuardEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.worldguard.enabled\", false);\n    }\n    \n    public boolean isPlaceholderAPIEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.placeholderapi.enabled\", false);\n    }\n    \n    public boolean isDynmapEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.dynmap.enabled\", false);\n    }\n    \n    public boolean showPlanetsOnDynmap() {\n        return plugin.getConfig().getBoolean(\"integrations.dynmap.showPlanets\", true);\n    }\n    \n    // ============================================\n    // RASTGELE İSİM OLUŞTURMA\n    // ============================================\n    \n    public String generateRandomName() {\n        List<String> prefixes = plugin.getConfig().getStringList(\"planetNames.prefixes\");\n        List<String> suffixes = plugin.getConfig().getStringList(\"planetNames.suffixes\");\n        List<String> postfixes = plugin.getConfig().getStringList(\"planetNames.postfixes\");\n        List<String> formats = plugin.getConfig().getStringList(\"planetNames.formats\");\n        \n        if (prefixes.isEmpty() || suffixes.isEmpty() || formats.isEmpty()) {\n            return \"Gezegen-\" + UUID.randomUUID().toString().substring(0, 8);\n        }\n        \n        Random random = new Random();\n        String prefix = prefixes.get(random.nextInt(prefixes.size()));\n        String suffix = suffixes.get(random.nextInt(suffixes.size()));\n        String format = formats.get(random.nextInt(formats.size()));\n        \n        String name = format.replace(\"{prefix}\", prefix).replace(\"{suffix}\", suffix);\n        \n        if (name.contains(\"{postfix}\") && !postfixes.isEmpty()) {\n            String postfix = postfixes.get(random.nextInt(postfixes.size()));\n            name = name.replace(\"{postfix}\", postfix);\n        }\n        \n        if (name.contains(\"{number}\")) {\n            int min = plugin.getConfig().getInt(\"planetNames.numberRange.min\", 1);\n            int max = plugin.getConfig().getInt(\"planetNames.numberRange.max\", 999);\n            int number = min + random.nextInt(max - min + 1);\n            name = name.replace(\"{number}\", String.valueOf(number));\n        }\n        \n        return name;\n    }\n    \n    // ============================================\n    // MESAJ SİSTEMİ\n    // ============================================\n    \n    public String getMessage(String key) {\n        String prefix = plugin.getConfig().getString(\"messages.prefix\", \"&8[&bGezegen&8]&r\");\n        String message = plugin.getConfig().getString(\"messages.\" + key, key);\n        return colorize(prefix + \" \" + message);\n    }\n    \n    public String getMessageRaw(String key) {\n        return colorize(plugin.getConfig().getString(\"messages.\" + key, key));\n    }\n    \n    private String colorize(String text) {\n        return text.replace(\"&\", \"§\");\n    }\n    \n    // ============================================\n    // YARDIMCI METODLAR\n    // ============================================\n    \n    /**\n     * Debug mesajı gönder\n     */\n    public void sendDebugMessage(String category, String message) {\n        if (!isDebugEnabled()) return;\n        \n        boolean categoryEnabled = switch (category.toLowerCase()) {\n            case \"ore\" -> isOreDebugEnabled();\n            case \"tree\" -> isTreeDebugEnabled();\n            case \"structure\" -> isStructureDebugEnabled();\n            case \"performance\" -> isPerformanceMonitorEnabled();\n            default -> false;\n        };\n        \n        if (categoryEnabled) {\n            plugin.logInfo(\"[DEBUG:\" + category.toUpperCase() + \"] \" + message);\n        }\n    }\n    \n    /**\n     * Tüm feature'ları kontrol et\n     */\n    public boolean areAllFeaturesEnabled() {\n        return isOreGenerationEnabled() && \n               isTreeGenerationEnabled() && \n               isStructureGenerationEnabled() && \n               isTreasureGenerationEnabled();\n    }\n    \n    /**\n     * Config'i validate et\n     */\n    public void validateConfig() {\n        if (getMinRadius() >= getMaxRadius()) {\n            plugin.logWarning(\"minRadius >= maxRadius! Varsayılan değerler kullanılıyor.\");\n        }\n        \n        if (getBlocksPerBatch() > 1000) {\n            plugin.logWarning(\"blocksPerBatch çok yüksek! Performans sorunları olabilir.\");\n        }\n        \n        if (getThreadPoolCoreSize() > 16) {\n            plugin.logWarning(\"threadPoolCoreSize çok yüksek! CPU kullanımı artabilir.\");\n        }\n        \n        if (getShellThickness() < 3 || getShellThickness() > 15) {\n            plugin.logWarning(\"shellThickness ideal değerlerin dışında (3-15).\");\n        }\n    }\n}","size_bytes":15683},"src/main/java/com/skyorbs/shapes/impl/AsteroidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class AsteroidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.2);\n        double roughness = 0.6 + 0.4 * Math.abs(noise);\n        return distance <= radius * roughness;\n    }\n    \n    @Override\n    public String getName() {\n        return \"ASTEROID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Asteroid\";\n    }\n}\n","size_bytes":773},"src/main/java/com/skyorbs/shapes/impl/EllipsoidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\nimport java.util.Random;\n\npublic class EllipsoidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        Random rand = new Random(seed);\n        double rx = radius * (0.8 + 0.4 * rand.nextDouble());\n        double ry = radius * (0.8 + 0.4 * rand.nextDouble());\n        double rz = radius * (0.8 + 0.4 * rand.nextDouble());\n        \n        double val = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) + (dz * dz) / (rz * rz);\n        return val <= 1.0;\n    }\n    \n    @Override\n    public String getName() {\n        return \"ELLIPSOID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Elips\";\n    }\n}\n","size_bytes":871},"src/main/java/com/skyorbs/shapes/impl/BlobShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class BlobShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.15);\n        double deformation = 1 + 0.3 * noise;\n        return distance <= radius * deformation;\n    }\n    \n    @Override\n    public String getName() {\n        return \"BLOB\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.3;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Ameba\";\n    }\n}\n","size_bytes":755},"src/main/java/com/skyorbs/atmosphere/PlanetAtmosphereManager.java":{"content":"package com.skyorbs.atmosphere;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.*;\n\n/**\n * Manages atmospheric effects for planets\n * Applies particles, status effects, and visual effects to players on planets\n */\npublic class PlanetAtmosphereManager {\n    \n    private final SkyOrbs plugin;\n    private final Map<UUID, AtmosphereType> planetAtmospheres = new HashMap<>();\n    private BukkitRunnable atmosphereTask;\n    \n    public PlanetAtmosphereManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    /**\n     * Start atmosphere effects task\n     */\n    public void start() {\n        atmosphereTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                processAtmosphereEffects();\n            }\n        };\n        atmosphereTask.runTaskTimer(plugin, 20L, 20L); // Run every second\n    }\n    \n    /**\n     * Stop atmosphere effects task\n     */\n    public void stop() {\n        if (atmosphereTask != null) {\n            atmosphereTask.cancel();\n            atmosphereTask = null;\n        }\n    }\n    \n    /**\n     * Register atmosphere for a planet\n     */\n    public void registerPlanetAtmosphere(UUID planetId, AtmosphereType atmosphere) {\n        planetAtmospheres.put(planetId, atmosphere);\n    }\n    \n    /**\n     * Get atmosphere for a planet\n     */\n    public AtmosphereType getPlanetAtmosphere(UUID planetId) {\n        return planetAtmospheres.getOrDefault(planetId, AtmosphereType.CLEAR);\n    }\n    \n    /**\n     * Process atmospheric effects for all online players\n     */\n    private void processAtmosphereEffects() {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            Orb nearestPlanet = findNearestPlanet(player);\n            \n            if (nearestPlanet != null) {\n                AtmosphereType atmosphere = planetAtmospheres.get(nearestPlanet.getId());\n                if (atmosphere != null) {\n                    applyAtmosphereEffects(player, nearestPlanet, atmosphere);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Find nearest planet to player\n     */\n    private Orb findNearestPlanet(Player player) {\n        Location playerLoc = player.getLocation();\n        List<Orb> allPlanets;\n        \n        try {\n            allPlanets = plugin.getDatabaseManager().getAllOrbs();\n        } catch (Exception e) {\n            return null; // Return null if database error\n        }\n        \n        Orb nearest = null;\n        double minDistance = Double.MAX_VALUE;\n        \n        for (Orb orb : allPlanets) {\n            if (!orb.getWorldName().equals(playerLoc.getWorld().getName())) continue;\n            \n            double distance = Math.sqrt(\n                Math.pow(playerLoc.getX() - orb.getCenterX(), 2) +\n                Math.pow(playerLoc.getY() - orb.getCenterY(), 2) +\n                Math.pow(playerLoc.getZ() - orb.getCenterZ(), 2)\n            );\n            \n            // Check if player is within planet's atmosphere radius (1.5x planet radius)\n            if (distance <= orb.getRadius() * 1.5 && distance < minDistance) {\n                minDistance = distance;\n                nearest = orb;\n            }\n        }\n        \n        return nearest;\n    }\n    \n    /**\n     * Apply atmosphere effects to player\n     */\n    private void applyAtmosphereEffects(Player player, Orb planet, AtmosphereType atmosphere) {\n        // Apply potion effects\n        if (atmosphere.hasEffects()) {\n            player.addPotionEffect(new PotionEffect(\n                atmosphere.getEffectType(),\n                100,  // 5 seconds duration (refresh every second)\n                atmosphere == AtmosphereType.CORROSIVE ? 2 : 1, // Stronger corrosive\n                true,  // Ambient\n                true,  // Particles\n                true   // Icon\n            ));\n        }\n        \n        // Spawn particles around player\n        if (atmosphere.hasParticles()) {\n            spawnAtmosphereParticles(player, atmosphere);\n        }\n        \n        // Apply glow effect\n        if (atmosphere.hasGlow()) {\n            player.addPotionEffect(new PotionEffect(\n                PotionEffectType.NIGHT_VISION,\n                200,  // 10 seconds\n                0,\n                true,\n                false,\n                false\n            ));\n        }\n    }\n    \n    /**\n     * Spawn atmospheric particles around player\n     */\n    private void spawnAtmosphereParticles(Player player, AtmosphereType atmosphere) {\n        Location loc = player.getLocation();\n        World world = loc.getWorld();\n        Random random = new Random();\n        \n        // Spawn particles in a radius around player\n        for (int i = 0; i < 5; i++) {\n            double offsetX = (random.nextDouble() - 0.5) * 4;\n            double offsetY = (random.nextDouble() - 0.5) * 3;\n            double offsetZ = (random.nextDouble() - 0.5) * 4;\n            \n            Location particleLoc = loc.clone().add(offsetX, offsetY, offsetZ);\n            \n            world.spawnParticle(\n                atmosphere.getParticleType(),\n                particleLoc,\n                1,     // Count\n                0,     // Offset X\n                0,     // Offset Y\n                0,     // Offset Z\n                0.01   // Speed\n            );\n        }\n    }\n    \n    /**\n     * Select random atmosphere based on probabilities\n     */\n    public AtmosphereType selectRandomAtmosphere(Random random) {\n        double totalWeight = 0.0;\n        for (AtmosphereType type : AtmosphereType.values()) {\n            totalWeight += type.getProbability();\n        }\n        \n        double value = random.nextDouble() * totalWeight;\n        double current = 0.0;\n        \n        for (AtmosphereType type : AtmosphereType.values()) {\n            current += type.getProbability();\n            if (value <= current) {\n                return type;\n            }\n        }\n        \n        return AtmosphereType.CLEAR;\n    }\n}\n","size_bytes":6130},"src/main/java/com/skyorbs/SkyOrbs.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.commands.GezegenCommand;\nimport com.skyorbs.config.ConfigManager;\nimport com.skyorbs.generation.GenerationManager;\nimport com.skyorbs.shapes.ShapeRegistry;\nimport com.skyorbs.storage.DatabaseManager;\nimport com.skyorbs.dungeons.DungeonGenerator;\nimport com.skyorbs.palettes.PaletteRegistry;\nimport com.skyorbs.atmosphere.PlanetAtmosphereManager;\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.logging.Level;\n\npublic class SkyOrbs extends JavaPlugin {\n    \n    private static SkyOrbs instance;\n    private ConfigManager configManager;\n    private DatabaseManager databaseManager;\n    private GenerationManager generationManager;\n    private ShapeRegistry shapeRegistry;\n    private DungeonGenerator dungeonGenerator;\n    private PaletteRegistry paletteRegistry;\n    private PlanetAtmosphereManager atmosphereManager;\n    \n    // Performans metrikleri\n    private long startupTime;\n    private int totalPlanetsGenerated = 0;\n    \n    @Override\n    public void onEnable() {\n        startupTime = System.currentTimeMillis();\n        instance = this;\n        \n        logInfo(\"========================================\");\n        logInfo(\"SkyOrbs 2.0.0 aktifleştiriliyor...\");\n        logInfo(\"Türkçe Minecraft gezegen oluşturma eklentisi\");\n        logInfo(\"========================================\");\n        \n        // Config oluştur\n        saveDefaultConfig();\n        \n        try {\n            // 1. Config Manager\n            configManager = new ConfigManager(this);\n            configManager.validateConfig(); // Config doğrulama\n            logSuccess(\"✓ Konfigürasyon yüklendi ve doğrulandı\");\n            \n            // 2. Database\n            databaseManager = new DatabaseManager(this);\n            databaseManager.initialize();\n            logSuccess(\"✓ Veritabanı bağlantısı kuruldu\");\n            \n            // 3. Shape Registry\n            shapeRegistry = new ShapeRegistry();\n            shapeRegistry.registerAllShapes();\n            logSuccess(\"✓ \" + shapeRegistry.getShapeCount() + \" gezegen şekli kaydedildi\");\n            \n            // 3.5. Palette Registry (20+ palettes for diversity)\n            paletteRegistry = new PaletteRegistry();\n            logSuccess(\"✓ \" + paletteRegistry.getPaletteCount() + \" gezegen paleti kaydedildi\");\n            \n            // 3.6. Atmosphere Manager\n            atmosphereManager = new PlanetAtmosphereManager(this);\n            atmosphereManager.start();\n            logSuccess(\"✓ Atmosfer efekt sistemi başlatıldı\");\n            \n            // 4. Generation Manager\n            generationManager = new GenerationManager(this);\n            logSuccess(\"✓ Gezegen üretim sistemi hazır\");\n\n            // 4.5. Dungeon Generator\n            dungeonGenerator = new DungeonGenerator(this);\n            logSuccess(\"✓ Zindan üretim sistemi hazır\");\n            \n            // 5. Commands\n            registerCommands();\n            logSuccess(\"✓ Komutlar kaydedildi\");\n            \n            // 6. Özellik kontrolü\n            logFeatureStatus();\n            \n            // 7. Entegrasyon kontrolü\n            checkIntegrations();\n            \n            // 8. Performans monitörü\n            if (configManager.isPerformanceMonitorEnabled()) {\n                startPerformanceMonitor();\n            }\n            \n            // 9. Auto-save sistemi\n            if (configManager.isAutoSaveEnabled()) {\n                startAutoSave();\n            }\n            \n            long loadTime = System.currentTimeMillis() - startupTime;\n            \n            // Calculate total combinations\n            int totalCombinations = shapeRegistry.getShapeCount() * paletteRegistry.getPaletteCount() * 8; // 8 atmospheres\n            \n            logSuccess(\"========================================\");\n            logSuccess(\"SkyOrbs başarıyla aktifleştirildi!\");\n            logSuccess(\"17 şekil × 20 palet × 8 atmosfer = \" + totalCombinations + \"+ gezegen kombinasyonu!\");\n            logSuccess(\"Modifiyerler ile 10,000+ farklı gezegen çeşidi mümkün!\");\n            logSuccess(\"Yükleme süresi: \" + loadTime + \"ms\");\n            logSuccess(\"========================================\");\n            \n        } catch (Exception e) {\n            logError(\"Eklenti başlatılırken hata oluştu!\", e);\n            getServer().getPluginManager().disablePlugin(this);\n        }\n    }\n    \n    @Override\n    public void onDisable() {\n        logInfo(\"========================================\");\n        logInfo(\"SkyOrbs devre dışı bırakılıyor...\");\n        \n        if (atmosphereManager != null) {\n            atmosphereManager.stop();\n            logSuccess(\"✓ Atmosfer sistemi durduruldu\");\n        }\n        \n        if (generationManager != null) {\n            generationManager.shutdown();\n            logSuccess(\"✓ Üretim görevleri sonlandırıldı\");\n        }\n        \n        if (databaseManager != null) {\n            databaseManager.close();\n            logSuccess(\"✓ Veritabanı bağlantısı kapatıldı\");\n        }\n        \n        // İstatistikler\n        logInfo(\"Toplam oluşturulan gezegen: \" + totalPlanetsGenerated);\n        \n        logInfo(\"SkyOrbs devre dışı bırakıldı.\");\n        logInfo(\"========================================\");\n    }\n    \n    /**\n     * Komutları kaydet\n     */\n    private void registerCommands() {\n        GezegenCommand commandExecutor = new GezegenCommand(this);\n        getCommand(\"gezegen\").setExecutor(commandExecutor);\n        getCommand(\"gezegen\").setTabCompleter(commandExecutor);\n    }\n    \n    /**\n     * Özellik durumlarını logla\n     */\n    private void logFeatureStatus() {\n        logInfo(\"Özellik Durumu:\");\n        logInfo(\"  • Ore Sistemi: \" + (configManager.isOreGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Ağaç Sistemi: \" + (configManager.isTreeGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Yapı Sistemi: \" + (configManager.isStructureGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Hazine Sistemi: \" + (configManager.isTreasureGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Asteroid Sistemi: \" + (configManager.isAsteroidsEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Uydu Sistemi: \" + (configManager.isSatellitesEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n    }\n    \n    /**\n     * Entegrasyonları kontrol et\n     */\n    private void checkIntegrations() {\n        boolean hasIntegration = false;\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"Vault\") && configManager.isVaultEnabled()) {\n            logSuccess(\"✓ Vault entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"WorldGuard\") && configManager.isWorldGuardEnabled()) {\n            logSuccess(\"✓ WorldGuard entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"PlaceholderAPI\") && configManager.isPlaceholderAPIEnabled()) {\n            logSuccess(\"✓ PlaceholderAPI entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"dynmap\") && configManager.isDynmapEnabled()) {\n            logSuccess(\"✓ Dynmap entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (!hasIntegration) {\n            logInfo(\"Entegrasyon: Yok (opsiyonel)\");\n        }\n    }\n    \n    /**\n     * Performans monitörünü başlat\n     */\n    private void startPerformanceMonitor() {\n        int interval = configManager.getPerformanceLogInterval();\n        \n        Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {\n            Runtime runtime = Runtime.getRuntime();\n            long usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024;\n            long maxMemory = runtime.maxMemory() / 1024 / 1024;\n            \n            double tps = Bukkit.getTPS()[0]; // 1 dakikalık TPS\n            \n            configManager.sendDebugMessage(\"performance\", \n                String.format(\"TPS: %.2f | RAM: %dMB/%dMB | Gezegenler: %d\", \n                    tps, usedMemory, maxMemory, totalPlanetsGenerated));\n            \n        }, interval, interval);\n        \n        logInfo(\"✓ Performans monitörü başlatıldı\");\n    }\n    \n    /**\n     * Auto-save sistemini başlat\n     */\n    private void startAutoSave() {\n        int interval = configManager.getAutoSaveInterval() * 20; // Saniye to tick\n        \n        Bukkit.getScheduler().runTaskTimer(this, () -> {\n            try {\n                // Database'i kaydet (eğer varsa değişiklikler)\n                logInfo(\"Auto-save: Veri kaydediliyor...\");\n                // DatabaseManager zaten her işlemde kaydediyor, ek bir şey gerekmiyor\n                logInfo(\"Auto-save: Tamamlandı\");\n            } catch (Exception e) {\n                logError(\"Auto-save hatası!\", e);\n            }\n        }, interval, interval);\n        \n        logInfo(\"✓ Auto-save sistemi başlatıldı (Her \" + configManager.getAutoSaveInterval() + \" saniye)\");\n    }\n    \n    /**\n     * Config'i yeniden yükle\n     */\n    public void reloadPluginConfig() {\n        reloadConfig();\n        configManager = new ConfigManager(this);\n        configManager.validateConfig();\n        logSuccess(\"Konfigürasyon yeniden yüklendi ve doğrulandı\");\n    }\n    \n    /**\n     * Gezegen sayacını artır\n     */\n    public void incrementPlanetCount() {\n        totalPlanetsGenerated++;\n    }\n    \n    // ============================================\n    // GETTER METODLARI\n    // ============================================\n    \n    public static SkyOrbs getInstance() {\n        return instance;\n    }\n    \n    public ConfigManager getConfigManager() {\n        return configManager;\n    }\n    \n    public DatabaseManager getDatabaseManager() {\n        return databaseManager;\n    }\n    \n    public GenerationManager getGenerationManager() {\n        return generationManager;\n    }\n    \n    public ShapeRegistry getShapeRegistry() {\n        return shapeRegistry;\n    }\n\n    public DungeonGenerator getDungeonGenerator() {\n        return dungeonGenerator;\n    }\n    \n    public PaletteRegistry getPaletteRegistry() {\n        return paletteRegistry;\n    }\n    \n    public PlanetAtmosphereManager getAtmosphereManager() {\n        return atmosphereManager;\n    }\n    \n    public int getTotalPlanetsGenerated() {\n        return totalPlanetsGenerated;\n    }\n    \n    public long getUptime() {\n        return System.currentTimeMillis() - startupTime;\n    }\n    \n    // ============================================\n    // LOGGING METODLARI\n    // ============================================\n    \n    public void logInfo(String message) {\n        getLogger().info(message);\n    }\n    \n    public void logSuccess(String message) {\n        getLogger().info(\"§a\" + message);\n    }\n    \n    public void logWarning(String message) {\n        getLogger().warning(message);\n    }\n    \n    public void logError(String message, Exception e) {\n        getLogger().log(Level.SEVERE, message, e);\n    }\n    \n    public void logDebug(String category, String message) {\n        if (configManager != null) {\n            configManager.sendDebugMessage(category, message);\n        }\n    }\n}","size_bytes":11460},"src/main/java/com/skyorbs/modifiers/PlanetModifier.java":{"content":"package com.skyorbs.modifiers;\n\n/**\n * Planet modifiers that create diversity\n * Applied during generation to modify planet structure\n */\npublic enum PlanetModifier {\n    \n    HOLLOW(\"Hollow\", \"İçi Boş\", 0.4),           // Empty interior with shell\n    ORE_RICH(\"Ore Rich\", \"Maden Zengin\", 0.3),   // 2x ore density\n    MAGMA_CORE(\"Magma Core\", \"Magma Çekirdek\", 0.2),  // Hot glowing core\n    ICY_CORE(\"Icy Core\", \"Buz Çekirdek\", 0.15),       // Frozen core\n    LAYERED(\"Layered\", \"Katmanlı\", 0.25),       // Multiple material layers\n    ANTI_GRAVITY(\"Anti-Gravity\", \"Yer Çekimsiz\", 0.1), // Floating zones\n    DENSE(\"Dense\", \"Yoğun\", 0.2),               // Extra solid, more blocks\n    POROUS(\"Porous\", \"Gözenekli\", 0.15),        // Many caves and tunnels\n    RINGED(\"Ringed\", \"Halkalı\", 0.2),           // Has ring system\n    RADIOACTIVE(\"Radioactive\", \"Radyoaktif\", 0.05); // Dangerous radiation\n    \n    private final String name;\n    private final String displayName;\n    private final double probability;\n    \n    PlanetModifier(String name, String displayName, double probability) {\n        this.name = name;\n        this.displayName = displayName;\n        this.probability = probability;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getProbability() {\n        return probability;\n    }\n}\n","size_bytes":1429},"src/main/java/com/skyorbs/dungeons/DungeonGenerator.java":{"content":"package com.skyorbs.dungeons;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.*;\n\npublic class DungeonGenerator {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n\n    public DungeonGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Generate mini-dungeons within planets\n     */\n    public List<DungeonRoom> generateDungeons(Orb orb, int count) {\n        List<DungeonRoom> dungeons = new ArrayList<>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        SimplexOctaveGenerator dungeonNoise = new SimplexOctaveGenerator(seed + 500, 4);\n        dungeonNoise.setScale(0.01);\n\n        for (int i = 0; i < count; i++) {\n            // Find suitable location for dungeon\n            int attempts = 0;\n            boolean placed = false;\n\n            while (!placed && attempts < 50) {\n                // Generate position within planet\n                double angle = random.nextDouble() * 2 * Math.PI;\n                double distance = random.nextDouble() * (radius * 0.8); // Keep away from edges\n\n                int x = cx + (int)(Math.cos(angle) * distance);\n                int z = cz + (int)(Math.sin(angle) * distance);\n                int y = cy + random.nextInt(radius * 2) - radius;\n\n                // Check if location is valid (inside planet, not too close to surface)\n                double distFromCenter = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n                if (distFromCenter <= radius * 0.9 && distFromCenter >= radius * 0.3) {\n                    DungeonRoom dungeon = generateDungeonRoom(orb, x, y, z, seed + i);\n                    if (dungeon != null) {\n                        dungeons.add(dungeon);\n                        placed = true;\n                    }\n                }\n                attempts++;\n            }\n        }\n\n        return dungeons;\n    }\n\n    private DungeonRoom generateDungeonRoom(Orb orb, int x, int y, int z, long seed) {\n        Random roomRandom = new Random(seed);\n        DungeonType type = getDungeonTypeForPlanet(orb.getPlanetType(), roomRandom);\n\n        // Room size based on dungeon type\n        int width = type.baseSize + roomRandom.nextInt(3);\n        int height = type.baseSize + roomRandom.nextInt(2);\n        int length = type.baseSize + roomRandom.nextInt(3);\n\n        // Create room bounds\n        int minX = x - width/2;\n        int maxX = x + width/2;\n        int minY = y - height/2;\n        int maxY = y + height/2;\n        int minZ = z - length/2;\n        int maxZ = z + length/2;\n\n        DungeonRoom room = new DungeonRoom(type, minX, minY, minZ, maxX, maxY, maxZ);\n\n        // Generate room structure\n        generateRoomStructure(orb, room, roomRandom);\n\n        // Add loot\n        generateLoot(orb, room, roomRandom);\n\n        // Add mobs if applicable\n        generateMobs(room, roomRandom);\n\n        return room;\n    }\n\n    private void generateRoomStructure(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        // Clear area and create walls/floor/ceiling\n        for (int x = room.minX; x <= room.maxX; x++) {\n            for (int y = room.minY; y <= room.maxY; y++) {\n                for (int z = room.minZ; z <= room.maxZ; z++) {\n                    Block block = world.getBlockAt(x, y, z);\n                    Material material;\n\n                    if (x == room.minX || x == room.maxX || z == room.minZ || z == room.maxZ) {\n                        // Walls\n                        material = getWallMaterial(room.type, random);\n                    } else if (y == room.minY) {\n                        // Floor\n                        material = getFloorMaterial(room.type, random);\n                    } else if (y == room.maxY) {\n                        // Ceiling\n                        material = getCeilingMaterial(room.type, random);\n                    } else {\n                        // Air\n                        material = Material.AIR;\n                    }\n\n                    block.setType(material, false);\n                }\n            }\n        }\n\n        // Add decorative elements\n        addDecorations(orb, room, random);\n    }\n\n    private void addDecorations(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        int decorationCount = random.nextInt(5) + 3;\n\n        for (int i = 0; i < decorationCount; i++) {\n            int x = room.minX + 1 + random.nextInt(room.maxX - room.minX - 1);\n            int z = room.minZ + 1 + random.nextInt(room.maxZ - room.minZ - 1);\n            int y = room.minY + 1;\n\n            Block floorBlock = world.getBlockAt(x, y, z);\n            if (floorBlock.getType() == Material.AIR) {\n                Material decoration = getDecorationMaterial(room.type, random);\n                floorBlock.setType(decoration, false);\n            }\n        }\n    }\n\n    private void generateLoot(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        // Place treasure chest in center\n        int centerX = (room.minX + room.maxX) / 2;\n        int centerZ = (room.minZ + room.maxZ) / 2;\n        int chestY = room.minY + 1;\n\n        Block chestBlock = world.getBlockAt(centerX, chestY, centerZ);\n        chestBlock.setType(Material.CHEST, false);\n\n        if (chestBlock.getState() instanceof Chest chest) {\n            List<ItemStack> loot = generateLootItems(room.type, orb.getCoreLevel(), random);\n            for (int i = 0; i < Math.min(loot.size(), 27); i++) {\n                chest.getInventory().setItem(i, loot.get(i));\n            }\n        }\n    }\n\n    private List<ItemStack> generateLootItems(DungeonType type, int coreLevel, Random random) {\n        List<ItemStack> loot = new ArrayList<>();\n\n        // Base loot based on dungeon type\n        switch (type) {\n            case CRYSTAL_CAVERN -> {\n                loot.add(new ItemStack(Material.DIAMOND, random.nextInt(3) + 1));\n                loot.add(new ItemStack(Material.EMERALD, random.nextInt(2) + 1));\n                if (coreLevel >= 3) {\n                    loot.add(new ItemStack(Material.AMETHYST_SHARD, random.nextInt(5) + 3));\n                }\n            }\n            case LAVA_CHAMBER -> {\n                loot.add(new ItemStack(Material.GOLD_INGOT, random.nextInt(4) + 2));\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, random.nextInt(2)));\n                if (coreLevel >= 4) {\n                    loot.add(new ItemStack(Material.ANCIENT_DEBRIS, random.nextInt(3) + 1));\n                }\n            }\n            case ICE_TOMB -> {\n                loot.add(new ItemStack(Material.DIAMOND, random.nextInt(2) + 1));\n                if (coreLevel >= 2) {\n                    loot.add(new ItemStack(Material.BLUE_ICE, random.nextInt(8) + 4));\n                }\n            }\n            case SHADOW_VAULT -> {\n                loot.add(new ItemStack(Material.OBSIDIAN, random.nextInt(16) + 8));\n                if (coreLevel >= 5) {\n                    loot.add(new ItemStack(Material.CRYING_OBSIDIAN, random.nextInt(4) + 1));\n                }\n            }\n            case TOXIC_LAB -> {\n                loot.add(new ItemStack(Material.SLIME_BALL, random.nextInt(12) + 6));\n                if (coreLevel >= 3) {\n                    loot.add(new ItemStack(Material.HONEY_BOTTLE, random.nextInt(3) + 1));\n                }\n            }\n        }\n\n        // Add common loot\n        loot.add(new ItemStack(Material.IRON_INGOT, random.nextInt(8) + 4));\n        loot.add(new ItemStack(Material.GOLD_INGOT, random.nextInt(4) + 2));\n\n        // Add experience bottles based on core level\n        int expBottles = Math.min(coreLevel, 3);\n        for (int i = 0; i < expBottles; i++) {\n            loot.add(new ItemStack(Material.EXPERIENCE_BOTTLE, random.nextInt(3) + 1));\n        }\n\n        return loot;\n    }\n\n    private void generateMobs(DungeonRoom room, Random random) {\n        // This would integrate with Minecraft's mob spawning system\n        // For now, we'll just mark that mobs should spawn here\n        room.hasMobs = random.nextDouble() < 0.7; // 70% chance of mobs\n    }\n\n    /**\n     * Generate core crystal at planet center\n     */\n    public void generateCoreCrystal(Orb orb) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n\n        // Create crystal structure\n        int crystalSize = Math.min(3, orb.getCoreLevel());\n\n        for (int x = -crystalSize; x <= crystalSize; x++) {\n            for (int y = -crystalSize; y <= crystalSize; y++) {\n                for (int z = -crystalSize; z <= crystalSize; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n                    if (distance <= crystalSize) {\n                        Block block = world.getBlockAt(cx + x, cy + y, cz + z);\n                        if (distance < crystalSize * 0.5) {\n                            block.setType(Material.AMETHYST_BLOCK, false);\n                        } else {\n                            block.setType(Material.BUDDING_AMETHYST, false);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Create chest with special loot\n        Block chestBlock = world.getBlockAt(cx, cy + crystalSize + 1, cz);\n        chestBlock.setType(Material.CHEST, false);\n\n        if (chestBlock.getState() instanceof Chest chest) {\n            List<ItemStack> specialLoot = generateCoreLoot(orb);\n            for (int i = 0; i < Math.min(specialLoot.size(), 27); i++) {\n                chest.getInventory().setItem(i, specialLoot.get(i));\n            }\n        }\n    }\n\n    private List<ItemStack> generateCoreLoot(Orb orb) {\n        List<ItemStack> loot = new ArrayList<>();\n        Random random = new Random(orb.getSeed() + 999);\n\n        // Legendary items based on core level\n        if (orb.getCoreLevel() >= 5) {\n            loot.add(new ItemStack(Material.NETHERITE_INGOT, random.nextInt(3) + 1));\n            loot.add(new ItemStack(Material.DIAMOND_BLOCK, random.nextInt(2) + 1));\n        }\n\n        if (orb.getCoreLevel() >= 7) {\n            loot.add(new ItemStack(Material.ELYTRA, 1));\n        }\n\n        if (orb.getCoreLevel() >= 10) {\n            loot.add(new ItemStack(Material.NETHER_STAR, 1));\n        }\n\n        // Planet-specific legendary items\n        switch (orb.getPlanetType()) {\n            case CRYSTAL -> loot.add(new ItemStack(Material.AMETHYST_BLOCK, random.nextInt(16) + 8));\n            case LAVA -> loot.add(new ItemStack(Material.ANCIENT_DEBRIS, random.nextInt(8) + 4));\n            case ICE -> loot.add(new ItemStack(Material.BLUE_ICE, random.nextInt(32) + 16));\n            case SHADOW -> loot.add(new ItemStack(Material.CRYING_OBSIDIAN, random.nextInt(12) + 6));\n            case TOXIC -> loot.add(new ItemStack(Material.SLIME_BLOCK, random.nextInt(24) + 12));\n        }\n\n        return loot;\n    }\n\n    // Material getters\n    private Material getWallMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> random.nextDouble() < 0.8 ? Material.AMETHYST_BLOCK : Material.QUARTZ_BLOCK;\n            case LAVA_CHAMBER -> random.nextDouble() < 0.7 ? Material.NETHERRACK : Material.MAGMA_BLOCK;\n            case ICE_TOMB -> random.nextDouble() < 0.9 ? Material.ICE : Material.PACKED_ICE;\n            case SHADOW_VAULT -> Material.OBSIDIAN;\n            case TOXIC_LAB -> Material.GREEN_CONCRETE;\n        };\n    }\n\n    private Material getFloorMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> Material.QUARTZ_BLOCK;\n            case LAVA_CHAMBER -> Material.MAGMA_BLOCK;\n            case ICE_TOMB -> Material.PACKED_ICE;\n            case SHADOW_VAULT -> Material.CRYING_OBSIDIAN;\n            case TOXIC_LAB -> Material.SLIME_BLOCK;\n        };\n    }\n\n    private Material getCeilingMaterial(DungeonType type, Random random) {\n        return getWallMaterial(type, random);\n    }\n\n    private Material getDecorationMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> Material.AMETHYST_CLUSTER;\n            case LAVA_CHAMBER -> Material.LAVA;\n            case ICE_TOMB -> Material.SNOW;\n            case SHADOW_VAULT -> Material.SOUL_LANTERN;\n            case TOXIC_LAB -> Material.GREEN_WOOL;\n        };\n    }\n\n    private DungeonType getDungeonTypeForPlanet(PlanetType planetType, Random random) {\n        return switch (planetType) {\n            case TERRESTRIAL -> DungeonType.values()[random.nextInt(DungeonType.values().length)];\n            case GAS -> DungeonType.CRYSTAL_CAVERN; // Gas planets have crystal formations\n            case LAVA -> DungeonType.LAVA_CHAMBER;\n            case ICE -> DungeonType.ICE_TOMB;\n            case CRYSTAL -> DungeonType.CRYSTAL_CAVERN;\n            case SHADOW -> DungeonType.SHADOW_VAULT;\n            case TOXIC -> DungeonType.TOXIC_LAB;\n        };\n    }\n\n    public enum DungeonType {\n        CRYSTAL_CAVERN(5, \"Kristal Mağarası\"),\n        LAVA_CHAMBER(6, \"Lava Odası\"),\n        ICE_TOMB(4, \"Buz Mezarlığı\"),\n        SHADOW_VAULT(5, \"Gölge Kasası\"),\n        TOXIC_LAB(5, \"Zehirli Laboratuvar\");\n\n        final int baseSize;\n        final String displayName;\n\n        DungeonType(int baseSize, String displayName) {\n            this.baseSize = baseSize;\n            this.displayName = displayName;\n        }\n\n        public String getDisplayName() { return displayName; }\n    }\n\n    public static class DungeonRoom {\n        public final DungeonType type;\n        public final int minX, minY, minZ, maxX, maxY, maxZ;\n        public boolean hasMobs;\n\n        public DungeonRoom(DungeonType type, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n            this.type = type;\n            this.minX = minX;\n            this.minY = minY;\n            this.minZ = minZ;\n            this.maxX = maxX;\n            this.maxY = maxY;\n            this.maxZ = maxZ;\n            this.hasMobs = false;\n        }\n    }\n}","size_bytes":14750},"src/main/java/com/skyorbs/core/PlanetEvolution.java":{"content":"package com.skyorbs.core;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PlanetEvolution {\n\n    private final Orb orb;\n\n    public PlanetEvolution(Orb orb) {\n        this.orb = orb;\n    }\n\n    public void evolve() {\n        if (!orb.canUpgrade()) {\n            return;\n        }\n\n        int oldLevel = orb.getCoreLevel();\n        orb.setCoreLevel(oldLevel + 1);\n\n        // Apply evolution effects\n        applyEvolutionEffects(oldLevel, orb.getCoreLevel());\n\n        // Reset XP for next level\n        orb.addXp(-orb.getXpForNextLevel());\n    }\n\n    private void applyEvolutionEffects(int oldLevel, int newLevel) {\n        // Size increase\n        if (newLevel >= 3) {\n            // Planet grows larger\n        }\n\n        // New features unlock\n        if (newLevel >= 2) {\n            // Unlock atmosphere effects\n        }\n\n        if (newLevel >= 4) {\n            // Unlock advanced biomes\n        }\n\n        if (newLevel >= 6) {\n            // Unlock special events\n        }\n\n        if (newLevel >= 8) {\n            // Unlock legendary features\n        }\n\n        if (newLevel >= 10) {\n            // Maximum evolution - special title\n        }\n    }\n\n    public Map<String, Object> getEvolutionRequirements() {\n        Map<String, Object> requirements = new HashMap<>();\n        requirements.put(\"currentLevel\", orb.getCoreLevel());\n        requirements.put(\"currentXp\", orb.getXp());\n        requirements.put(\"xpForNextLevel\", orb.getXpForNextLevel());\n        requirements.put(\"canUpgrade\", orb.canUpgrade());\n        requirements.put(\"progressPercent\", (double) orb.getXp() / orb.getXpForNextLevel() * 100);\n        return requirements;\n    }\n\n    public String getEvolutionDescription() {\n        int level = orb.getCoreLevel();\n        return switch (level) {\n            case 1 -> \"Temel çekirdek - yaşamın başlangıcı\";\n            case 2 -> \"Gelişen çekirdek - atmosfer oluşuyor\";\n            case 3 -> \"Olgun çekirdek - biyom çeşitliliği\";\n            case 4 -> \"Güçlü çekirdek - özel yetenekler\";\n            case 5 -> \"İleri çekirdek - ekolojik denge\";\n            case 6 -> \"Gelişmiş çekirdek - olay sistemi\";\n            case 7 -> \"Üstün çekirdek - nadir kaynaklar\";\n            case 8 -> \"Efsanevi çekirdek - mistik güçler\";\n            case 9 -> \"Ultimate çekirdek - maksimum potansiyel\";\n            case 10 -> \"Kozmik çekirdek - evrenin gücü\";\n            default -> \"Bilinmeyen evrim seviyesi\";\n        };\n    }\n\n    public void gainXpFromActivity(String activity, int baseXp) {\n        double multiplier = getXpMultiplier();\n        int finalXp = (int) (baseXp * multiplier);\n        orb.addXp(finalXp);\n    }\n\n    private double getXpMultiplier() {\n        double multiplier = 1.0;\n\n        // Planet type bonus\n        multiplier *= orb.getPlanetType().getEnergyMultiplier();\n\n        // Biosphere level bonus\n        multiplier *= (1.0 + (orb.getBiosphereLevel() - 1) * 0.1);\n\n        // Ecological balance bonus\n        if (orb.getEcologicalBalance() > 1.0) {\n            multiplier *= 1.2;\n        } else if (orb.getEcologicalBalance() < 0.8) {\n            multiplier *= 0.8;\n        }\n\n        return multiplier;\n    }\n}","size_bytes":3203},"src/test/java/com/skyorbs/ConfigManagerTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.config.ConfigManager;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.MockedStatic;\n\nimport java.io.File;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class ConfigManagerTest {\n\n    private ConfigManager configManager;\n    private SkyOrbs mockPlugin;\n\n    @BeforeEach\n    public void setUp() {\n        mockPlugin = mock(SkyOrbs.class);\n        when(mockPlugin.getConfig()).thenReturn(new YamlConfiguration());\n        configManager = new ConfigManager(mockPlugin);\n    }\n\n    @Test\n    public void testConfigManagerInitialization() {\n        assertNotNull(configManager);\n    }\n\n    @Test\n    public void testDefaultRadiusValues() {\n        // Test default values when config returns defaults\n        assertEquals(80, configManager.getMinRadius());\n        assertEquals(250, configManager.getMaxRadius());\n        assertEquals(150, configManager.getAverageRadius());\n    }\n\n    @Test\n    public void testPlacementSettings() {\n        assertEquals(3000, configManager.getMaxDistance());\n        assertEquals(0, configManager.getCenterX());\n        assertEquals(0, configManager.getCenterZ());\n        assertTrue(configManager.isClusteringEnabled());\n    }\n\n    @Test\n    public void testShapeWeights() {\n        var weights = configManager.getShapeWeights();\n        assertNotNull(weights);\n        // Test sadece map'in null olmadığını kontrol eder - mock config'de weights olmayabilir\n        // Bu test ConfigManager'ın düzgün çalıştığını doğrular\n    }\n\n    @Test\n    public void testAsteroidSettings() {\n        assertTrue(configManager.isAsteroidsEnabled());\n        assertEquals(1, configManager.getMinAsteroidsPerPlanet());\n        assertEquals(5, configManager.getMaxAsteroidsPerPlanet());\n    }\n\n    @Test\n    public void testRandomNameGeneration() {\n        String name = configManager.generateRandomName();\n        assertNotNull(name);\n        assertTrue(name.length() > 0);\n    }\n\n    @Test\n    public void testPerformanceSettings() {\n        assertTrue(configManager.isAsyncGenerationEnabled());\n        assertEquals(250, configManager.getBlocksPerBatch());\n        assertEquals(1, configManager.getBatchesPerTick());\n    }\n}","size_bytes":2348},"src/main/java/com/skyorbs/storage/DatabaseManager.java":{"content":"package com.skyorbs.storage;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\n\nimport java.io.File;\nimport java.sql.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\npublic class DatabaseManager {\n    \n    private final SkyOrbs plugin;\n    private Connection connection;\n    private final String dbPath;\n    \n    public DatabaseManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        this.dbPath = plugin.getDataFolder() + \"/data.db\";\n    }\n    \n    public void initialize() throws SQLException {\n        File dataFolder = plugin.getDataFolder();\n        if (!dataFolder.exists()) {\n            dataFolder.mkdirs();\n        }\n        \n        connection = DriverManager.getConnection(\"jdbc:sqlite:\" + dbPath);\n        createTables();\n    }\n    \n    private void createTables() throws SQLException {\n        String orbsTable = \"\"\"\n            CREATE TABLE IF NOT EXISTS orbs (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                world TEXT NOT NULL,\n                centerX INTEGER NOT NULL,\n                centerY INTEGER NOT NULL,\n                centerZ INTEGER NOT NULL,\n                radius INTEGER NOT NULL,\n                shape TEXT NOT NULL,\n                biome TEXT NOT NULL,\n                seed BIGINT NOT NULL,\n                created_at BIGINT NOT NULL,\n                is_asteroid BOOLEAN DEFAULT 0,\n                parent_id TEXT,\n                FOREIGN KEY (parent_id) REFERENCES orbs(id) ON DELETE CASCADE\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(orbsTable);\n        }\n    }\n    \n    public void saveOrb(Orb orb) throws SQLException {\n        String sql = \"\"\"\n            INSERT OR REPLACE INTO orbs \n            (id, name, world, centerX, centerY, centerZ, radius, shape, biome, seed, created_at, is_asteroid, parent_id)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, orb.getId().toString());\n            pstmt.setString(2, orb.getName());\n            pstmt.setString(3, orb.getWorldName());\n            pstmt.setInt(4, orb.getCenterX());\n            pstmt.setInt(5, orb.getCenterY());\n            pstmt.setInt(6, orb.getCenterZ());\n            pstmt.setInt(7, orb.getRadius());\n            pstmt.setString(8, orb.getShapeName());\n            pstmt.setString(9, orb.getBiomeName());\n            pstmt.setLong(10, orb.getSeed());\n            pstmt.setLong(11, orb.getCreatedAt());\n            pstmt.setBoolean(12, orb.isAsteroid());\n            pstmt.setString(13, orb.getParentId() != null ? orb.getParentId().toString() : null);\n            pstmt.executeUpdate();\n        }\n    }\n    \n    public Orb getOrb(UUID id) throws SQLException {\n        String sql = \"SELECT * FROM orbs WHERE id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, id.toString());\n            ResultSet rs = pstmt.executeQuery();\n            \n            if (rs.next()) {\n                return mapResultSetToOrb(rs);\n            }\n        }\n        return null;\n    }\n    \n    public Orb getOrbByName(String name) throws SQLException {\n        String sql = \"SELECT * FROM orbs WHERE name = ? COLLATE NOCASE\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, name);\n            ResultSet rs = pstmt.executeQuery();\n            \n            if (rs.next()) {\n                return mapResultSetToOrb(rs);\n            }\n        }\n        return null;\n    }\n    \n    public List<Orb> getAllOrbs() throws SQLException {\n        List<Orb> orbs = new ArrayList<>();\n        String sql = \"SELECT * FROM orbs WHERE is_asteroid = 0 ORDER BY created_at DESC\";\n        \n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            \n            while (rs.next()) {\n                orbs.add(mapResultSetToOrb(rs));\n            }\n        }\n        return orbs;\n    }\n    \n    public List<Orb> getChildOrbs(UUID planetId) throws SQLException {\n        List<Orb> children = new ArrayList<>();\n        String sql = \"SELECT * FROM orbs WHERE parent_id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, planetId.toString());\n            ResultSet rs = pstmt.executeQuery();\n            \n            while (rs.next()) {\n                children.add(mapResultSetToOrb(rs));\n            }\n        }\n        return children;\n    }\n    \n    public void deleteOrb(UUID id) throws SQLException {\n        String sql = \"DELETE FROM orbs WHERE id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, id.toString());\n            pstmt.executeUpdate();\n        }\n    }\n    \n    private Orb mapResultSetToOrb(ResultSet rs) throws SQLException {\n        UUID id = UUID.fromString(rs.getString(\"id\"));\n        String name = rs.getString(\"name\");\n        String world = rs.getString(\"world\");\n        int centerX = rs.getInt(\"centerX\");\n        int centerY = rs.getInt(\"centerY\");\n        int centerZ = rs.getInt(\"centerZ\");\n        int radius = rs.getInt(\"radius\");\n        String shape = rs.getString(\"shape\");\n        String biome = rs.getString(\"biome\");\n        long seed = rs.getLong(\"seed\");\n        long createdAt = rs.getLong(\"created_at\");\n        boolean isAsteroid = rs.getBoolean(\"is_asteroid\");\n        \n        String parentIdStr = rs.getString(\"parent_id\");\n        UUID parentId = parentIdStr != null ? UUID.fromString(parentIdStr) : null;\n        \n        return new Orb(id, name, world, centerX, centerY, centerZ, radius, shape, biome, seed, createdAt, isAsteroid, parentId);\n    }\n    \n    public void close() {\n        try {\n            if (connection != null && !connection.isClosed()) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            plugin.logError(\"Veritabanı kapatılırken hata!\", e);\n        }\n    }\n}\n","size_bytes":6188},"src/main/java/com/skyorbs/utils/NoiseGenerator.java":{"content":"package com.skyorbs.utils;\n\nimport java.util.Random;\n\npublic class NoiseGenerator {\n    \n    private static final int[] PERMUTATION = new int[512];\n    \n    static {\n        Random rand = new Random(0);\n        for (int i = 0; i < 256; i++) {\n            PERMUTATION[i] = i;\n        }\n        for (int i = 0; i < 256; i++) {\n            int j = rand.nextInt(256);\n            int temp = PERMUTATION[i];\n            PERMUTATION[i] = PERMUTATION[j];\n            PERMUTATION[j] = temp;\n        }\n        for (int i = 0; i < 256; i++) {\n            PERMUTATION[256 + i] = PERMUTATION[i];\n        }\n    }\n    \n    public static double getNoise(int x, int y, int z, long seed, double frequency) {\n        Random seedRand = new Random(seed);\n        int offsetX = seedRand.nextInt(10000);\n        int offsetY = seedRand.nextInt(10000);\n        int offsetZ = seedRand.nextInt(10000);\n        \n        double nx = (x + offsetX) * frequency;\n        double ny = (y + offsetY) * frequency;\n        double nz = (z + offsetZ) * frequency;\n        \n        return perlinNoise(nx, ny, nz);\n    }\n    \n    private static double perlinNoise(double x, double y, double z) {\n        int X = (int) Math.floor(x) & 255;\n        int Y = (int) Math.floor(y) & 255;\n        int Z = (int) Math.floor(z) & 255;\n        \n        x -= Math.floor(x);\n        y -= Math.floor(y);\n        z -= Math.floor(z);\n        \n        double u = fade(x);\n        double v = fade(y);\n        double w = fade(z);\n        \n        int A = PERMUTATION[X] + Y;\n        int AA = PERMUTATION[A] + Z;\n        int AB = PERMUTATION[A + 1] + Z;\n        int B = PERMUTATION[X + 1] + Y;\n        int BA = PERMUTATION[B] + Z;\n        int BB = PERMUTATION[B + 1] + Z;\n        \n        return lerp(w,\n            lerp(v,\n                lerp(u, grad(PERMUTATION[AA], x, y, z), grad(PERMUTATION[BA], x - 1, y, z)),\n                lerp(u, grad(PERMUTATION[AB], x, y - 1, z), grad(PERMUTATION[BB], x - 1, y - 1, z))\n            ),\n            lerp(v,\n                lerp(u, grad(PERMUTATION[AA + 1], x, y, z - 1), grad(PERMUTATION[BA + 1], x - 1, y, z - 1)),\n                lerp(u, grad(PERMUTATION[AB + 1], x, y - 1, z - 1), grad(PERMUTATION[BB + 1], x - 1, y - 1, z - 1))\n            )\n        );\n    }\n    \n    private static double fade(double t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    \n    private static double lerp(double t, double a, double b) {\n        return a + t * (b - a);\n    }\n    \n    private static double grad(int hash, double x, double y, double z) {\n        int h = hash & 15;\n        double u = h < 8 ? x : y;\n        double v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n    }\n}\n","size_bytes":2732},"src/main/java/com/skyorbs/shapes/impl/PyramidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class PyramidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        if (dy < 0 || dy > radius) {\n            return false;\n        }\n        \n        int levelSize = radius - dy;\n        return Math.abs(dx) <= levelSize && Math.abs(dz) <= levelSize;\n    }\n    \n    @Override\n    public String getName() {\n        return \"PYRAMID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Piramit\";\n    }\n}\n","size_bytes":679},"src/main/java/com/skyorbs/shapes/impl/SpikyShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SpikyShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        double angle = Math.atan2(dz, dx);\n        double elevation = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));\n        \n        double spikePattern = Math.sin(angle * 6) * Math.cos(elevation * 4);\n        double spikeExtension = 1 + 0.3 * Math.max(0, spikePattern);\n        \n        return distance <= radius * spikeExtension;\n    }\n    \n    @Override\n    public String getName() {\n        return \"SPIKY\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.3;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Dikenli\";\n    }\n}\n","size_bytes":892},"src/main/java/com/skyorbs/core/PlanetType.java":{"content":"package com.skyorbs.core;\n\nimport org.bukkit.Material;\nimport org.bukkit.Color;\n\npublic enum PlanetType {\n\n    TERRESTRIAL(\"Karasal\", Material.GRASS_BLOCK, Color.GREEN, \"Dünya benzeri, yaşam dolu gezegen\"),\n    GAS(\"Gaz Devi\", Material.BLUE_WOOL, Color.BLUE, \"Gazdan oluşan dev gezegen\"),\n    LAVA(\"Lav\", Material.MAGMA_BLOCK, Color.ORANGE, \"Lav okyanusları ve volkanik aktivite\"),\n    ICE(\"Buz\", Material.PACKED_ICE, Color.AQUA, \"Donmuş yüzey ve buz fırtınaları\"),\n    CRYSTAL(\"Kristal\", Material.AMETHYST_BLOCK, Color.PURPLE, \"Kristal oluşumları ve mistik enerji\"),\n    SHADOW(\"Gölge\", Material.BLACK_CONCRETE, Color.BLACK, \"Karanlık ve mistik güçler\"),\n    TOXIC(\"Zehirli\", Material.SLIME_BLOCK, Color.LIME, \"Zehirli atmosfer ve tehlikeli flora\");\n\n    private final String displayName;\n    private final Material iconMaterial;\n    private final Color themeColor;\n    private final String description;\n\n    PlanetType(String displayName, Material iconMaterial, Color themeColor, String description) {\n        this.displayName = displayName;\n        this.iconMaterial = iconMaterial;\n        this.themeColor = themeColor;\n        this.description = description;\n    }\n\n    public String getDisplayName() {\n        return displayName;\n    }\n\n    public Material getIconMaterial() {\n        return iconMaterial;\n    }\n\n    public Color getThemeColor() {\n        return themeColor;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getEnergyMultiplier() {\n        return switch (this) {\n            case TERRESTRIAL -> 1.0;\n            case GAS -> 0.8;\n            case LAVA -> 1.2;\n            case ICE -> 0.9;\n            case CRYSTAL -> 1.5;\n            case SHADOW -> 1.3;\n            case TOXIC -> 1.1;\n        };\n    }\n\n    public int getMaxBiosphereLevel() {\n        return switch (this) {\n            case TERRESTRIAL -> 5;\n            case GAS -> 1;\n            case LAVA -> 2;\n            case ICE -> 3;\n            case CRYSTAL -> 4;\n            case SHADOW -> 3;\n            case TOXIC -> 4;\n        };\n    }\n\n    public boolean supportsLife() {\n        return this != GAS;\n    }\n\n    public boolean hasAtmosphere() {\n        return true; // All planets have atmosphere in this system\n    }\n}","size_bytes":2265},"src/main/java/com/skyorbs/biomes/BiomeType.java":{"content":"package com.skyorbs.biomes;\n\nimport org.bukkit.Material;\n\nimport java.util.Random;\n\npublic enum BiomeType {\n\n    // Earth-like biomes (6)\n    FOREST(\"Orman\", Material.GRASS_BLOCK, Material.OAK_LOG, Material.DIRT),\n    PLAINS(\"Düzlük\", Material.GRASS_BLOCK, Material.DIRT, Material.STONE),\n    JUNGLE(\"Orman\", Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, Material.MOSS_BLOCK),\n    SAVANNA(\"Savana\", Material.GRASS_BLOCK, Material.ACACIA_LOG, Material.COARSE_DIRT),\n    TAIGA(\"Tayga\", Material.SPRUCE_LOG, Material.SNOW_BLOCK, Material.STONE),\n    MEADOW(\"Çayır\", Material.GRASS_BLOCK, Material.FLOWERING_AZALEA_LEAVES, Material.MOSS_BLOCK),\n\n    // Desert biomes (3)\n    DESERT(\"Çöl\", Material.SAND, Material.SANDSTONE, Material.RED_SAND),\n    BADLANDS(\"Kötü Toprak\", Material.RED_SAND, Material.TERRACOTTA, Material.CLAY),\n    CANYON(\"Kanyon\", Material.ORANGE_TERRACOTTA, Material.RED_SANDSTONE, Material.STONE),\n\n    // Ice biomes (3)\n    FROZEN_TUNDRA(\"Donmuş Tundra\", Material.SNOW_BLOCK, Material.ICE, Material.PACKED_ICE),\n    ICE_SPIKES(\"Buz Dikenleri\", Material.PACKED_ICE, Material.BLUE_ICE, Material.SNOW_BLOCK),\n    GLACIER(\"Buzul\", Material.BLUE_ICE, Material.ICE, Material.STONE),\n\n    // Volcanic biomes (3)\n    LAVA_OCEAN(\"Lav Okyanusu\", Material.MAGMA_BLOCK, Material.NETHERRACK, Material.BLACKSTONE),\n    OBSIDIAN_PLAINS(\"Obsidyen Düzlüğü\", Material.OBSIDIAN, Material.CRYING_OBSIDIAN, Material.BLACKSTONE),\n    MAGMA_CAVES(\"Magma Mağaraları\", Material.NETHERRACK, Material.MAGMA_BLOCK, Material.BASALT),\n\n    // Alien biomes (7)\n    CRYSTAL_FOREST(\"Kristal Ormanı\", Material.AMETHYST_BLOCK, Material.PURPUR_BLOCK, Material.QUARTZ_BLOCK),\n    VOID(\"Boşluk\", Material.END_STONE, Material.OBSIDIAN, Material.CRYING_OBSIDIAN),\n    CORRUPTED(\"Bozulmuş\", Material.WARPED_NYLIUM, Material.CRIMSON_NYLIUM, Material.SOUL_SOIL),\n    MUSHROOM_GIANT(\"Dev Mantar\", Material.RED_MUSHROOM_BLOCK, Material.BROWN_MUSHROOM_BLOCK, Material.MYCELIUM),\n    TOXIC_SWAMP(\"Zehirli Bataklık\", Material.SLIME_BLOCK, Material.MOSS_BLOCK, Material.SCULK),\n    GLOWSTONE_CAVERN(\"Parıltı Taşı Mağarası\", Material.GLOWSTONE, Material.SHROOMLIGHT, Material.SEA_LANTERN),\n    CHORUS_LAND(\"Chorus Diyarı\", Material.CHORUS_PLANT, Material.PURPUR_BLOCK, Material.END_STONE),\n\n    // Additional diverse biomes (10 more for 20 total)\n    BASALTIC(\"Bazaltik\", Material.BASALT, Material.BLACKSTONE, Material.DEEPSLATE),\n    CRYSTALLINE(\"Kristalimsi\", Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.DIAMOND_BLOCK),\n    FUNGAL(\"Mantarlı\", Material.MYCELIUM, Material.RED_MUSHROOM_BLOCK, Material.BROWN_MUSHROOM_BLOCK),\n    CORAL(\"Mercan\", Material.BRAIN_CORAL_BLOCK, Material.TUBE_CORAL_BLOCK, Material.HORN_CORAL_BLOCK),\n    TOXIC(\"Zehirli\", Material.GREEN_CONCRETE, Material.LIME_CONCRETE, Material.SLIME_BLOCK),\n    AURORA(\"Aurora\", Material.PACKED_ICE, Material.BLUE_ICE, Material.LIGHT_BLUE_CONCRETE),\n    STORMY(\"Fırtınalı\", Material.GRAY_CONCRETE, Material.LIGHT_GRAY_CONCRETE, Material.STONE),\n    FOGGY(\"Sisli\", Material.WHITE_CONCRETE, Material.LIGHT_GRAY_CONCRETE, Material.COBBLESTONE),\n    CORROSIVE(\"Aşındırıcı\", Material.YELLOW_CONCRETE, Material.ORANGE_CONCRETE, Material.RED_CONCRETE),\n    LUMINOUS(\"Parıltılı\", Material.SEA_LANTERN, Material.GLOWSTONE, Material.SHROOMLIGHT);\n    \n    private final String displayName;\n    private final Material primary;\n    private final Material secondary;\n    private final Material tertiary;\n    \n    BiomeType(String displayName, Material primary, Material secondary, Material tertiary) {\n        this.displayName = displayName;\n        this.primary = primary;\n        this.secondary = secondary;\n        this.tertiary = tertiary;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public Material getMaterial(int depth, Random random) {\n        if (depth == 0) {\n            return primary;\n        } else if (depth < 3) {\n            return random.nextDouble() < 0.7 ? secondary : primary;\n        } else if (depth < 6) {\n            return random.nextDouble() < 0.5 ? tertiary : secondary;\n        } else {\n            return tertiary;\n        }\n    }\n    \n    public static BiomeType getRandomBiome(Random random) {\n        BiomeType[] values = values();\n        return values[random.nextInt(values.length)];\n    }\n    \n    public static BiomeType getRandomBiomeWeighted(Random random) {\n        double rand = random.nextDouble();\n\n        if (rand < 0.25) {\n            // Earth-like biomes (6)\n            BiomeType[] earthLike = {FOREST, PLAINS, JUNGLE, SAVANNA, TAIGA, MEADOW};\n            return earthLike[random.nextInt(earthLike.length)];\n        } else if (rand < 0.40) {\n            // Desert biomes (3)\n            BiomeType[] desertLike = {DESERT, BADLANDS, CANYON};\n            return desertLike[random.nextInt(desertLike.length)];\n        } else if (rand < 0.55) {\n            // Ice biomes (3)\n            BiomeType[] ice = {FROZEN_TUNDRA, ICE_SPIKES, GLACIER};\n            return ice[random.nextInt(ice.length)];\n        } else if (rand < 0.70) {\n            // Volcanic biomes (3)\n            BiomeType[] volcanic = {LAVA_OCEAN, OBSIDIAN_PLAINS, MAGMA_CAVES};\n            return volcanic[random.nextInt(volcanic.length)];\n        } else if (rand < 0.85) {\n            // Alien biomes (7)\n            BiomeType[] alien = {CRYSTAL_FOREST, VOID, CORRUPTED, MUSHROOM_GIANT, TOXIC_SWAMP, GLOWSTONE_CAVERN, CHORUS_LAND};\n            return alien[random.nextInt(alien.length)];\n        } else {\n            // Additional diverse biomes (10)\n            BiomeType[] diverse = {BASALTIC, CRYSTALLINE, FUNGAL, CORAL, TOXIC, AURORA, STORMY, FOGGY, CORROSIVE, LUMINOUS};\n            return diverse[random.nextInt(diverse.length)];\n        }\n    }\n}\n","size_bytes":5777},"src/main/java/com/skyorbs/features/TreeGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class TreeGenerator {\n    \n    public static List<OreGenerator.BlockData> generateTrees(Orb orb, BiomeType biome, World world) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(orb.getSeed() + 456);\n        \n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        \n        // Biyom bazlı ağaç yoğunluğu - DAHA FAZLA AĞAÇ İÇİN ÇARPAN\n        TreeConfig config = getTreeConfig(biome);\n        if (config == null) return blocks;\n\n        double treeMultiplier = 2.0; // 2x daha fazla ağaç\n        int treeCount = (int)(radius * config.density * treeMultiplier);\n        \n        for (int i = 0; i < treeCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // YÜZEYDE SPAWN ET - ZEMİNE DEĞMESİ İÇİN!\n            int y = findGroundLevel(cx, cy, cz, x, z, radius);\n\n            if (y == -1) continue; // Uygun yer bulunamadıysa atla\n\n            // Ağaç türünü seç\n            TreeType type = config.getRandomType(random);\n\n            // Ağacı oluştur\n            generateTree(blocks, x, y, z, type, random);\n        }\n        \n        return blocks;\n    }\n\n    /**\n     * Find appropriate ground level for trees - ensure they are grounded on solid blocks\n     */\n    private static int findGroundLevel(int cx, int cy, int cz, int x, int z, int radius) {\n        // Start from planet surface and go downward to find solid ground\n        for (int y = cy + radius; y >= cy - radius; y--) {\n            double distance = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n\n            // Check if we're in the surface layer of the planet\n            if (distance <= radius && distance >= radius - 3) { // Surface layer\n                // Check downward from this position to find actual solid ground\n                for (int checkY = y; checkY >= cy - radius; checkY--) {\n                    double checkDistance = Math.sqrt((x - cx) * (x - cx) + (checkY - cy) * (checkY - cy) + (z - cz) * (z - cz));\n\n                    // If we find a solid block within planet volume, that's our ground\n                    if (checkDistance <= radius - 1) { // Inside solid volume\n                        return checkY;\n                    }\n                }\n            }\n        }\n\n        return -1; // No suitable ground found\n    }\n    \n    /**\n     * Tek bir ağaç oluşturur\n     */\n    private static void generateTree(List<OreGenerator.BlockData> blocks, int x, int y, int z, \n                                     TreeType type, Random random) {\n        \n        int height = type.minHeight + random.nextInt(type.maxHeight - type.minHeight + 1);\n        \n        // Gövde\n        for (int i = 0; i < height; i++) {\n            blocks.add(new OreGenerator.BlockData(x, y + i, z, type.logMaterial));\n        }\n        \n        // Yapraklar\n        int leafStart = y + height - type.leafLayers;\n        for (int ly = 0; ly < type.leafLayers; ly++) {\n            int currentY = leafStart + ly;\n            int leafRadius = type.leafRadius - (ly / 2);\n            \n            for (int dx = -leafRadius; dx <= leafRadius; dx++) {\n                for (int dz = -leafRadius; dz <= leafRadius; dz++) {\n                    if (dx == 0 && dz == 0 && ly < type.leafLayers - 1) continue; // Gövdeyi atla\n                    \n                    double distance = Math.sqrt(dx * dx + dz * dz);\n                    if (distance <= leafRadius + random.nextDouble() * 0.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, currentY, z + dz, type.leafMaterial));\n                    }\n                }\n            }\n        }\n        \n        // Özel özellikler\n        if (type == TreeType.OAK && random.nextDouble() < 0.15) {\n            // Arı kovanı ekle\n            int side = random.nextInt(4);\n            int beeY = y + height - 2;\n            switch (side) {\n                case 0 -> blocks.add(new OreGenerator.BlockData(x + 1, beeY, z, Material.BEE_NEST));\n                case 1 -> blocks.add(new OreGenerator.BlockData(x - 1, beeY, z, Material.BEE_NEST));\n                case 2 -> blocks.add(new OreGenerator.BlockData(x, beeY, z + 1, Material.BEE_NEST));\n                case 3 -> blocks.add(new OreGenerator.BlockData(x, beeY, z - 1, Material.BEE_NEST));\n            }\n        }\n        \n        if (type == TreeType.JUNGLE && random.nextDouble() < 0.25) {\n            // Kakao ekle\n            int cocoaCount = 1 + random.nextInt(3);\n            for (int i = 0; i < cocoaCount; i++) {\n                int cocoaY = y + 2 + random.nextInt(height - 3);\n                int side = random.nextInt(4);\n                switch (side) {\n                    case 0 -> blocks.add(new OreGenerator.BlockData(x + 1, cocoaY, z, Material.COCOA));\n                    case 1 -> blocks.add(new OreGenerator.BlockData(x - 1, cocoaY, z, Material.COCOA));\n                    case 2 -> blocks.add(new OreGenerator.BlockData(x, cocoaY, z + 1, Material.COCOA));\n                    case 3 -> blocks.add(new OreGenerator.BlockData(x, cocoaY, z - 1, Material.COCOA));\n                }\n            }\n            \n            // Asma yapraklar\n            int vineCount = 3 + random.nextInt(5);\n            for (int i = 0; i < vineCount; i++) {\n                int vineX = x + random.nextInt(5) - 2;\n                int vineZ = z + random.nextInt(5) - 2;\n                int vineLength = 2 + random.nextInt(4);\n                \n                for (int vl = 0; vl < vineLength; vl++) {\n                    blocks.add(new OreGenerator.BlockData(vineX, y + height - vl, vineZ, Material.VINE));\n                }\n            }\n        }\n        \n        if (type == TreeType.DARK_OAK && random.nextDouble() < 0.30) {\n            // Mantarlar ekle\n            for (int i = 0; i < 3; i++) {\n                int mushX = x + random.nextInt(5) - 2;\n                int mushZ = z + random.nextInt(5) - 2;\n                Material mushroom = random.nextBoolean() ? Material.RED_MUSHROOM : Material.BROWN_MUSHROOM;\n                blocks.add(new OreGenerator.BlockData(mushX, y, mushZ, mushroom));\n            }\n        }\n        \n        if (type == TreeType.CHERRY && random.nextDouble() < 0.40) {\n            // Pembe yaprak efekti (ek yapraklar)\n            for (int i = 0; i < 5; i++) {\n                int petalX = x + random.nextInt(7) - 3;\n                int petalY = y + height + random.nextInt(2);\n                int petalZ = z + random.nextInt(7) - 3;\n                blocks.add(new OreGenerator.BlockData(petalX, petalY, petalZ, Material.PINK_PETALS));\n            }\n        }\n    }\n    \n    /**\n     * Biyom bazlı ağaç konfigürasyonu\n     */\n    private static TreeConfig getTreeConfig(BiomeType biome) {\n        return switch (biome) {\n            case FOREST -> new TreeConfig(0.25, \n                new TreeType[]{TreeType.OAK, TreeType.BIRCH, TreeType.DARK_OAK},\n                new double[]{0.5, 0.3, 0.2});\n            \n            case JUNGLE -> new TreeConfig(0.35, \n                new TreeType[]{TreeType.JUNGLE, TreeType.JUNGLE_LARGE},\n                new double[]{0.7, 0.3});\n            \n            case TAIGA -> new TreeConfig(0.20, \n                new TreeType[]{TreeType.SPRUCE, TreeType.PINE},\n                new double[]{0.7, 0.3});\n            \n            case SAVANNA -> new TreeConfig(0.08, \n                new TreeType[]{TreeType.ACACIA},\n                new double[]{1.0});\n            \n            case MEADOW -> new TreeConfig(0.15, \n                new TreeType[]{TreeType.OAK, TreeType.BIRCH, TreeType.CHERRY},\n                new double[]{0.4, 0.4, 0.2});\n            \n            case PLAINS -> new TreeConfig(0.05, \n                new TreeType[]{TreeType.OAK},\n                new double[]{1.0});\n            \n            case MUSHROOM_GIANT -> new TreeConfig(0.12, \n                new TreeType[]{TreeType.GIANT_MUSHROOM_RED, TreeType.GIANT_MUSHROOM_BROWN},\n                new double[]{0.5, 0.5});\n            \n            case TOXIC_SWAMP -> new TreeConfig(0.18, \n                new TreeType[]{TreeType.MANGROVE, TreeType.DARK_OAK},\n                new double[]{0.6, 0.4});\n            \n            default -> null;\n        };\n    }\n    \n    /**\n     * Ağaç türleri\n     */\n    private enum TreeType {\n        OAK(Material.OAK_LOG, Material.OAK_LEAVES, 4, 6, 2, 4),\n        BIRCH(Material.BIRCH_LOG, Material.BIRCH_LEAVES, 5, 7, 2, 4),\n        SPRUCE(Material.SPRUCE_LOG, Material.SPRUCE_LEAVES, 6, 10, 2, 5),\n        JUNGLE(Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, 4, 6, 2, 4),\n        JUNGLE_LARGE(Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, 10, 15, 3, 6),\n        ACACIA(Material.ACACIA_LOG, Material.ACACIA_LEAVES, 4, 6, 3, 4),\n        DARK_OAK(Material.DARK_OAK_LOG, Material.DARK_OAK_LEAVES, 5, 7, 3, 5),\n        MANGROVE(Material.MANGROVE_LOG, Material.MANGROVE_LEAVES, 4, 7, 2, 4),\n        CHERRY(Material.CHERRY_LOG, Material.CHERRY_LEAVES, 5, 8, 3, 5),\n        PINE(Material.SPRUCE_LOG, Material.SPRUCE_LEAVES, 8, 12, 2, 6),\n        GIANT_MUSHROOM_RED(Material.MUSHROOM_STEM, Material.RED_MUSHROOM_BLOCK, 4, 6, 3, 5),\n        GIANT_MUSHROOM_BROWN(Material.MUSHROOM_STEM, Material.BROWN_MUSHROOM_BLOCK, 4, 6, 3, 5);\n        \n        final Material logMaterial;\n        final Material leafMaterial;\n        final int minHeight;\n        final int maxHeight;\n        final int leafRadius;\n        final int leafLayers;\n        \n        TreeType(Material log, Material leaf, int minH, int maxH, int leafR, int leafL) {\n            this.logMaterial = log;\n            this.leafMaterial = leaf;\n            this.minHeight = minH;\n            this.maxHeight = maxH;\n            this.leafRadius = leafR;\n            this.leafLayers = leafL;\n        }\n    }\n    \n    /**\n     * Biyom ağaç konfigürasyonu\n     */\n    private static class TreeConfig {\n        final double density;\n        final TreeType[] types;\n        final double[] weights;\n        \n        TreeConfig(double density, TreeType[] types, double[] weights) {\n            this.density = density;\n            this.types = types;\n            this.weights = weights;\n        }\n        \n        TreeType getRandomType(Random random) {\n            double total = 0;\n            for (double w : weights) total += w;\n            \n            double rand = random.nextDouble() * total;\n            double current = 0;\n            \n            for (int i = 0; i < types.length; i++) {\n                current += weights[i];\n                if (rand <= current) {\n                    return types[i];\n                }\n            }\n            \n            return types[0];\n        }\n    }\n}","size_bytes":11037},"src/test/java/com/skyorbs/ShapeRegistryTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.shapes.ShapeRegistry;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ShapeRegistryTest {\n\n    private ShapeRegistry shapeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        shapeRegistry = new ShapeRegistry();\n        shapeRegistry.registerAllShapes();\n    }\n\n    @Test\n    public void testShapeRegistryInitialization() {\n        assertNotNull(shapeRegistry);\n        assertEquals(18, shapeRegistry.getShapeCount());\n    }\n\n    @Test\n    public void testShapeRetrieval() {\n        PlanetShape sphere = shapeRegistry.getShape(\"SPHERE\");\n        assertNotNull(sphere);\n        assertEquals(\"SPHERE\", sphere.getName());\n        assertEquals(\"Küre\", sphere.getDisplayName());\n    }\n\n    @Test\n    public void testRandomShapeSelection() {\n        PlanetShape randomShape = shapeRegistry.getRandomShape(java.util.Map.of(\n            \"SPHERE\", 1.0,\n            \"BLOB\", 0.0\n        ));\n        assertNotNull(randomShape);\n        assertEquals(\"SPHERE\", randomShape.getName());\n    }\n\n    @Test\n    public void testInvalidShapeRetrieval() {\n        PlanetShape invalidShape = shapeRegistry.getShape(\"INVALID\");\n        assertNotNull(invalidShape); // Should return default SPHERE\n        assertEquals(\"SPHERE\", invalidShape.getName());\n    }\n}","size_bytes":1418},"src/main/java/com/skyorbs/commands/GezegenCommand.java":{"content":"package com.skyorbs.commands;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.command.*;\nimport org.bukkit.entity.Player;\n\nimport java.sql.SQLException;\nimport java.util.*;\n\npublic class GezegenCommand implements CommandExecutor, TabCompleter {\n    \n    private final SkyOrbs plugin;\n    \n    public GezegenCommand(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (args.length == 0) {\n            sendHelp(sender);\n            return true;\n        }\n        \n        switch (args[0].toLowerCase()) {\n            case \"create\", \"oluştur\" -> handleCreate(sender);\n            case \"list\", \"liste\" -> handleList(sender);\n            case \"tp\", \"teleport\", \"ışınlan\" -> handleTeleport(sender, args);\n            case \"sil\", \"delete\" -> handleDelete(sender, args);\n            case \"info\", \"bilgi\" -> handleInfo(sender, args);\n            case \"reload\", \"yenile\" -> handleReload(sender);\n            default -> sendHelp(sender);\n        }\n        \n        return true;\n    }\n    \n    private void handleCreate(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.create\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n        \n        if (!(sender instanceof Player player)) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"playerOnly\"));\n            return;\n        }\n        \n        World world = player.getWorld();\n        plugin.getGenerationManager().createPlanetAsync(world, player);\n    }\n    \n    private void handleList(CommandSender sender) {\n        try {\n            List<Orb> orbs = plugin.getDatabaseManager().getAllOrbs();\n            \n            if (orbs.isEmpty()) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"listEmpty\"));\n                return;\n            }\n            \n            sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"listHeader\")\n                .replace(\"{count}\", String.valueOf(orbs.size())));\n            \n            for (Orb orb : orbs) {\n                String shapeName = plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName();\n                double distFromSpawn = orb.getDistanceFromSpawn();\n                \n                sender.sendMessage(String.format(\"§e%s §7- §f%s §7| §f%d,%d,%d §7(Spawn'dan §f%.0f §7blok)\",\n                    orb.getName(), shapeName, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ(), distFromSpawn));\n            }\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleTeleport(CommandSender sender, String[] args) {\n        if (!(sender instanceof Player player)) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"playerOnly\"));\n            return;\n        }\n        \n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen tp <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            World world = Bukkit.getWorld(orb.getWorldName());\n            if (world == null) {\n                sender.sendMessage(\"§cGezegen dünyası bulunamadı!\");\n                return;\n            }\n            \n            Location loc = new Location(world, orb.getCenterX(), orb.getCenterY() + orb.getRadius() + 10, orb.getCenterZ());\n            player.teleport(loc);\n            \n            sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"teleported\")\n                .replace(\"{name}\", orb.getName()));\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleDelete(CommandSender sender, String[] args) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n        \n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen sil <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            sender.sendMessage(\"§eGezegen siliniyor...\");\n            \n            plugin.getGenerationManager().deletePlanet(orb)\n                .thenRun(() -> {\n                    sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetDeleted\")\n                        .replace(\"{name}\", orb.getName()));\n                });\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleInfo(CommandSender sender, String[] args) {\n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen info <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            List<Orb> allOrbs = plugin.getDatabaseManager().getAllOrbs();\n            \n            sender.sendMessage(\"§b═══ Gezegen Bilgileri ═══\");\n            sender.sendMessage(\"§7İsim: §e\" + orb.getName());\n            sender.sendMessage(\"§7Şekil: §f\" + plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName());\n            sender.sendMessage(\"§7Biyom: §f\" + orb.getBiomeName());\n            sender.sendMessage(\"§7Yarıçap: §f\" + orb.getRadius() + \" blok\");\n            sender.sendMessage(\"§7Merkez: §f\" + orb.getCenterX() + \", \" + orb.getCenterY() + \", \" + orb.getCenterZ());\n            sender.sendMessage(\"§7Spawn'dan Uzaklık: §f\" + String.format(\"%.0f\", orb.getDistanceFromSpawn()) + \" blok\");\n            \n            sender.sendMessage(\"§7Yakındaki Gezegenler:\");\n            int nearbyCount = 0;\n            for (Orb other : allOrbs) {\n                if (!other.getId().equals(orb.getId())) {\n                    double distance = orb.getDistanceFrom(other.getCenterX(), other.getCenterZ());\n                    if (distance < 3000 && nearbyCount < 5) {\n                        sender.sendMessage(String.format(\"  §8• §e%s §7- §f%.0f blok uzakta\", other.getName(), distance));\n                        nearbyCount++;\n                    }\n                }\n            }\n            \n            if (nearbyCount == 0) {\n                sender.sendMessage(\"  §7(Yakında gezegen yok)\");\n            }\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleReload(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n        \n        plugin.reloadPluginConfig();\n        sender.sendMessage(plugin.getConfigManager().getMessage(\"configReloaded\"));\n    }\n    \n    private void sendHelp(CommandSender sender) {\n        sender.sendMessage(\"§b═══ Gezegen Komutları ═══\");\n        sender.sendMessage(\"§e/gezegen create §7- Yeni gezegen oluştur\");\n        sender.sendMessage(\"§e/gezegen list §7- Tüm gezegenleri listele\");\n        sender.sendMessage(\"§e/gezegen tp <isim> §7- Gezegene ışınlan\");\n        sender.sendMessage(\"§e/gezegen info <isim> §7- Gezegen bilgilerini göster\");\n        sender.sendMessage(\"§e/gezegen sil <isim> §7- Gezegeni sil (Admin)\");\n        sender.sendMessage(\"§e/gezegen reload §7- Konfigürasyonu yenile (Admin)\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        if (args.length == 1) {\n            return Arrays.asList(\"create\", \"list\", \"tp\", \"info\", \"sil\", \"reload\");\n        }\n        \n        if (args.length == 2 && (args[0].equalsIgnoreCase(\"tp\") || args[0].equalsIgnoreCase(\"info\") || args[0].equalsIgnoreCase(\"sil\"))) {\n            try {\n                List<Orb> orbs = plugin.getDatabaseManager().getAllOrbs();\n                return orbs.stream().map(Orb::getName).toList();\n            } catch (SQLException e) {\n                return new ArrayList<>();\n            }\n        }\n        \n        return new ArrayList<>();\n    }\n}\n","size_bytes":9278},"src/main/java/com/skyorbs/features/AsteroidGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class AsteroidGenerator {\n\n    private final SkyOrbs plugin;\n\n    public AsteroidGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Ana gezegen için asteroidler üretir\n     */\n    public List<Orb> generateAsteroidsForPlanet(Orb planet, World world) {\n        List<Orb> asteroids = new ArrayList<>();\n        Random random = new Random(planet.getSeed() + 999);\n\n        int minCount = plugin.getConfigManager().getMinAsteroidsPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxAsteroidsPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            Orb asteroid = createAsteroid(planet, world, random);\n            if (asteroid != null) {\n                asteroids.add(asteroid);\n            }\n        }\n\n        return asteroids;\n    }\n\n    /**\n     * Tek bir asteroid oluşturur\n     */\n    private Orb createAsteroid(Orb parentPlanet, World world, Random random) {\n        int minRadius = plugin.getConfigManager().getMinAsteroidRadius();\n        int maxRadius = plugin.getConfigManager().getMaxAsteroidRadius();\n\n        // Boyut dağılımı (küçük %60, orta %30, büyük %10)\n        double sizeRand = random.nextDouble();\n        int radius;\n        if (sizeRand < 0.6) {\n            radius = minRadius + random.nextInt(11); // 20-30\n        } else if (sizeRand < 0.9) {\n            radius = 30 + random.nextInt(11); // 30-40\n        } else {\n            radius = 40 + random.nextInt(11); // 40-50\n        }\n\n        // Şekil seçimi (Asteroid %70, Fractal %20, Spiky %10)\n        String shapeName;\n        double shapeRand = random.nextDouble();\n        if (shapeRand < 0.7) {\n            shapeName = \"ASTEROID\";\n        } else if (shapeRand < 0.9) {\n            shapeName = \"FRACTAL\";\n        } else {\n            shapeName = \"SPIKY\";\n        }\n\n        // Biyom seçimi (rastgele ama mantıklı)\n        BiomeType biome = getRandomAsteroidBiome(random);\n\n        // Pozisyon hesaplama\n        int[] position = calculateAsteroidPosition(parentPlanet, random);\n        int centerX = position[0];\n        int centerY = position[1];\n        int centerZ = position[2];\n\n        // İsim oluşturma\n        String name = \"Asteroid-\" + UUID.randomUUID().toString().substring(0, 6);\n\n        // Seed oluşturma\n        long seed = random.nextLong();\n\n        return new Orb(\n            UUID.randomUUID(),\n            name,\n            world.getName(),\n            centerX,\n            centerY,\n            centerZ,\n            radius,\n            shapeName,\n            biome.name(),\n            seed,\n            System.currentTimeMillis(),\n            true, // isAsteroid = true\n            parentPlanet.getId()\n        );\n    }\n\n    /**\n     * Asteroid pozisyonunu hesaplar\n     */\n    private int[] calculateAsteroidPosition(Orb parentPlanet, Random random) {\n        int parentX = parentPlanet.getCenterX();\n        int parentY = parentPlanet.getCenterY();\n        int parentZ = parentPlanet.getCenterZ();\n\n        int minDistance = plugin.getConfigManager().getMinAsteroidDistance();\n        int maxDistance = plugin.getConfigManager().getMaxAsteroidDistance();\n\n        // Rastgele açı ve mesafe\n        double angle = random.nextDouble() * 2 * Math.PI;\n        int distance = minDistance + random.nextInt(maxDistance - minDistance + 1);\n\n        int x = parentX + (int)(Math.cos(angle) * distance);\n        int z = parentZ + (int)(Math.sin(angle) * distance);\n        int y = parentY + random.nextInt(41) - 20; // ±20 varyasyon\n\n        return new int[]{x, y, z};\n    }\n\n    /**\n     * Asteroid için uygun biyom seçer\n     */\n    private BiomeType getRandomAsteroidBiome(Random random) {\n        // Asteroidler için daha sert biyomlar\n        BiomeType[] asteroidBiomes = {\n            BiomeType.CANYON,\n            BiomeType.BADLANDS,\n            BiomeType.ICE_SPIKES,\n            BiomeType.LAVA_OCEAN,\n            BiomeType.VOID\n        };\n\n        return asteroidBiomes[random.nextInt(asteroidBiomes.length)];\n    }\n\n    /**\n     * Asteroid bloklarını üretir (ore'lar dahil)\n     */\n    public List<OreGenerator.BlockData> generateAsteroidBlocks(Orb asteroid, BiomeType biome) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(asteroid.getSeed());\n\n        int cx = asteroid.getCenterX();\n        int cy = asteroid.getCenterY();\n        int cz = asteroid.getCenterZ();\n        int radius = asteroid.getRadius();\n\n        // Asteroid şekli için shape al\n        var shape = plugin.getShapeRegistry().getShape(asteroid.getShapeName());\n        if (shape == null) {\n            shape = plugin.getShapeRegistry().getShape(\"ASTEROID\");\n        }\n\n        // Ana bloklar\n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    if (shape.isBlockPart(x, y, z, radius, asteroid.getSeed())) {\n                        Material material = getAsteroidMaterial(biome, random);\n                        blocks.add(new OreGenerator.BlockData(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        // Asteroid ore'ları (düşük yoğunluk)\n        generateAsteroidOres(blocks, asteroid, biome, random);\n\n        return blocks;\n    }\n\n    /**\n     * Asteroid malzemesi seçer\n     */\n    private Material getAsteroidMaterial(BiomeType biome, Random random) {\n        // Biyom bazlı temel malzemeler\n        Material[] materials = switch (biome) {\n            case CANYON, BADLANDS -> new Material[]{Material.STONE, Material.COBBLESTONE, Material.GRAVEL};\n            case ICE_SPIKES -> new Material[]{Material.ICE, Material.PACKED_ICE, Material.BLUE_ICE};\n            case LAVA_OCEAN -> new Material[]{Material.NETHERRACK, Material.BASALT, Material.BLACKSTONE};\n            case VOID -> new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.PURPUR_BLOCK};\n            default -> new Material[]{Material.STONE, Material.ANDESITE, Material.DIORITE, Material.GRANITE};\n        };\n\n        return materials[random.nextInt(materials.length)];\n    }\n\n    /**\n     * Asteroid ore'ları üretir (düşük yoğunluk)\n     */\n    private void generateAsteroidOres(List<OreGenerator.BlockData> blocks, Orb asteroid, BiomeType biome, Random random) {\n        int cx = asteroid.getCenterX();\n        int cy = asteroid.getCenterY();\n        int cz = asteroid.getCenterZ();\n        int radius = asteroid.getRadius();\n\n        // Çok düşük ore yoğunluğu\n        int oreCount = radius * radius / 100; // Çok az ore\n\n        for (int i = 0; i < oreCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int y = cy + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Sadece asteroid içinde ise\n            double distance = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n            if (distance <= radius - 2) {\n                Material ore = getAsteroidOre(biome, random);\n                if (ore != null) {\n                    blocks.add(new OreGenerator.BlockData(x, y, z, ore));\n                }\n            }\n        }\n    }\n\n    /**\n     * Asteroid ore malzemesi seçer\n     */\n    private Material getAsteroidOre(BiomeType biome, Random random) {\n        // Asteroidlerde nadir bulunan malzemeler\n        Material[] ores = {Material.COAL_ORE, Material.IRON_ORE, Material.COPPER_ORE, Material.GOLD_ORE, Material.DIAMOND_ORE};\n        return ores[random.nextInt(ores.length)];\n    }\n}","size_bytes":7970}},"version":2}