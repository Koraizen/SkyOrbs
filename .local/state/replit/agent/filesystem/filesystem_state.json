{"file_contents":{"src/main/java/com/skyorbs/shapes/impl/SphereShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SphereShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        return dx * dx + dy * dy + dz * dz <= radius * radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"SPHERE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Küre\";\n    }\n}\n","size_bytes":548},"src/main/java/com/skyorbs/shapes/impl/StarShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.SkyOrbs;\n\npublic class StarShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Yıldız şekli - 5 kollu yıldız (CONFIG KONTROLLÜ)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // CONFIG'DEN ALGORİTMA AYARLARINI OKU\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        int points = plugin.getConfig().getInt(\"generation.shapes.algorithmTweaks.star.points\", 5);\n        double innerRadius = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.star.innerRadius\", 0.4);\n        double outerRadius = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.star.outerRadius\", 1.0);\n        double heightFactor = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.star.heightFactor\", 0.6);\n        boolean centerSolid = plugin.getConfig().getBoolean(\"generation.shapes.algorithmTweaks.star.centerSolid\", true);\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // 2D yıldız kontrolü (XZ düzleminde)\n        double angle = Math.atan2(z, x);\n        double starRadius = Math.sqrt(x * x + z * z);\n\n        // Yıldız formülü: r = a / (1 + b * sin(nθ))\n        double a = outerRadius;\n        double b = innerRadius;\n        double expectedRadius = a / (1 + b * Math.sin(points * angle));\n\n        // Y koordinatı için yükseklik kontrolü\n        double thickness = 0.3;\n\n        // Yıldız şekli kontrolü - config kontrollü\n        boolean inStar = starRadius <= expectedRadius && Math.abs(y) <= heightFactor;\n\n        // Yıldız merkezi için ekstra kontrol (config kontrollü)\n        boolean inCenter = false;\n        if (centerSolid) {\n            double centerRadius = Math.sqrt(x * x + y * y + z * z);\n            inCenter = centerRadius <= 0.4;\n        }\n\n        return inStar || inCenter;\n    }\n\n    @Override\n    public String getName() {\n        return \"STAR\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Yıldız\";\n    }\n}","size_bytes":2359},"src/main/java/com/skyorbs/shapes/impl/EllipsoidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\nimport java.util.Random;\n\npublic class EllipsoidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        Random rand = new Random(seed);\n        double rx = radius * (0.8 + 0.4 * rand.nextDouble());\n        double ry = radius * (0.8 + 0.4 * rand.nextDouble());\n        double rz = radius * (0.8 + 0.4 * rand.nextDouble());\n        \n        double val = (dx * dx) / (rx * rx) + (dy * dy) / (ry * ry) + (dz * dz) / (rz * rz);\n        return val <= 1.0;\n    }\n    \n    @Override\n    public String getName() {\n        return \"ELLIPSOID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Elips\";\n    }\n}\n","size_bytes":871},"src/main/java/com/skyorbs/shapes/impl/CrossShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CrossShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Haç şekli - 3D cross\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = Math.abs(dx) / (double)radius;\n        double y = Math.abs(dy) / (double)radius;\n        double z = Math.abs(dz) / (double)radius;\n\n        // Cross formülü - üç eksende geniş\n        double thickness = 0.3; // Haç kalınlığı\n        return (x <= thickness && y <= 1.0 && z <= 1.0) ||\n               (x <= 1.0 && y <= thickness && z <= 1.0) ||\n               (x <= 1.0 && y <= 1.0 && z <= thickness);\n    }\n\n    @Override\n    public String getName() {\n        return \"CROSS\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Haç\";\n    }\n}","size_bytes":1073},"src/main/java/com/skyorbs/shapes/impl/SpikyShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SpikyShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        double angle = Math.atan2(dz, dx);\n        double elevation = Math.atan2(dy, Math.sqrt(dx * dx + dz * dz));\n        \n        double spikePattern = Math.sin(angle * 6) * Math.cos(elevation * 4);\n        double spikeExtension = 1 + 0.3 * Math.max(0, spikePattern);\n        \n        return distance <= radius * spikeExtension;\n    }\n    \n    @Override\n    public String getName() {\n        return \"SPIKY\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.3;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Dikenli\";\n    }\n}\n","size_bytes":892},"src/main/java/com/skyorbs/shapes/impl/TrainShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TrainShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Tren şekli - locomotive, cars, wheels\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Train body (vagon gövdesi)\n        if (Math.abs(y) <= 0.2) {\n            return Math.abs(z) <= 0.4;\n        }\n\n        // Train roof (tavan)\n        if (y > 0.2 && y < 0.4) {\n            return Math.abs(z) <= 0.35;\n        }\n\n        // Wheels (tekerlekler)\n        double wheelRadius = 0.12;\n        if (y < -0.15) {\n            // Left wheels\n            if (Math.abs(z - 0.25) <= wheelRadius) return true;\n            // Right wheels\n            if (Math.abs(z + 0.25) <= wheelRadius) return true;\n        }\n\n        // Chimney (baca) - locomotive için\n        if (x > 0.2 && x < 0.4 && Math.abs(z) <= 0.08 && y > 0.4 && y < 0.6) {\n            return true;\n        }\n\n        // Coupler (bağlantı)\n        if (x < -0.4 && Math.abs(y) <= 0.1 && Math.abs(z) <= 0.05) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"TRAIN\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Tren\";\n    }\n}","size_bytes":1624},"src/main/java/com/skyorbs/shapes/impl/CloudShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CloudShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Bulut şekli - yumuşak, yuvarlak\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Cloud formülü - yumuşak yuvarlak\n        double cloudDensity = Math.exp(-(x*x + y*y + z*z)) +\n                             Math.exp(-((x-0.3)*(x-0.3) + (y+0.2)*(y+0.2) + z*z)) * 0.7 +\n                             Math.exp(-((x+0.3)*(x+0.3) + (y-0.2)*(y-0.2) + z*z)) * 0.7;\n\n        return cloudDensity > 0.3;\n    }\n\n    @Override\n    public String getName() {\n        return \"CLOUD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Bulut\";\n    }\n}","size_bytes":1100},"src/main/java/com/skyorbs/utils/NoiseGenerator.java":{"content":"package com.skyorbs.utils;\n\nimport java.util.Random;\n\npublic class NoiseGenerator {\n    \n    private static final int[] PERMUTATION = new int[512];\n    \n    static {\n        Random rand = new Random(0);\n        for (int i = 0; i < 256; i++) {\n            PERMUTATION[i] = i;\n        }\n        for (int i = 0; i < 256; i++) {\n            int j = rand.nextInt(256);\n            int temp = PERMUTATION[i];\n            PERMUTATION[i] = PERMUTATION[j];\n            PERMUTATION[j] = temp;\n        }\n        for (int i = 0; i < 256; i++) {\n            PERMUTATION[256 + i] = PERMUTATION[i];\n        }\n    }\n    \n    public static double getNoise(int x, int y, int z, long seed, double frequency) {\n        Random seedRand = new Random(seed);\n        int offsetX = seedRand.nextInt(10000);\n        int offsetY = seedRand.nextInt(10000);\n        int offsetZ = seedRand.nextInt(10000);\n\n        double nx = (x + offsetX) * frequency;\n        double ny = (y + offsetY) * frequency;\n        double nz = (z + offsetZ) * frequency;\n\n        return perlinNoise(nx, ny, nz);\n    }\n\n    /**\n     * Get 3D noise value for regional coherence in planet generation\n     * @param x X coordinate\n     * @param y Y coordinate\n     * @param z Z coordinate\n     * @param seed World seed\n     * @return Noise value between -1 and 1\n     */\n    public static double getNoise3D(double x, double y, double z, long seed) {\n        return getNoise((int)x, (int)y, (int)z, seed, 0.01);\n    }\n    \n    private static double perlinNoise(double x, double y, double z) {\n        int X = (int) Math.floor(x) & 255;\n        int Y = (int) Math.floor(y) & 255;\n        int Z = (int) Math.floor(z) & 255;\n        \n        x -= Math.floor(x);\n        y -= Math.floor(y);\n        z -= Math.floor(z);\n        \n        double u = fade(x);\n        double v = fade(y);\n        double w = fade(z);\n        \n        int A = PERMUTATION[X] + Y;\n        int AA = PERMUTATION[A] + Z;\n        int AB = PERMUTATION[A + 1] + Z;\n        int B = PERMUTATION[X + 1] + Y;\n        int BA = PERMUTATION[B] + Z;\n        int BB = PERMUTATION[B + 1] + Z;\n        \n        return lerp(w,\n            lerp(v,\n                lerp(u, grad(PERMUTATION[AA], x, y, z), grad(PERMUTATION[BA], x - 1, y, z)),\n                lerp(u, grad(PERMUTATION[AB], x, y - 1, z), grad(PERMUTATION[BB], x - 1, y - 1, z))\n            ),\n            lerp(v,\n                lerp(u, grad(PERMUTATION[AA + 1], x, y, z - 1), grad(PERMUTATION[BA + 1], x - 1, y, z - 1)),\n                lerp(u, grad(PERMUTATION[AB + 1], x, y - 1, z - 1), grad(PERMUTATION[BB + 1], x - 1, y - 1, z - 1))\n            )\n        );\n    }\n    \n    private static double fade(double t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n    \n    private static double lerp(double t, double a, double b) {\n        return a + t * (b - a);\n    }\n    \n    private static double grad(int hash, double x, double y, double z) {\n        int h = hash & 15;\n        double u = h < 8 ? x : y;\n        double v = h < 4 ? y : h == 12 || h == 14 ? x : z;\n        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n    }\n\n    /**\n     * Simplex noise 3D for ore vein generation\n     * Returns value between -1 and 1\n     */\n    public static double simplexNoise3D(double x, double y, double z) {\n        // Simple implementation using existing perlin noise\n        return perlinNoise(x, y, z);\n    }\n}\n","size_bytes":3389},"src/main/java/com/skyorbs/features/AsteroidGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class AsteroidGenerator {\n\n    private final SkyOrbs plugin;\n\n    public AsteroidGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Ana gezegen için asteroidler üretir\n     */\n    public List<Orb> generateAsteroidsForPlanet(Orb planet, World world) {\n        List<Orb> asteroids = new ArrayList<>();\n        Random random = new Random(planet.getSeed() + 999);\n\n        int minCount = plugin.getConfigManager().getMinAsteroidsPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxAsteroidsPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            Orb asteroid = createAsteroid(planet, world, random);\n            if (asteroid != null) {\n                asteroids.add(asteroid);\n            }\n        }\n\n        return asteroids;\n    }\n\n    /**\n     * Tek bir asteroid oluşturur\n     */\n    private Orb createAsteroid(Orb parentPlanet, World world, Random random) {\n        int minRadius = plugin.getConfigManager().getMinAsteroidRadius();\n        int maxRadius = plugin.getConfigManager().getMaxAsteroidRadius();\n\n        // Boyut dağılımı (küçük %60, orta %30, büyük %10)\n        double sizeRand = random.nextDouble();\n        int radius;\n        if (sizeRand < 0.6) {\n            radius = minRadius + random.nextInt(11); // 20-30\n        } else if (sizeRand < 0.9) {\n            radius = 30 + random.nextInt(11); // 30-40\n        } else {\n            radius = 40 + random.nextInt(11); // 40-50\n        }\n\n        // Şekil seçimi (Asteroid %70, Fractal %20, Spiky %10)\n        String shapeName;\n        double shapeRand = random.nextDouble();\n        if (shapeRand < 0.7) {\n            shapeName = \"ASTEROID\";\n        } else if (shapeRand < 0.9) {\n            shapeName = \"FRACTAL\";\n        } else {\n            shapeName = \"SPIKY\";\n        }\n\n        // Biyom seçimi (rastgele ama mantıklı)\n        BiomeType biome = getRandomAsteroidBiome(random);\n\n        // Pozisyon hesaplama\n        int[] position = calculateAsteroidPosition(parentPlanet, random);\n        int centerX = position[0];\n        int centerY = position[1];\n        int centerZ = position[2];\n\n        // İsim oluşturma\n        String name = \"Asteroid-\" + UUID.randomUUID().toString().substring(0, 6);\n\n        // Seed oluşturma\n        long seed = random.nextLong();\n\n        return new Orb(\n            UUID.randomUUID(),\n            name,\n            world.getName(),\n            centerX,\n            centerY,\n            centerZ,\n            radius,\n            shapeName,\n            biome.name(),\n            seed,\n            System.currentTimeMillis(),\n            true, // isAsteroid = true\n            parentPlanet.getId()\n        );\n    }\n\n    /**\n     * Asteroid pozisyonunu hesaplar\n     */\n    private int[] calculateAsteroidPosition(Orb parentPlanet, Random random) {\n        int parentX = parentPlanet.getCenterX();\n        int parentY = parentPlanet.getCenterY();\n        int parentZ = parentPlanet.getCenterZ();\n\n        int minDistance = plugin.getConfigManager().getMinAsteroidDistance();\n        int maxDistance = plugin.getConfigManager().getMaxAsteroidDistance();\n\n        // Rastgele açı ve mesafe\n        double angle = random.nextDouble() * 2 * Math.PI;\n        int distance = minDistance + random.nextInt(maxDistance - minDistance + 1);\n\n        int x = parentX + (int)(Math.cos(angle) * distance);\n        int z = parentZ + (int)(Math.sin(angle) * distance);\n        int y = parentY + random.nextInt(41) - 20; // ±20 varyasyon\n\n        return new int[]{x, y, z};\n    }\n\n    /**\n     * Asteroid için uygun biyom seçer\n     */\n    private BiomeType getRandomAsteroidBiome(Random random) {\n        // Asteroidler için daha sert biyomlar\n        BiomeType[] asteroidBiomes = {\n            BiomeType.CANYON,\n            BiomeType.BADLANDS,\n            BiomeType.ICE_SPIKES,\n            BiomeType.LAVA_OCEAN,\n            BiomeType.VOID\n        };\n\n        return asteroidBiomes[random.nextInt(asteroidBiomes.length)];\n    }\n\n    /**\n     * Asteroid bloklarını üretir (ore'lar dahil)\n     */\n    public List<OreGenerator.BlockData> generateAsteroidBlocks(Orb asteroid, BiomeType biome) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(asteroid.getSeed());\n\n        int cx = asteroid.getCenterX();\n        int cy = asteroid.getCenterY();\n        int cz = asteroid.getCenterZ();\n        int radius = asteroid.getRadius();\n\n        // Asteroid şekli için shape al\n        var shape = plugin.getShapeRegistry().getShape(asteroid.getShapeName());\n        if (shape == null) {\n            shape = plugin.getShapeRegistry().getShape(\"ASTEROID\");\n        }\n\n        // Ana bloklar\n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    if (shape.isBlockPart(x, y, z, radius, asteroid.getSeed())) {\n                        Material material = getAsteroidMaterial(biome, random);\n                        blocks.add(new OreGenerator.BlockData(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        // Asteroid ore'ları (düşük yoğunluk)\n        generateAsteroidOres(blocks, asteroid, biome, random);\n\n        return blocks;\n    }\n\n    /**\n     * Asteroid malzemesi seçer\n     */\n    private Material getAsteroidMaterial(BiomeType biome, Random random) {\n        // Biyom bazlı temel malzemeler\n        Material[] materials = switch (biome) {\n            case CANYON, BADLANDS -> new Material[]{Material.STONE, Material.COBBLESTONE, Material.GRAVEL};\n            case ICE_SPIKES -> new Material[]{Material.ICE, Material.PACKED_ICE, Material.BLUE_ICE};\n            case LAVA_OCEAN -> new Material[]{Material.NETHERRACK, Material.BASALT, Material.BLACKSTONE};\n            case VOID -> new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.PURPUR_BLOCK};\n            default -> new Material[]{Material.STONE, Material.ANDESITE, Material.DIORITE, Material.GRANITE};\n        };\n\n        return materials[random.nextInt(materials.length)];\n    }\n\n    /**\n     * Asteroid ore'ları üretir (düşük yoğunluk)\n     */\n    private void generateAsteroidOres(List<OreGenerator.BlockData> blocks, Orb asteroid, BiomeType biome, Random random) {\n        int cx = asteroid.getCenterX();\n        int cy = asteroid.getCenterY();\n        int cz = asteroid.getCenterZ();\n        int radius = asteroid.getRadius();\n\n        // Çok düşük ore yoğunluğu\n        int oreCount = radius * radius / 100; // Çok az ore\n\n        for (int i = 0; i < oreCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int y = cy + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Sadece asteroid içinde ise\n            double distance = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n            if (distance <= radius - 2) {\n                Material ore = getAsteroidOre(biome, random);\n                if (ore != null) {\n                    blocks.add(new OreGenerator.BlockData(x, y, z, ore));\n                }\n            }\n        }\n    }\n\n    /**\n     * Asteroid ore malzemesi seçer\n     */\n    private Material getAsteroidOre(BiomeType biome, Random random) {\n        // Asteroidlerde nadir bulunan malzemeler\n        Material[] ores = {Material.COAL_ORE, Material.IRON_ORE, Material.COPPER_ORE, Material.GOLD_ORE, Material.DIAMOND_ORE};\n        return ores[random.nextInt(ores.length)];\n    }\n}","size_bytes":7970},"src/main/java/com/skyorbs/core/PlanetType.java":{"content":"package com.skyorbs.core;\n\nimport org.bukkit.Material;\nimport org.bukkit.Color;\n\npublic enum PlanetType {\n\n    TERRESTRIAL(\"Karasal\", Material.GRASS_BLOCK, Color.GREEN, \"Dünya benzeri, yaşam dolu gezegen\"),\n    GAS(\"Gaz Devi\", Material.BLUE_WOOL, Color.BLUE, \"Gazdan oluşan dev gezegen\"),\n    LAVA(\"Lav\", Material.MAGMA_BLOCK, Color.ORANGE, \"Lav okyanusları ve volkanik aktivite\"),\n    ICE(\"Buz\", Material.PACKED_ICE, Color.AQUA, \"Donmuş yüzey ve buz fırtınaları\"),\n    CRYSTAL(\"Kristal\", Material.AMETHYST_BLOCK, Color.PURPLE, \"Kristal oluşumları ve mistik enerji\"),\n    SHADOW(\"Gölge\", Material.BLACK_CONCRETE, Color.BLACK, \"Karanlık ve mistik güçler\"),\n    TOXIC(\"Zehirli\", Material.SLIME_BLOCK, Color.LIME, \"Zehirli atmosfer ve tehlikeli flora\");\n\n    private final String displayName;\n    private final Material iconMaterial;\n    private final Color themeColor;\n    private final String description;\n\n    PlanetType(String displayName, Material iconMaterial, Color themeColor, String description) {\n        this.displayName = displayName;\n        this.iconMaterial = iconMaterial;\n        this.themeColor = themeColor;\n        this.description = description;\n    }\n\n    public String getDisplayName() {\n        return displayName;\n    }\n\n    public Material getIconMaterial() {\n        return iconMaterial;\n    }\n\n    public Color getThemeColor() {\n        return themeColor;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n\n    public double getEnergyMultiplier() {\n        return switch (this) {\n            case TERRESTRIAL -> 1.0;\n            case GAS -> 0.8;\n            case LAVA -> 1.2;\n            case ICE -> 0.9;\n            case CRYSTAL -> 1.5;\n            case SHADOW -> 1.3;\n            case TOXIC -> 1.1;\n        };\n    }\n\n    public int getMaxBiosphereLevel() {\n        return switch (this) {\n            case TERRESTRIAL -> 5;\n            case GAS -> 1;\n            case LAVA -> 2;\n            case ICE -> 3;\n            case CRYSTAL -> 4;\n            case SHADOW -> 3;\n            case TOXIC -> 4;\n        };\n    }\n\n    public boolean supportsLife() {\n        return this != GAS;\n    }\n\n    public boolean hasAtmosphere() {\n        return true; // All planets have atmosphere in this system\n    }\n}","size_bytes":2265},"src/main/java/com/skyorbs/generation/AsteroidGenerator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class AsteroidGenerator {\n\n    private final SkyOrbs plugin;\n\n    public AsteroidGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public List<Orb> generateAsteroidsForPlanet(Orb planet, World world) {\n        List<Orb> asteroids = new ArrayList<Orb>();\n\n        if (!plugin.getConfigManager().isAsteroidsEnabled()) {\n            return asteroids;\n        }\n\n        Random random = new Random(planet.getSeed() + 12345);\n\n        int minCount = plugin.getConfigManager().getMinAsteroidsPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxAsteroidsPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            int radius = plugin.getConfigManager().getMinAsteroidRadius() +\n                        random.nextInt(plugin.getConfigManager().getMaxAsteroidRadius() -\n                                     plugin.getConfigManager().getMinAsteroidRadius() + 1);\n\n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = plugin.getConfigManager().getMinAsteroidDistance() +\n                          random.nextInt(plugin.getConfigManager().getMaxAsteroidDistance() -\n                                       plugin.getConfigManager().getMinAsteroidDistance());\n\n            int x = planet.getCenterX() + (int)(Math.cos(angle) * distance);\n            int z = planet.getCenterZ() + (int)(Math.sin(angle) * distance);\n            int y = planet.getCenterY() + random.nextInt(41) - 20;\n\n            BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n\n            // Select asteroid shape and add visual effects\n            String shapeName = getAsteroidShapeForBiome(biome, random);\n\n            Orb asteroid = new Orb(\n                UUID.randomUUID(),\n                planet.getName() + \"_Asteroid_\" + (i + 1),\n                world.getName(),\n                x, y, z,\n                radius,\n                shapeName,\n                biome.name(),\n                planet.getSeed() + i + 1000,\n                System.currentTimeMillis(),\n                true,\n                planet.getId()\n            );\n\n            asteroids.add(asteroid);\n\n            // Add asteroid field effects (debris around asteroid)\n            if (random.nextDouble() < 0.3) { // 30% chance for asteroid field\n                generateAsteroidField(planet, world, x, y, z, radius, random);\n            }\n        }\n\n        return asteroids;\n    }\n\n    /**\n     * Generate asteroid field debris around asteroid\n     */\n    private void generateAsteroidField(Orb planet, World world, int ax, int ay, int az, int asteroidRadius, Random random) {\n        int debrisCount = 5 + random.nextInt(15); // 5-20 debris pieces\n\n        for (int i = 0; i < debrisCount; i++) {\n            // Generate debris within 50-100 blocks of asteroid\n            double angle = random.nextDouble() * 2 * Math.PI;\n            double distance = 50 + random.nextDouble() * 50;\n\n            int x = ax + (int)(Math.cos(angle) * distance);\n            int z = az + (int)(Math.sin(angle) * distance);\n            int y = ay + random.nextInt(21) - 10; // ±10 blocks\n\n            // Only place if not too close to planet\n            double planetDist = Math.sqrt((x - planet.getCenterX()) * (x - planet.getCenterX()) +\n                                        (y - planet.getCenterY()) * (y - planet.getCenterY()) +\n                                        (z - planet.getCenterZ()) * (z - planet.getCenterZ()));\n\n            if (planetDist > planet.getRadius() + 20) { // At least 20 blocks from planet surface\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                    Material debrisMaterial = getDebrisMaterial(random);\n                    block.setType(debrisMaterial, false);\n                }\n            }\n        }\n    }\n\n    /**\n     * Get appropriate asteroid shape for biome\n     */\n    private String getAsteroidShapeForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> random.nextBoolean() ? \"DIAMOND\" : \"OCTAHEDRON\";\n            case LAVA_OCEAN, MAGMA_CAVES -> \"SPHERE\"; // Smooth volcanic asteroids\n            case VOID -> \"CUBE\"; // Geometric void asteroids\n            case CORRUPTED -> \"SPIKY\"; // Spiky corrupted asteroids\n            case FROZEN_TUNDRA, GLACIER -> \"FRACTAL\"; // Irregular ice asteroids\n            default -> \"ASTEROID\"; // Default irregular shape\n        };\n    }\n\n    /**\n     * Get random debris material for asteroid fields\n     */\n    private Material getDebrisMaterial(Random random) {\n        Material[] debrisMaterials = {\n            Material.STONE, Material.COBBLESTONE, Material.ANDESITE, Material.DIORITE, Material.GRANITE,\n            Material.IRON_ORE, Material.COAL_ORE, Material.GOLD_ORE, Material.REDSTONE_ORE\n        };\n        return debrisMaterials[random.nextInt(debrisMaterials.length)];\n    }\n}\n","size_bytes":5352},"src/main/java/com/skyorbs/shapes/impl/CarShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CarShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Araba şekli - body, wheels, windows\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Car body (gövde)\n        if (Math.abs(y) <= 0.2) {\n            double bodyWidth = 0.6;\n            double bodyLength = 0.8;\n            return Math.abs(x) <= bodyLength && Math.abs(z) <= bodyWidth;\n        }\n\n        // Car roof (tavan)\n        if (y > 0.2 && y < 0.5) {\n            double roofWidth = 0.5;\n            double roofLength = 0.6;\n            return Math.abs(x) <= roofLength && Math.abs(z) <= roofWidth;\n        }\n\n        // Wheels (tekerlekler)\n        double wheelRadius = 0.15;\n        // Front wheels\n        if (x > 0.3 && x < 0.5) {\n            if ((Math.abs(z - 0.4) <= wheelRadius && Math.abs(y + 0.2) <= wheelRadius) ||\n                (Math.abs(z + 0.4) <= wheelRadius && Math.abs(y + 0.2) <= wheelRadius)) {\n                return true;\n            }\n        }\n        // Rear wheels\n        if (x < -0.3 && x > -0.5) {\n            if ((Math.abs(z - 0.4) <= wheelRadius && Math.abs(y + 0.2) <= wheelRadius) ||\n                (Math.abs(z + 0.4) <= wheelRadius && Math.abs(y + 0.2) <= wheelRadius)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"CAR\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Araba\";\n    }\n}","size_bytes":1890},"src/main/java/com/skyorbs/generation/PlanetSizeCalculator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\n\nimport java.util.Random;\n\npublic class PlanetSizeCalculator {\n    \n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n    \n    public PlanetSizeCalculator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    public int calculateRadius(String sizeCategory) {\n        // CONFIG'DEN OKU - Tamamen config kontrollü\n        boolean sizeEnabled = plugin.getConfig().getBoolean(\"generation.planetSize.enabled\", true);\n        if (!sizeEnabled) {\n            // Eski sistem fallback\n            int minRadius = plugin.getConfigManager().getMinRadius();\n            int maxRadius = plugin.getConfigManager().getMaxRadius();\n            int worldMaxHeight = 320;\n            int safeMaxRadius = Math.min(maxRadius, worldMaxHeight / 2 - 20);\n            return switch (sizeCategory.toUpperCase()) {\n                case \"SMALL\" -> Math.min(minRadius + random.nextInt(40), safeMaxRadius);\n                case \"MEDIUM\" -> Math.min(120 + random.nextInt(60), safeMaxRadius);\n                case \"LARGE\" -> Math.min(180 + random.nextInt(70), safeMaxRadius);\n                default -> Math.min(120 + random.nextInt(60), safeMaxRadius);\n            };\n        }\n\n        // YENİ CONFIG TABANLI SİSTEM\n        int minRadius = plugin.getConfig().getInt(\"generation.planetSize.minRadius\", 5);\n        int maxRadius = plugin.getConfig().getInt(\"generation.planetSize.maxRadius\", 250);\n        int worldHeightLimit = plugin.getConfig().getInt(\"generation.planetSize.worldHeightLimit\", 320);\n        int safeBuffer = plugin.getConfig().getInt(\"generation.planetSize.safeBuffer\", 20);\n        int safeMaxRadius = Math.min(maxRadius, worldHeightLimit / 2 - safeBuffer);\n\n        return switch (sizeCategory.toUpperCase()) {\n            case \"SMALL\" -> {\n                int tinyMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.tiny.min\", 5);\n                int tinyMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.tiny.max\", 15);\n                yield Math.min(tinyMin + random.nextInt(tinyMax - tinyMin + 1), safeMaxRadius);\n            }\n            case \"MEDIUM\" -> {\n                int mediumMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.medium.min\", 50);\n                int mediumMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.medium.max\", 120);\n                yield Math.min(mediumMin + random.nextInt(mediumMax - mediumMin + 1), safeMaxRadius);\n            }\n            case \"LARGE\" -> {\n                int largeMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.large.min\", 120);\n                int largeMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.large.max\", 200);\n                yield Math.min(largeMin + random.nextInt(largeMax - largeMin + 1), safeMaxRadius);\n            }\n            default -> {\n                // TAMAMEN RASTGELE BOYUTLAR - Config kontrollü dağılım\n                double rand = random.nextDouble();\n\n                double tinyProb = plugin.getConfig().getDouble(\"generation.planetSize.sizeDistribution.tiny\", 0.05);\n                double smallProb = plugin.getConfig().getDouble(\"generation.planetSize.sizeDistribution.small\", 0.10);\n                double mediumProb = plugin.getConfig().getDouble(\"generation.planetSize.sizeDistribution.medium\", 0.20);\n                double largeProb = plugin.getConfig().getDouble(\"generation.planetSize.sizeDistribution.large\", 0.30);\n\n                if (rand < tinyProb) {\n                    // Çok küçük gezegenler\n                    int tinyMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.tiny.min\", 5);\n                    int tinyMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.tiny.max\", 15);\n                    yield Math.max(minRadius, tinyMin + random.nextInt(tinyMax - tinyMin + 1));\n                } else if (rand < tinyProb + smallProb) {\n                    // Küçük gezegenler\n                    int smallMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.small.min\", 15);\n                    int smallMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.small.max\", 50);\n                    yield Math.min(smallMin + random.nextInt(smallMax - smallMin + 1), safeMaxRadius);\n                } else if (rand < tinyProb + smallProb + mediumProb) {\n                    // Orta gezegenler\n                    int mediumMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.medium.min\", 50);\n                    int mediumMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.medium.max\", 120);\n                    yield Math.min(mediumMin + random.nextInt(mediumMax - mediumMin + 1), safeMaxRadius);\n                } else if (rand < tinyProb + smallProb + mediumProb + largeProb) {\n                    // Büyük gezegenler\n                    int largeMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.large.min\", 120);\n                    int largeMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.large.max\", 200);\n                    yield Math.min(largeMin + random.nextInt(largeMax - largeMin + 1), safeMaxRadius);\n                } else {\n                    // Çok büyük gezegenler\n                    int hugeMin = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.huge.min\", 200);\n                    int hugeMax = plugin.getConfig().getInt(\"generation.planetSize.sizeRanges.huge.max\", 250);\n                    yield Math.min(hugeMin + random.nextInt(hugeMax - hugeMin + 1), safeMaxRadius);\n                }\n            }\n        };\n    }\n    \n    public long estimateBlockCount(int radius) {\n        int shellThickness = 7;\n        double outerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius, 3);\n        double innerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius - shellThickness, 3);\n        return (long)((outerVolume - innerVolume) * 1.1);\n    }\n    \n    public boolean validateSize(int radius) {\n        int minRadius = plugin.getConfigManager().getMinRadius();\n        int maxRadius = plugin.getConfigManager().getMaxRadius();\n        return radius >= minRadius && radius <= maxRadius;\n    }\n}\n","size_bytes":6254},"src/main/java/com/skyorbs/shapes/impl/SnowboardShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SnowboardShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Snowboard şekli - board, bindings, edges\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main board (ana tahta)\n        if (Math.abs(y) <= 0.02) {\n            // Tapered shape - wider in middle\n            double width = 0.2 + (0.3 - Math.abs(x) * 0.6);\n            return Math.abs(z) <= width && Math.abs(x) <= 0.8;\n        }\n\n        // Board edges (kenarlar) - slightly raised\n        if (Math.abs(y) <= 0.04) {\n            double width = 0.2 + (0.3 - Math.abs(x) * 0.6);\n            return Math.abs(z) <= width && Math.abs(x) <= 0.8;\n        }\n\n        // Nose and tail (burun ve kuyruk) - upturned\n        if (Math.abs(x) > 0.6) {\n            double tipAngle = (Math.abs(x) - 0.6) * 0.5;\n            if (y > tipAngle - 0.02 && y < tipAngle + 0.02) {\n                return Math.abs(z) <= 0.15;\n            }\n        }\n\n        // Bindings (bağlamalar)\n        double bindingWidth = 0.08;\n        double bindingLength = 0.06;\n        // Front binding\n        if (x > 0.2 && x < 0.32 && Math.abs(y - 0.05) <= 0.03) {\n            return Math.abs(z) <= bindingWidth;\n        }\n        // Rear binding\n        if (x < -0.2 && x > -0.32 && Math.abs(y - 0.05) <= 0.03) {\n            return Math.abs(z) <= bindingWidth;\n        }\n\n        // Binding straps (bağlama kayışları)\n        if (Math.abs(y - 0.08) <= 0.02) {\n            if (Math.abs(x - 0.26) <= bindingLength && Math.abs(z) <= 0.12) return true;\n            if (Math.abs(x + 0.26) <= bindingLength && Math.abs(z) <= 0.12) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SNOWBOARD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kar Tahtası\";\n    }\n}","size_bytes":2254},"src/main/java/com/skyorbs/shapes/impl/PlaneShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class PlaneShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Uçak şekli - fuselage, wings, tail, engines\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Fuselage (gövde)\n        if (Math.abs(y) <= 0.1 && Math.abs(z) <= 0.08) {\n            return Math.abs(x) <= 0.7;\n        }\n\n        // Wings (kanatlar)\n        if (Math.abs(z) > 0.08 && Math.abs(z) < 0.4 && Math.abs(y) <= 0.05) {\n            double wingLength = 0.6;\n            return Math.abs(x) <= wingLength;\n        }\n\n        // Tail (kuyruk)\n        if (x < -0.5) {\n            // Vertical stabilizer\n            if (Math.abs(z) <= 0.05 && y > 0.1 && y < 0.3) {\n                return true;\n            }\n            // Horizontal stabilizer\n            if (Math.abs(y) <= 0.05 && Math.abs(z) <= 0.2) {\n                return true;\n            }\n        }\n\n        // Engines (motorlar)\n        double engineRadius = 0.08;\n        // Under wings\n        if (Math.abs(z - 0.25) <= engineRadius && Math.abs(y + 0.08) <= engineRadius && Math.abs(x) <= 0.4) {\n            return true;\n        }\n        if (Math.abs(z + 0.25) <= engineRadius && Math.abs(y + 0.08) <= engineRadius && Math.abs(x) <= 0.4) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"PLANE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Uçak\";\n    }\n}","size_bytes":1867},"src/main/java/com/skyorbs/shapes/impl/KiteShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class KiteShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Uçurtma şekli - diamond shape with tail\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Diamond kite shape\n        double absX = Math.abs(x);\n        double absZ = Math.abs(z);\n\n        // Top triangle\n        if (y > 0) {\n            double topWidth = 0.4 - y * 0.8;\n            if (absX <= topWidth && absZ <= topWidth) return true;\n        }\n\n        // Bottom triangle\n        if (y <= 0) {\n            double bottomWidth = 0.4 + y * 0.8;\n            if (absX <= bottomWidth && absZ <= bottomWidth) return true;\n        }\n\n        // Tail (kuyruk)\n        if (y < -0.3) {\n            double tailWidth = 0.05;\n            double tailLength = (-y - 0.3) * 0.5;\n            if (absZ <= tailWidth && absX <= tailLength) return true;\n        }\n\n        // Cross spars (çapraz çubuklar)\n        if (Math.abs(y) <= 0.02) {\n            if (absX <= 0.4 && absZ <= 0.02) return true;\n            if (absZ <= 0.4 && absX <= 0.02) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"KITE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Uçurtma\";\n    }\n}","size_bytes":1680},"src/main/java/com/skyorbs/core/PlanetEvolution.java":{"content":"package com.skyorbs.core;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class PlanetEvolution {\n\n    private final Orb orb;\n\n    public PlanetEvolution(Orb orb) {\n        this.orb = orb;\n    }\n\n    public void evolve() {\n        if (!orb.canUpgrade()) {\n            return;\n        }\n\n        int oldLevel = orb.getCoreLevel();\n        orb.setCoreLevel(oldLevel + 1);\n\n        // Apply evolution effects\n        applyEvolutionEffects(oldLevel, orb.getCoreLevel());\n\n        // Reset XP for next level\n        orb.addXp(-orb.getXpForNextLevel());\n    }\n\n    private void applyEvolutionEffects(int oldLevel, int newLevel) {\n        // Size increase\n        if (newLevel >= 3) {\n            // Planet grows larger\n        }\n\n        // New features unlock\n        if (newLevel >= 2) {\n            // Unlock atmosphere effects\n        }\n\n        if (newLevel >= 4) {\n            // Unlock advanced biomes\n        }\n\n        if (newLevel >= 6) {\n            // Unlock special events\n        }\n\n        if (newLevel >= 8) {\n            // Unlock legendary features\n        }\n\n        if (newLevel >= 10) {\n            // Maximum evolution - special title\n        }\n    }\n\n    public Map<String, Object> getEvolutionRequirements() {\n        Map<String, Object> requirements = new HashMap<>();\n        requirements.put(\"currentLevel\", orb.getCoreLevel());\n        requirements.put(\"currentXp\", orb.getXp());\n        requirements.put(\"xpForNextLevel\", orb.getXpForNextLevel());\n        requirements.put(\"canUpgrade\", orb.canUpgrade());\n        requirements.put(\"progressPercent\", (double) orb.getXp() / orb.getXpForNextLevel() * 100);\n        return requirements;\n    }\n\n    public String getEvolutionDescription() {\n        int level = orb.getCoreLevel();\n        return switch (level) {\n            case 1 -> \"Temel çekirdek - yaşamın başlangıcı\";\n            case 2 -> \"Gelişen çekirdek - atmosfer oluşuyor\";\n            case 3 -> \"Olgun çekirdek - biyom çeşitliliği\";\n            case 4 -> \"Güçlü çekirdek - özel yetenekler\";\n            case 5 -> \"İleri çekirdek - ekolojik denge\";\n            case 6 -> \"Gelişmiş çekirdek - olay sistemi\";\n            case 7 -> \"Üstün çekirdek - nadir kaynaklar\";\n            case 8 -> \"Efsanevi çekirdek - mistik güçler\";\n            case 9 -> \"Ultimate çekirdek - maksimum potansiyel\";\n            case 10 -> \"Kozmik çekirdek - evrenin gücü\";\n            default -> \"Bilinmeyen evrim seviyesi\";\n        };\n    }\n\n    public void gainXpFromActivity(String activity, int baseXp) {\n        double multiplier = getXpMultiplier();\n        int finalXp = (int) (baseXp * multiplier);\n        orb.addXp(finalXp);\n    }\n\n    private double getXpMultiplier() {\n        double multiplier = 1.0;\n\n        // Planet type bonus\n        multiplier *= orb.getPlanetType().getEnergyMultiplier();\n\n        // Biosphere level bonus\n        multiplier *= (1.0 + (orb.getBiosphereLevel() - 1) * 0.1);\n\n        // Ecological balance bonus\n        if (orb.getEcologicalBalance() > 1.0) {\n            multiplier *= 1.2;\n        } else if (orb.getEcologicalBalance() < 0.8) {\n            multiplier *= 0.8;\n        }\n\n        return multiplier;\n    }\n}","size_bytes":3203},"src/main/java/com/skyorbs/shapes/impl/HotAirBalloonShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HotAirBalloonShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Sıcak hava balonu şekli - envelope, basket, burner\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Balloon envelope (balon kabı) - teardrop shape\n        if (y > 0.1) {\n            double envelopeRadius = Math.sqrt(1 - Math.pow((y - 0.55) / 0.45, 2)) * 0.4;\n            double radialDistance = Math.sqrt(x*x + z*z);\n            if (radialDistance <= envelopeRadius) return true;\n        }\n\n        // Envelope neck (boyun)\n        if (y <= 0.1 && y >= -0.1) {\n            double neckRadius = 0.15;\n            return Math.sqrt(x*x + z*z) <= neckRadius;\n        }\n\n        // Basket (sepet)\n        if (y <= -0.1 && y >= -0.4) {\n            return Math.abs(x) <= 0.2 && Math.abs(z) <= 0.2;\n        }\n\n        // Burner (brülör)\n        if (y >= -0.05 && y <= 0.05 && Math.abs(x) <= 0.08) {\n            return Math.abs(z) <= 0.03;\n        }\n\n        // Suspension lines (asma halatları)\n        if (y <= 0.1 && y >= -0.1) {\n            double lineSpacing = 0.06;\n            for (int i = -2; i <= 2; i++) {\n                for (int j = -2; j <= 2; j++) {\n                    double lineX = i * lineSpacing;\n                    double lineZ = j * lineSpacing;\n                    if (Math.abs(x - lineX) <= 0.01 && Math.abs(z - lineZ) <= 0.01) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"HOT_AIR_BALLOON\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Sıcak Hava Balonu\";\n    }\n}","size_bytes":2110},"src/main/java/com/skyorbs/shapes/impl/SkateboardShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SkateboardShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Skateboard şekli - deck, wheels, trucks\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main deck (ana tabla)\n        if (Math.abs(y) <= 0.03) {\n            return Math.abs(x) <= 0.6 && Math.abs(z) <= 0.15;\n        }\n\n        // Deck taper (kenar eğimi)\n        if (Math.abs(y) <= 0.05) {\n            double taper = 1.0 - Math.abs(x) * 0.3;\n            return Math.abs(z) <= 0.15 * taper && Math.abs(x) <= 0.6;\n        }\n\n        // Trucks (kamyonlar)\n        double truckWidth = 0.08;\n        double truckLength = 0.12;\n        // Front truck\n        if (x > 0.3 && x < 0.42 && Math.abs(y + 0.06) <= 0.04) {\n            return Math.abs(z) <= truckWidth;\n        }\n        // Rear truck\n        if (x < -0.3 && x > -0.42 && Math.abs(y + 0.06) <= 0.04) {\n            return Math.abs(z) <= truckWidth;\n        }\n\n        // Wheels (tekerlekler)\n        double wheelRadius = 0.04;\n        // Front wheels\n        if (x > 0.35 && x < 0.4) {\n            if (Math.abs(z - 0.1) <= wheelRadius && Math.abs(y + 0.08) <= wheelRadius) return true;\n            if (Math.abs(z + 0.1) <= wheelRadius && Math.abs(y + 0.08) <= wheelRadius) return true;\n        }\n        // Rear wheels\n        if (x < -0.35 && x > -0.4) {\n            if (Math.abs(z - 0.1) <= wheelRadius && Math.abs(y + 0.08) <= wheelRadius) return true;\n            if (Math.abs(z + 0.1) <= wheelRadius && Math.abs(y + 0.08) <= wheelRadius) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SKATEBOARD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kaykay\";\n    }\n}","size_bytes":2159},"src/main/java/com/skyorbs/SkyOrbs.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.commands.GezegenCommand;\nimport com.skyorbs.config.ConfigManager;\nimport com.skyorbs.generation.GenerationManager;\nimport com.skyorbs.shapes.ShapeRegistry;\nimport com.skyorbs.storage.DatabaseManager;\nimport com.skyorbs.storage.PlanetDataManager;\nimport com.skyorbs.dungeons.DungeonGenerator;\nimport com.skyorbs.palettes.PaletteRegistry;\nimport com.skyorbs.atmosphere.PlanetAtmosphereManager;\nimport org.bukkit.Bukkit;\nimport org.bukkit.plugin.java.JavaPlugin;\n\nimport java.util.Map;\nimport java.util.logging.Level;\nimport com.skyorbs.ecosystem.BiosphereManager;\nimport com.skyorbs.events.CelestialEvents;\nimport com.skyorbs.listeners.PlanetEventListener;\n\npublic class SkyOrbs extends JavaPlugin {\n    \n    private static SkyOrbs instance;\n    private ConfigManager configManager;\n    private DatabaseManager databaseManager;\n    private PlanetDataManager planetDataManager;\n    private GenerationManager generationManager;\n    private ShapeRegistry shapeRegistry;\n    private DungeonGenerator dungeonGenerator;\n    private PaletteRegistry paletteRegistry;\n    private PlanetAtmosphereManager atmosphereManager;\n    private com.skyorbs.gui.AdminConfigGUI adminConfigGUI;\n\n    // NEW: Missing managers\n    private BiosphereManager biosphereManager;\n    private CelestialEvents celestialEvents;\n    private PlanetEventListener planetEventListener;\n\n    // Performans metrikleri\n    private long startupTime;\n    private int totalPlanetsGenerated = 0;\n    \n    @Override\n    public void onEnable() {\n        startupTime = System.currentTimeMillis();\n        instance = this;\n        \n        logInfo(\"========================================\");\n        logInfo(\"SkyOrbs 2.0.0 aktifleştiriliyor...\");\n        logInfo(\"Türkçe Minecraft gezegen oluşturma eklentisi\");\n        logInfo(\"========================================\");\n        \n        // Config oluştur ve yedek varsa geri yükle\n        saveDefaultConfig();\n\n        // Config yedek kontrolü\n        checkAndRestoreConfigBackup();\n\n        try {\n            // 1. Config Manager\n            configManager = new ConfigManager(this);\n            configManager.validateConfig(); // Config doğrulama\n            logSuccess(\"✓ Konfigürasyon yüklendi ve doğrulandı\");\n\n            // 2. Database\n            databaseManager = new DatabaseManager(this);\n            databaseManager.initialize();\n            logSuccess(\"✓ Veritabanı bağlantısı kuruldu\");\n\n            // 2.5. Planet Data Manager\n            planetDataManager = new PlanetDataManager(this);\n            logSuccess(\"✓ Gezegen data yönetim sistemi hazır\");\n\n            // 3. Shape Registry\n            shapeRegistry = new ShapeRegistry();\n            shapeRegistry.registerAllShapes();\n            logSuccess(\"✓ \" + shapeRegistry.getShapeCount() + \" gezegen şekli kaydedildi\");\n\n            // SHAPE CONFIGURATION DEBUG\n            logInfo(\"========================================\");\n            logInfo(\"SHAPE CONFIGURATION:\");\n            logInfo(\"========================================\");\n\n            Map<String, Double> weights = configManager.getShapeWeights();\n            if (weights.isEmpty()) {\n                logWarning(\"⚠ NO SHAPE WEIGHTS LOADED!\");\n            } else {\n                logSuccess(\"✓ Loaded \" + weights.size() + \" shape weights:\");\n                weights.entrySet().stream()\n                    .sorted(Map.Entry.<String, Double>comparingByValue().reversed())\n                    .forEach(entry ->\n                        logInfo(\"  • \" + entry.getKey() + \" = \" + entry.getValue())\n                    );\n            }\n\n            logInfo(\"========================================\");\n            \n            // 3.5. Palette Registry (20+ palettes for diversity)\n            paletteRegistry = new PaletteRegistry();\n            logSuccess(\"✓ \" + paletteRegistry.getPaletteCount() + \" gezegen paleti kaydedildi\");\n            \n            // 3.6. Atmosphere Manager\n            atmosphereManager = new PlanetAtmosphereManager(this);\n            atmosphereManager.start();\n            logSuccess(\"✓ Atmosfer efekt sistemi başlatıldı\");\n\n            // 3.7. Admin Config GUI\n            adminConfigGUI = new com.skyorbs.gui.AdminConfigGUI(this);\n            logSuccess(\"✓ Admin konfigürasyon GUI'si hazır\");\n            \n            // 4. Generation Manager\n            generationManager = new GenerationManager(this);\n            logSuccess(\"✓ Gezegen üretim sistemi hazır\");\n\n            // 4.5. Dungeon Generator\n            dungeonGenerator = new DungeonGenerator(this);\n            logSuccess(\"✓ Zindan üretim sistemi hazır\");\n\n            // NEW: Initialize Biosphere Manager\n            biosphereManager = new BiosphereManager(this);\n            logSuccess(\"✓ Biyosfer yönetim sistemi başlatıldı\");\n\n            // NEW: Initialize Celestial Events\n            celestialEvents = new CelestialEvents(this);\n            logSuccess(\"✓ Gök olayları sistemi başlatıldı\");\n\n            // Register event listeners\n            planetEventListener = new PlanetEventListener(this);\n            getServer().getPluginManager().registerEvents(planetEventListener, this);\n            getServer().getPluginManager().registerEvents(new com.skyorbs.listeners.GUIClickListener(this), this);\n            logSuccess(\"✓ Event listeners registered\");\n\n            // 5. Commands\n            registerCommands();\n            logSuccess(\"✓ Komutlar kaydedildi\");\n            \n            // 6. Özellik kontrolü\n            logFeatureStatus();\n            \n            // 7. Entegrasyon kontrolü\n            checkIntegrations();\n            \n            // 8. Performans monitörü\n            if (configManager.isPerformanceMonitorEnabled()) {\n                startPerformanceMonitor();\n            }\n            \n            // 9. Auto-save sistemi\n            if (configManager.isAutoSaveEnabled()) {\n                startAutoSave();\n            }\n            \n            long loadTime = System.currentTimeMillis() - startupTime;\n            \n            // Calculate total combinations\n            int totalCombinations = shapeRegistry.getShapeCount() * paletteRegistry.getPaletteCount() * 8; // 8 atmospheres\n            \n            logSuccess(\"========================================\");\n            logSuccess(\"SkyOrbs başarıyla aktifleştirildi!\");\n            logSuccess(\"17 şekil × 20 palet × 8 atmosfer = \" + totalCombinations + \"+ gezegen kombinasyonu!\");\n            logSuccess(\"Modifiyerler ile 10,000+ farklı gezegen çeşidi mümkün!\");\n            logSuccess(\"Yükleme süresi: \" + loadTime + \"ms\");\n            logSuccess(\"========================================\");\n            \n        } catch (Exception e) {\n            logError(\"Eklenti başlatılırken hata oluştu!\", e);\n            getServer().getPluginManager().disablePlugin(this);\n        }\n    }\n    \n    @Override\n    public void onDisable() {\n        logInfo(\"========================================\");\n        logInfo(\"SkyOrbs devre dışı bırakılıyor...\");\n        \n        if (atmosphereManager != null) {\n            atmosphereManager.stop();\n            logSuccess(\"✓ Atmosfer sistemi durduruldu\");\n        }\n        \n        if (generationManager != null) {\n            generationManager.shutdown();\n            logSuccess(\"✓ Üretim görevleri sonlandırıldı\");\n        }\n        \n        if (databaseManager != null) {\n            databaseManager.close();\n            logSuccess(\"✓ Veritabanı bağlantısı kapatıldı\");\n        }\n\n        // Stop celestial events\n        if (celestialEvents != null) {\n            // No explicit stop needed - BukkitRunnable will cancel\n            logSuccess(\"✓ Gök olayları sistemi durduruldu\");\n        }\n\n        // Biosphere manager doesn't need explicit stop\n\n        // İstatistikler\n        logInfo(\"Toplam oluşturulan gezegen: \" + totalPlanetsGenerated);\n        \n        logInfo(\"SkyOrbs devre dışı bırakıldı.\");\n        logInfo(\"========================================\");\n    }\n    \n    /**\n     * Komutları kaydet\n     */\n    private void registerCommands() {\n        GezegenCommand commandExecutor = new GezegenCommand(this);\n        getCommand(\"gezegen\").setExecutor(commandExecutor);\n        getCommand(\"gezegen\").setTabCompleter(commandExecutor);\n    }\n    \n    /**\n     * Özellik durumlarını logla\n     */\n    private void logFeatureStatus() {\n        logInfo(\"Özellik Durumu:\");\n        logInfo(\"  • Ore Sistemi: \" + (configManager.isOreGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Ağaç Sistemi: \" + (configManager.isTreeGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Yapı Sistemi: \" + (configManager.isStructureGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Hazine Sistemi: \" + (configManager.isTreasureGenerationEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Asteroid Sistemi: \" + (configManager.isAsteroidsEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n        logInfo(\"  • Uydu Sistemi: \" + (configManager.isSatellitesEnabled() ? \"§aAktif\" : \"§cKapalı\"));\n    }\n    \n    /**\n     * Entegrasyonları kontrol et\n     */\n    private void checkIntegrations() {\n        boolean hasIntegration = false;\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"Vault\") && configManager.isVaultEnabled()) {\n            logSuccess(\"✓ Vault entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"WorldGuard\") && configManager.isWorldGuardEnabled()) {\n            logSuccess(\"✓ WorldGuard entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"PlaceholderAPI\") && configManager.isPlaceholderAPIEnabled()) {\n            logSuccess(\"✓ PlaceholderAPI entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (Bukkit.getPluginManager().isPluginEnabled(\"dynmap\") && configManager.isDynmapEnabled()) {\n            logSuccess(\"✓ Dynmap entegrasyonu aktif\");\n            hasIntegration = true;\n        }\n        \n        if (!hasIntegration) {\n            logInfo(\"Entegrasyon: Yok (opsiyonel)\");\n        }\n    }\n    \n    /**\n     * Performans monitörünü başlat\n     */\n    private void startPerformanceMonitor() {\n        int interval = configManager.getPerformanceLogInterval();\n        \n        Bukkit.getScheduler().runTaskTimerAsynchronously(this, () -> {\n            Runtime runtime = Runtime.getRuntime();\n            long usedMemory = (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024;\n            long maxMemory = runtime.maxMemory() / 1024 / 1024;\n            \n            double tps = Bukkit.getTPS()[0]; // 1 dakikalık TPS\n            \n            configManager.sendDebugMessage(\"performance\", \n                String.format(\"TPS: %.2f | RAM: %dMB/%dMB | Gezegenler: %d\", \n                    tps, usedMemory, maxMemory, totalPlanetsGenerated));\n            \n        }, interval, interval);\n        \n        logInfo(\"✓ Performans monitörü başlatıldı\");\n    }\n    \n    /**\n     * Auto-save sistemini başlat\n     */\n    private void startAutoSave() {\n        int interval = configManager.getAutoSaveInterval() * 20; // Saniye to tick\n        \n        Bukkit.getScheduler().runTaskTimer(this, () -> {\n            try {\n                // Database'i kaydet (eğer varsa değişiklikler)\n                logInfo(\"Auto-save: Veri kaydediliyor...\");\n                // DatabaseManager zaten her işlemde kaydediyor, ek bir şey gerekmiyor\n                logInfo(\"Auto-save: Tamamlandı\");\n            } catch (Exception e) {\n                logError(\"Auto-save hatası!\", e);\n            }\n        }, interval, interval);\n        \n        logInfo(\"✓ Auto-save sistemi başlatıldı (Her \" + configManager.getAutoSaveInterval() + \" saniye)\");\n    }\n    \n    /**\n     * Config'i yeniden yükle ve yedekle\n     */\n    public void reloadPluginConfig() {\n        try {\n            // 1. Mevcut config'i yedekle\n            backupCurrentConfig();\n\n            // 2. Config dosyasını yeniden yükle\n            reloadConfig();\n\n            // 3. ConfigManager'ı yeniden oluştur\n            configManager = new ConfigManager(this);\n\n            // 4. Validate et\n            configManager.validateConfig();\n\n            logSuccess(\"========================================\");\n            logSuccess(\"CONFIG RELOADED SUCCESSFULLY!\");\n            logSuccess(\"Previous config backed up to config.backup.yml\");\n            logSuccess(\"========================================\");\n\n        } catch (Exception e) {\n            logError(\"Failed to reload config!\", e);\n        }\n    }\n\n    /**\n     * Mevcut config'i yedekle\n     */\n    private void backupCurrentConfig() {\n        try {\n            java.io.File configFile = new java.io.File(getDataFolder(), \"config.yml\");\n            java.io.File backupFile = new java.io.File(getDataFolder(), \"config.backup.yml\");\n\n            if (configFile.exists()) {\n                java.nio.file.Files.copy(configFile.toPath(), backupFile.toPath(),\n                    java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n                logInfo(\"✓ Config backed up to config.backup.yml\");\n            }\n        } catch (Exception e) {\n            logWarning(\"Failed to backup config: \" + e.getMessage());\n        }\n    }\n\n    /**\n     * Config yedek kontrolü ve geri yükleme\n     */\n    private void checkAndRestoreConfigBackup() {\n        try {\n            java.io.File configFile = new java.io.File(getDataFolder(), \"config.yml\");\n            java.io.File backupFile = new java.io.File(getDataFolder(), \"config.backup.yml\");\n\n            // Eğer config dosyası yoksa ve yedek varsa, yedeği geri yükle\n            if (!configFile.exists() && backupFile.exists()) {\n                java.nio.file.Files.copy(backupFile.toPath(), configFile.toPath());\n                logSuccess(\"✓ Config restored from backup!\");\n            } else if (backupFile.exists()) {\n                logInfo(\"✓ Config backup available at config.backup.yml\");\n            }\n        } catch (Exception e) {\n            logWarning(\"Failed to check/restore config backup: \" + e.getMessage());\n        }\n    }\n    \n    /**\n     * Gezegen sayacını artır\n     */\n    public void incrementPlanetCount() {\n        totalPlanetsGenerated++;\n    }\n    \n    // ============================================\n    // GETTER METODLARI\n    // ============================================\n    \n    public static SkyOrbs getInstance() {\n        return instance;\n    }\n    \n    public ConfigManager getConfigManager() {\n        return configManager;\n    }\n    \n    public DatabaseManager getDatabaseManager() {\n        return databaseManager;\n    }\n\n    public PlanetDataManager getPlanetDataManager() {\n        return planetDataManager;\n    }\n    \n    public GenerationManager getGenerationManager() {\n        return generationManager;\n    }\n    \n    public ShapeRegistry getShapeRegistry() {\n        return shapeRegistry;\n    }\n\n    public DungeonGenerator getDungeonGenerator() {\n        return dungeonGenerator;\n    }\n    \n    public PaletteRegistry getPaletteRegistry() {\n        return paletteRegistry;\n    }\n    \n    public PlanetAtmosphereManager getAtmosphereManager() {\n        return atmosphereManager;\n    }\n\n    public com.skyorbs.gui.AdminConfigGUI getAdminConfigGUI() {\n        return adminConfigGUI;\n    }\n    \n    public int getTotalPlanetsGenerated() {\n        return totalPlanetsGenerated;\n    }\n\n    // NEW: Getters\n    public BiosphereManager getBiosphereManager() {\n        return biosphereManager;\n    }\n\n    public CelestialEvents getCelestialEvents() {\n        return celestialEvents;\n    }\n\n    public PlanetEventListener getPlanetEventListener() {\n        return planetEventListener;\n    }\n\n    public long getUptime() {\n        return System.currentTimeMillis() - startupTime;\n    }\n    \n    // ============================================\n    // LOGGING METODLARI\n    // ============================================\n    \n    public void logInfo(String message) {\n        getLogger().info(message);\n    }\n    \n    public void logSuccess(String message) {\n        getLogger().info(\"§a\" + message);\n    }\n    \n    public void logWarning(String message) {\n        getLogger().warning(message);\n    }\n    \n    public void logError(String message, Exception e) {\n        getLogger().log(Level.SEVERE, message, e);\n    }\n    \n    public void logDebug(String category, String message) {\n        if (configManager != null) {\n            configManager.sendDebugMessage(category, message);\n        }\n    }\n}","size_bytes":16767},"src/main/java/com/skyorbs/modifiers/ModifierResolver.java":{"content":"package com.skyorbs.modifiers;\n\nimport java.util.*;\n\n/**\n * Resolves which modifiers apply to a planet\n * Enables massive diversity through modifier combinations\n */\npublic class ModifierResolver {\n    \n    private final Random random;\n    \n    public ModifierResolver(long seed) {\n        this.random = new Random(seed);\n    }\n    \n    /**\n     * Roll for modifiers based on probabilities\n     * Each modifier is rolled independently\n     * @return Set of active modifiers for this planet\n     */\n    public Set<PlanetModifier> resolveModifiers() {\n        Set<PlanetModifier> active = new HashSet<PlanetModifier>();\n        \n        for (PlanetModifier modifier : PlanetModifier.values()) {\n            if (random.nextDouble() < modifier.getProbability()) {\n                active.add(modifier);\n            }\n        }\n        \n        // Ensure incompatible modifiers don't coexist\n        resolveConflicts(active);\n        \n        return active;\n    }\n    \n    /**\n     * Remove conflicting modifiers - EXTENDED CONFLICT RESOLUTION\n     */\n    private void resolveConflicts(Set<PlanetModifier> modifiers) {\n        // MAGMA_CORE and ICY_CORE are mutually exclusive\n        if (modifiers.contains(PlanetModifier.MAGMA_CORE) &&\n            modifiers.contains(PlanetModifier.ICY_CORE)) {\n            // Keep random one\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.ICY_CORE);\n            } else {\n                modifiers.remove(PlanetModifier.MAGMA_CORE);\n            }\n        }\n\n        // DENSE and POROUS are opposite\n        if (modifiers.contains(PlanetModifier.DENSE) &&\n            modifiers.contains(PlanetModifier.POROUS)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.POROUS);\n            } else {\n                modifiers.remove(PlanetModifier.DENSE);\n            }\n        }\n\n        // FROZEN and VOLCANIC are opposite\n        if (modifiers.contains(PlanetModifier.FROZEN) &&\n            modifiers.contains(PlanetModifier.VOLCANIC)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.VOLCANIC);\n            } else {\n                modifiers.remove(PlanetModifier.FROZEN);\n            }\n        }\n\n        // AQUATIC and SANDY are somewhat opposite\n        if (modifiers.contains(PlanetModifier.AQUATIC) &&\n            modifiers.contains(PlanetModifier.SANDY)) {\n            if (random.nextDouble() < 0.3) { // 30% chance to keep both (oasis)\n                // Keep both for interesting combinations\n            } else {\n                if (random.nextBoolean()) {\n                    modifiers.remove(PlanetModifier.SANDY);\n                } else {\n                    modifiers.remove(PlanetModifier.AQUATIC);\n                }\n            }\n        }\n\n        // VOID and CELESTIAL are mutually exclusive\n        if (modifiers.contains(PlanetModifier.VOID) &&\n            modifiers.contains(PlanetModifier.CELESTIAL)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.CELESTIAL);\n            } else {\n                modifiers.remove(PlanetModifier.VOID);\n            }\n        }\n\n        // RADIOACTIVE and VEGETATED don't mix well\n        if (modifiers.contains(PlanetModifier.RADIOACTIVE) &&\n            modifiers.contains(PlanetModifier.VEGETATED)) {\n            if (random.nextDouble() < 0.2) { // 20% chance to keep both (mutant plants)\n                // Keep both for interesting combinations\n            } else {\n                modifiers.remove(PlanetModifier.VEGETATED);\n            }\n        }\n\n        // DIVINE and INFERNAL are mutually exclusive\n        if (modifiers.contains(PlanetModifier.DIVINE) &&\n            modifiers.contains(PlanetModifier.INFERNAL)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.INFERNAL);\n            } else {\n                modifiers.remove(PlanetModifier.DIVINE);\n            }\n        }\n\n        // CHAOTIC and ORDERED are mutually exclusive\n        if (modifiers.contains(PlanetModifier.CHAOTIC) &&\n            modifiers.contains(PlanetModifier.ORDERED)) {\n            if (random.nextBoolean()) {\n                modifiers.remove(PlanetModifier.ORDERED);\n            } else {\n                modifiers.remove(PlanetModifier.CHAOTIC);\n            }\n        }\n\n        // Limit rare modifiers (max 2 per planet)\n        int rareCount = 0;\n        PlanetModifier[] toRemove = new PlanetModifier[0];\n        for (PlanetModifier mod : modifiers) {\n            if (mod.getProbability() < 0.1) { // Rare modifier\n                rareCount++;\n                if (rareCount > 2) {\n                    toRemove = java.util.Arrays.copyOf(toRemove, toRemove.length + 1);\n                    toRemove[toRemove.length - 1] = mod;\n                }\n            }\n        }\n        for (PlanetModifier mod : toRemove) {\n            modifiers.remove(mod);\n        }\n    }\n    \n    /**\n     * Get ore density multiplier\n     */\n    public double getOreDensityMultiplier(Set<PlanetModifier> modifiers) {\n        double multiplier = 1.0;\n        \n        if (modifiers.contains(PlanetModifier.ORE_RICH)) {\n            multiplier *= 2.0;\n        }\n        \n        if (modifiers.contains(PlanetModifier.DENSE)) {\n            multiplier *= 1.5;\n        }\n        \n        if (modifiers.contains(PlanetModifier.POROUS)) {\n            multiplier *= 0.7;\n        }\n        \n        return multiplier;\n    }\n    \n    /**\n     * Get shell thickness for hollow planets\n     */\n    public int getShellThickness(Set<PlanetModifier> modifiers, int baseThickness) {\n        if (modifiers.contains(PlanetModifier.HOLLOW)) {\n            if (modifiers.contains(PlanetModifier.DENSE)) {\n                return baseThickness + 2;\n            }\n            return baseThickness;\n        }\n        return -1; // Not hollow\n    }\n    \n    /**\n     * Check if planet should have tunnels\n     */\n    public boolean shouldHaveTunnels(Set<PlanetModifier> modifiers) {\n        return modifiers.contains(PlanetModifier.POROUS) || \n               modifiers.contains(PlanetModifier.HOLLOW);\n    }\n    \n    /**\n     * Get number of tunnels\n     */\n    public int getTunnelCount(Set<PlanetModifier> modifiers) {\n        if (modifiers.contains(PlanetModifier.POROUS)) {\n            return 5 + random.nextInt(5); // 5-10 tunnels\n        }\n        if (modifiers.contains(PlanetModifier.HOLLOW)) {\n            return 2 + random.nextInt(3); // 2-5 tunnels\n        }\n        return 0;\n    }\n}\n","size_bytes":6518},"src/main/java/com/skyorbs/shapes/impl/HouseShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HouseShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Ev şekli - walls, roof, door, windows\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // House base (temel)\n        if (y < -0.3) {\n            return Math.abs(x) <= 0.6 && Math.abs(z) <= 0.6;\n        }\n\n        // House walls (duvarlar)\n        if (y >= -0.3 && y < 0.3) {\n            return Math.abs(x) <= 0.5 && Math.abs(z) <= 0.5;\n        }\n\n        // House roof (çatı)\n        if (y >= 0.3 && y < 0.7) {\n            double roofWidth = 0.5 - (y - 0.3) * 0.5; // Çatı yukarıda daralır\n            return Math.abs(x) <= roofWidth && Math.abs(z) <= roofWidth;\n        }\n\n        // Door (kapı)\n        if (Math.abs(x) <= 0.1 && y >= -0.3 && y < 0.1 && z > 0.4) {\n            return false; // Kapı boşluğu\n        }\n\n        // Windows (pencereler)\n        if (y > -0.1 && y < 0.2) {\n            // Front windows\n            if (z > 0.3 && Math.abs(x - 0.25) <= 0.08) return false;\n            if (z > 0.3 && Math.abs(x + 0.25) <= 0.08) return false;\n            // Side windows\n            if (Math.abs(z) <= 0.08 && Math.abs(x - 0.35) <= 0.08) return false;\n            if (Math.abs(z) <= 0.08 && Math.abs(x + 0.35) <= 0.08) return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public String getName() {\n        return \"HOUSE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Ev\";\n    }\n}","size_bytes":1885},"src/main/java/com/skyorbs/generation/AdvancedWorldGen.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.*;\n\npublic class AdvancedWorldGen {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n\n    public AdvancedWorldGen(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Advanced procedural generation using Perlin + Voronoi hybrid\n     */\n    public List<BlockPlacement> generateAdvancedTerrain(Orb orb, PlanetType planetType) {\n        List<BlockPlacement> blocks = new ArrayList<BlockPlacement>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Initialize noise generators\n        SimplexOctaveGenerator perlinNoise = new SimplexOctaveGenerator(seed, 8);\n        perlinNoise.setScale(0.01);\n\n        SimplexOctaveGenerator detailNoise = new SimplexOctaveGenerator(seed + 1, 4);\n        detailNoise.setScale(0.05);\n\n        // Generate terrain using hybrid approach\n        for (int x = -radius; x <= radius; x++) {\n            for (int z = -radius; z <= radius; z++) {\n                // Check if within planet bounds (basic sphere)\n                double distance = Math.sqrt(x * x + z * z);\n                if (distance > radius) continue;\n\n                // Calculate height using Perlin noise\n                double perlinValue = perlinNoise.noise(x, z, 0.5);\n                double detailValue = detailNoise.noise(x, z, 0.5);\n                double combinedNoise = (perlinValue * 0.7) + (detailValue * 0.3);\n\n                // Apply Voronoi-like features for interesting terrain\n                double voronoiFeature = calculateVoronoiFeature(x, z, seed);\n\n                // Calculate final height\n                int height = (int) (combinedNoise * radius * 0.5);\n                height = Math.max(-radius, Math.min(radius, height));\n\n                // Add voronoi influence\n                height += (int) (voronoiFeature * radius * 0.2);\n\n                // Generate vertical column\n                for (int y = -radius; y <= height; y++) {\n                    double verticalDistance = Math.sqrt(x * x + y * y + z * z);\n                    if (verticalDistance <= radius) {\n                        Material material = getTerrainMaterial(planetType, y, height, combinedNoise, seed);\n                        blocks.add(new BlockPlacement(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Calculate Voronoi-like features for terrain variation\n     */\n    private double calculateVoronoiFeature(int x, int z, long seed) {\n        // Simple voronoi-like calculation for terrain features\n        double minDistance = Double.MAX_VALUE;\n\n        // Sample nearby points\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                int px = (x / 16) * 16 + dx * 8;\n                int pz = (z / 16) * 16 + dz * 8;\n\n                Random pointRandom = new Random(seed + px * 31 + pz);\n                int offsetX = pointRandom.nextInt(8) - 4;\n                int offsetZ = pointRandom.nextInt(8) - 4;\n\n                double distance = Math.sqrt((x - (px + offsetX)) * (x - (px + offsetX)) +\n                                          (z - (pz + offsetZ)) * (z - (pz + offsetZ)));\n                minDistance = Math.min(minDistance, distance);\n            }\n        }\n\n        return Math.max(0, 1.0 - minDistance / 8.0);\n    }\n\n    /**\n     * Get terrain material based on planet type and depth\n     */\n    private Material getTerrainMaterial(PlanetType planetType, int y, int surfaceHeight, double noise, long seed) {\n        Random materialRandom = new Random(seed + y * 17 + surfaceHeight);\n\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                if (y == surfaceHeight) {\n                    return materialRandom.nextDouble() < 0.7 ? Material.GRASS_BLOCK : Material.DIRT;\n                } else if (y > surfaceHeight - 3) {\n                    return Material.DIRT;\n                } else {\n                    return Material.STONE;\n                }\n            }\n            case GAS -> {\n                // Gas planets have layered gas materials\n                double layer = (double) y / surfaceHeight;\n                if (layer > 0.8) return Material.BLUE_WOOL;\n                else if (layer > 0.6) return Material.LIGHT_BLUE_WOOL;\n                else if (layer > 0.4) return Material.CYAN_WOOL;\n                else return Material.BLUE_WOOL;\n            }\n            case LAVA -> {\n                if (y >= surfaceHeight - 2) {\n                    return materialRandom.nextDouble() < 0.8 ? Material.MAGMA_BLOCK : Material.LAVA;\n                } else {\n                    return Material.NETHERRACK;\n                }\n            }\n            case ICE -> {\n                if (y == surfaceHeight) {\n                    return Material.SNOW_BLOCK;\n                } else if (y > surfaceHeight - 5) {\n                    return Material.ICE;\n                } else {\n                    return Material.PACKED_ICE;\n                }\n            }\n            case CRYSTAL -> {\n                double crystalChance = Math.abs(noise) * 0.5;\n                if (materialRandom.nextDouble() < crystalChance) {\n                    return Material.AMETHYST_BLOCK;\n                } else {\n                    return Material.QUARTZ_BLOCK;\n                }\n            }\n            case SHADOW -> {\n                return Material.BLACK_CONCRETE;\n            }\n            case TOXIC -> {\n                if (y == surfaceHeight) {\n                    return Material.SLIME_BLOCK;\n                } else {\n                    return Material.GREEN_CONCRETE;\n                }\n            }\n            default -> {\n                return Material.STONE;\n            }\n        }\n    }\n\n    /**\n     * Generate multi-layered ore maps\n     */\n    public List<BlockPlacement> generateOreLayers(Orb orb, PlanetType planetType) {\n        List<BlockPlacement> ores = new ArrayList<BlockPlacement>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Define ore layers with depth ranges\n        Map<OreLayer, Double> oreLayers = getOreConfiguration(planetType);\n\n        for (Map.Entry<OreLayer, Double> entry : oreLayers.entrySet()) {\n            OreLayer layer = entry.getKey();\n            double density = entry.getValue();\n\n            SimplexOctaveGenerator oreNoise = new SimplexOctaveGenerator(seed + layer.hashCode(), 4);\n            oreNoise.setScale(0.02);\n\n            // Generate ores within the layer's depth range\n            for (int x = -radius; x <= radius; x++) {\n                for (int z = -radius; z <= radius; z++) {\n                    for (int y = layer.minDepth; y <= layer.maxDepth; y++) {\n                        double distance = Math.sqrt(x * x + y * y + z * z);\n                        if (distance > radius) continue;\n\n                        // Check if we're in the right material\n                        if (!isValidOreLocation(planetType, y)) continue;\n\n                        // Use noise to determine ore placement\n                        double noiseValue = oreNoise.noise(x, y, z);\n                        if (Math.abs(noiseValue) < density) {\n                            ores.add(new BlockPlacement(cx + x, cy + y, cz + z, layer.material));\n                        }\n                    }\n                }\n            }\n        }\n\n        return ores;\n    }\n\n    /**\n     * Check if location is valid for ore placement\n     */\n    private boolean isValidOreLocation(PlanetType planetType, int y) {\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                return y < 0; // Underground only\n            }\n            case LAVA -> {\n                return y < 10; // Near surface in lava planets\n            }\n            case CRYSTAL -> {\n                return true; // Crystals can be anywhere\n            }\n            case ICE -> {\n                return y < -5; // Deep under ice\n            }\n            default -> {\n                return y < 0; // Underground by default\n            }\n        }\n    }\n\n    /**\n     * Get ore configuration for planet type\n     */\n    private Map<OreLayer, Double> getOreConfiguration(PlanetType planetType) {\n        Map<OreLayer, Double> layers = new HashMap<OreLayer, Double>();\n\n        switch (planetType) {\n            case TERRESTRIAL -> {\n                layers.put(new OreLayer(Material.COAL_ORE, -64, 128), 0.15);\n                layers.put(new OreLayer(Material.IRON_ORE, -64, 72), 0.12);\n                layers.put(new OreLayer(Material.COPPER_ORE, 0, 96), 0.10);\n                layers.put(new OreLayer(Material.GOLD_ORE, -64, 32), 0.04);\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, 16), 0.008);\n                layers.put(new OreLayer(Material.EMERALD_ORE, -16, 320), 0.005);\n            }\n            case LAVA -> {\n                layers.put(new OreLayer(Material.NETHERITE_BLOCK, -64, -32), 0.02);\n                layers.put(new OreLayer(Material.ANCIENT_DEBRIS, -64, -16), 0.01);\n                layers.put(new OreLayer(Material.GOLD_ORE, -32, 64), 0.08);\n            }\n            case CRYSTAL -> {\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, 64), 0.05);\n                layers.put(new OreLayer(Material.EMERALD_ORE, -32, 96), 0.03);\n                layers.put(new OreLayer(Material.LAPIS_ORE, 0, 32), 0.10);\n            }\n            case ICE -> {\n                layers.put(new OreLayer(Material.DIAMOND_ORE, -64, -16), 0.015);\n                layers.put(new OreLayer(Material.GOLD_ORE, -32, 16), 0.06);\n            }\n            // Add more planet-specific ore configs...\n        }\n\n        return layers;\n    }\n\n    /**\n     * Ore layer definition\n     */\n    private static class OreLayer {\n        final Material material;\n        final int minDepth;\n        final int maxDepth;\n\n        OreLayer(Material material, int minDepth, int maxDepth) {\n            this.material = material;\n            this.minDepth = minDepth;\n            this.maxDepth = maxDepth;\n        }\n\n        @Override\n        public int hashCode() {\n            return material.hashCode() + minDepth * 31 + maxDepth * 37;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof OreLayer)) return false;\n            OreLayer other = (OreLayer) obj;\n            return material == other.material && minDepth == other.minDepth && maxDepth == other.maxDepth;\n        }\n    }\n\n    /**\n     * Block placement helper class\n     */\n    public static class BlockPlacement {\n        public final int x, y, z;\n        public final Material material;\n\n        public BlockPlacement(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n}","size_bytes":11325},"src/main/java/com/skyorbs/shapes/impl/HangGliderShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HangGliderShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Delta kanat şekli - wing, keel, hang point\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Wing (kanat) - delta shape\n        if (y > 0) {\n            double wingWidth = y * 0.8; // Wider at back\n            double wingLength = 0.6;\n            return Math.abs(x) <= wingLength && Math.abs(z) <= wingWidth;\n        }\n\n        // Leading edge (ön kenar)\n        if (Math.abs(y) <= 0.05) {\n            return Math.abs(x) <= 0.6 && Math.abs(z) <= 0.8;\n        }\n\n        // Keel (omurga)\n        if (Math.abs(z) <= 0.03 && y <= 0) {\n            return Math.abs(x) <= 0.5;\n        }\n\n        // Hang point (asma noktası)\n        if (Math.abs(x) <= 0.08 && Math.abs(z) <= 0.08 && y <= -0.1 && y >= -0.2) {\n            return true;\n        }\n\n        // Control bar (kontrol çubuğu)\n        if (y <= -0.2 && y >= -0.25) {\n            return Math.abs(x) <= 0.3 && Math.abs(z) <= 0.02;\n        }\n\n        // Downtubes (destek çubukları)\n        if (Math.abs(x - 0.2) <= 0.02 && y <= -0.1) {\n            return Math.abs(z) <= 0.02;\n        }\n        if (Math.abs(x + 0.2) <= 0.02 && y <= -0.1) {\n            return Math.abs(z) <= 0.02;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"HANG_GLIDER\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Delta Kanat\";\n    }\n}","size_bytes":1890},"src/main/java/com/skyorbs/atmosphere/AtmosphereType.java":{"content":"package com.skyorbs.atmosphere;\n\nimport org.bukkit.Color;\nimport org.bukkit.Particle;\nimport org.bukkit.potion.PotionEffectType;\n\n/**\n * Different atmosphere types for planets\n * Provides visual and gameplay effects\n */\npublic enum AtmosphereType {\n    \n    CLEAR(\"Clear\", \"Temiz\", 0.4, \n        null, null, false, false),\n    \n    LUMINOUS(\"Luminous\", \"Parlak\", 0.2,\n        Particle.END_ROD, PotionEffectType.NIGHT_VISION, false, true),\n    \n    TOXIC(\"Toxic\", \"Zehirli\", 0.15,\n        Particle.DRIPPING_LAVA, PotionEffectType.POISON, true, false),\n    \n    STORMY(\"Stormy\", \"Fırtınalı\", 0.1,\n        Particle.CLOUD, PotionEffectType.SLOWNESS, true, false),\n    \n    FOGGY(\"Foggy\", \"Sisli\", 0.08,\n        Particle.CLOUD, PotionEffectType.BLINDNESS, true, false),\n    \n    CORROSIVE(\"Corrosive\", \"Aşındırıcı\", 0.05,\n        Particle.PORTAL, PotionEffectType.WITHER, true, false),\n    \n    AURORA(\"Aurora\", \"Aurora\", 0.03,\n        Particle.END_ROD, PotionEffectType.REGENERATION, false, true),\n    \n    RADIOACTIVE(\"Radioactive\", \"Radyoaktif\", 0.02,\n        Particle.ELECTRIC_SPARK, PotionEffectType.WITHER, true, false);\n    \n    private final String name;\n    private final String displayName;\n    private final double probability;\n    private final Particle particleType;\n    private final PotionEffectType effectType;\n    private final boolean hasFog;\n    private final boolean hasGlow;\n    \n    AtmosphereType(String name, String displayName, double probability,\n                   Particle particleType, PotionEffectType effectType,\n                   boolean hasFog, boolean hasGlow) {\n        this.name = name;\n        this.displayName = displayName;\n        this.probability = probability;\n        this.particleType = particleType;\n        this.effectType = effectType;\n        this.hasFog = hasFog;\n        this.hasGlow = hasGlow;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getProbability() {\n        return probability;\n    }\n    \n    public Particle getParticleType() {\n        return particleType;\n    }\n    \n    public PotionEffectType getEffectType() {\n        return effectType;\n    }\n    \n    public boolean hasFog() {\n        return hasFog;\n    }\n    \n    public boolean hasGlow() {\n        return hasGlow;\n    }\n    \n    public boolean hasEffects() {\n        return effectType != null;\n    }\n    \n    public boolean hasParticles() {\n        return particleType != null;\n    }\n    \n    /**\n     * Get color for atmosphere particles\n     */\n    public Color getAtmosphereColor() {\n        return switch (this) {\n            case LUMINOUS, AURORA -> Color.fromRGB(200, 220, 255);\n            case TOXIC -> Color.fromRGB(100, 255, 100);\n            case STORMY -> Color.fromRGB(128, 128, 128);\n            case FOGGY -> Color.fromRGB(200, 200, 200);\n            case CORROSIVE -> Color.fromRGB(255, 200, 50);\n            case RADIOACTIVE -> Color.fromRGB(0, 255, 0);\n            default -> Color.WHITE;\n        };\n    }\n}\n","size_bytes":3069},"src/main/java/com/skyorbs/shapes/impl/GeometricShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\n/**\n * GEOMETRIC SHAPE - Geometrik şekil (icosphere benzeri)\n * Creates planets with geometric, polyhedron-like appearance\n */\npublic class GeometricShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Create geodesic-like pattern\n        double ax = Math.abs(dx);\n        double ay = Math.abs(dy);\n        double az = Math.abs(dz);\n        \n        // Blend between sphere and polyhedron\n        double sphereVal = distance;\n        double polyVal = (ax + ay + az) * 0.7;\n        \n        double blended = sphereVal * 0.6 + polyVal * 0.4;\n        \n        return blended <= radius;\n    }\n\n    @Override\n    public String getName() { \n        return \"GEOMETRIC\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.0; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Geometrik\"; \n    }\n}\n","size_bytes":1080},"src/main/java/com/skyorbs/shapes/impl/LightningShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class LightningShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Yıldırım şekli - zigzag\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Lightning bolt formülü - zigzag pattern\n        double lightningPath = Math.abs(x - Math.sin(y * 10) * 0.3);\n        return lightningPath <= 0.2 && Math.abs(z) <= 0.1;\n    }\n\n    @Override\n    public String getName() {\n        return \"LIGHTNING\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Yıldırım\";\n    }\n}","size_bytes":966},"src/main/java/com/skyorbs/shapes/impl/ChessPieceShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ChessPieceShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Satranç taşı şekli - base, body, head\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Chess piece - wide base, narrow neck, detailed head\n        if (y < -0.5) {\n            // Base - geniş\n            return Math.sqrt(x*x + z*z) <= 0.6;\n        } else if (y < 0.0) {\n            // Body - orta\n            return Math.sqrt(x*x + z*z) <= 0.4;\n        } else {\n            // Head - detaylı şekil\n            double headRadius = Math.sqrt(x*x + z*z);\n            // Cross shape on top\n            if (Math.abs(x) <= 0.2 && Math.abs(z) <= 0.2) return true;\n            if (Math.abs(x) <= 0.4 && Math.abs(z) <= 0.1) return true;\n            if (Math.abs(x) <= 0.1 && Math.abs(z) <= 0.4) return true;\n            return headRadius <= 0.3;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"CHESS_PIECE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Satranç Taşı\";\n    }\n}","size_bytes":1479},"src/main/java/com/skyorbs/shapes/impl/ArrowShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ArrowShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Ok şekli - 3D arrow\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Arrow formülü - baş kısmı geniş, kuyruk kısmı dar\n        double arrowLength = Math.abs(y);\n        double arrowWidth = 0.8 - 0.6 * arrowLength; // Uçta geniş, kuyrukta dar\n\n        return Math.abs(x) <= arrowWidth && Math.abs(z) <= arrowWidth;\n    }\n\n    @Override\n    public String getName() {\n        return \"ARROW\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Ok\";\n    }\n}","size_bytes":1027},"src/main/java/com/skyorbs/gui/AdminConfigGUI.java":{"content":"package com.skyorbs.gui;\n\nimport com.skyorbs.SkyOrbs;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\npublic class AdminConfigGUI {\n\n    private final SkyOrbs plugin;\n\n    public AdminConfigGUI(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public void openAdminConfigGUI(Player player) {\n        Inventory gui = Bukkit.createInventory(null, 54, \"§8[§cAdmin Konfigürasyon§8]\");\n\n        // Generation Settings (Top Row)\n        gui.setItem(0, createGenerationSettingsItem());\n        gui.setItem(1, createPlacementSettingsItem());\n        gui.setItem(2, createPerformanceSettingsItem());\n        gui.setItem(3, createFeatureSettingsItem());\n        gui.setItem(4, createLimitSettingsItem());\n\n        // Ore Configuration (Second Row)\n        gui.setItem(9, createOreConfigItem(\"terrestrial\"));\n        gui.setItem(10, createOreConfigItem(\"lava\"));\n        gui.setItem(11, createOreConfigItem(\"crystal\"));\n        gui.setItem(12, createOreConfigItem(\"ice\"));\n        gui.setItem(13, createOreConfigItem(\"shadow\"));\n        gui.setItem(14, createOreConfigItem(\"toxic\"));\n        gui.setItem(15, createOreConfigItem(\"gas\"));\n\n        // Quick Actions (Third Row)\n        gui.setItem(18, createReloadConfigItem());\n        gui.setItem(19, createResetAllItem());\n        gui.setItem(20, createExportConfigItem());\n        gui.setItem(21, createImportConfigItem());\n        gui.setItem(22, createSaveConfigItem());\n        gui.setItem(23, createBackupConfigItem());\n\n        // System Info (Fourth Row)\n        gui.setItem(27, createSystemInfoItem());\n        gui.setItem(28, createPerformanceStatsItem());\n        gui.setItem(29, createPlanetStatsItem());\n\n        // Close button\n        gui.setItem(49, createCloseItem());\n\n        player.openInventory(gui);\n    }\n\n    private ItemStack createGenerationSettingsItem() {\n        ItemStack item = new ItemStack(Material.GRASS_BLOCK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§a§lÜretim Ayarları\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen boyutları ve şekilleri\");\n        lore.add(\"\");\n        lore.add(\"§7Min yarıçap: §e\" + plugin.getConfigManager().getMinRadius());\n        lore.add(\"§7Max yarıçap: §e\" + plugin.getConfigManager().getMaxRadius());\n        lore.add(\"§7Ortalama yarıçap: §e\" + plugin.getConfigManager().getAverageRadius());\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createPlacementSettingsItem() {\n        ItemStack item = new ItemStack(Material.COMPASS);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lYerleştirme Ayarları\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen konumlandırma kuralları\");\n        lore.add(\"\");\n        lore.add(\"§7Max uzaklık: §e\" + plugin.getConfigManager().getMaxDistance());\n        lore.add(\"§7Kümeleme: §e\" + (plugin.getConfigManager().isClusteringEnabled() ? \"Aktif\" : \"Pasif\"));\n        lore.add(\"§7Küme min uzaklık: §e\" + plugin.getConfigManager().getClusterMinDistance());\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createPerformanceSettingsItem() {\n        ItemStack item = new ItemStack(Material.REDSTONE);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lPerformans Ayarları\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Batch boyutu ve hız ayarları\");\n        lore.add(\"\");\n        lore.add(\"§7Batch boyutu: §e\" + plugin.getConfigManager().getBlocksPerBatch());\n        lore.add(\"§7Tick başına batch: §e\" + plugin.getConfigManager().getBatchesPerTick());\n        lore.add(\"§7Shell kalınlığı: §e\" + plugin.getConfigManager().getShellThickness());\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createFeatureSettingsItem() {\n        ItemStack item = new ItemStack(Material.LEVER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§d§lÖzellik Ayarları\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Üretim özelliklerinin aç/kapa\");\n        lore.add(\"\");\n        lore.add(\"§7Ore üretimi: \" + (plugin.getConfigManager().isOreGenerationEnabled() ? \"§aAktif\" : \"§cPasif\"));\n        lore.add(\"§7Ağaç üretimi: \" + (plugin.getConfigManager().isTreeGenerationEnabled() ? \"§aAktif\" : \"§cPasif\"));\n        lore.add(\"§7Yapı üretimi: \" + (plugin.getConfigManager().isStructureGenerationEnabled() ? \"§aAktif\" : \"§cPasif\"));\n        lore.add(\"§7Hazine üretimi: \" + (plugin.getConfigManager().isTreasureGenerationEnabled() ? \"§aAktif\" : \"§cPasif\"));\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createLimitSettingsItem() {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§4§lLimit Ayarları\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Oyuncu ve sistem limitleri\");\n        lore.add(\"\");\n        lore.add(\"§7Oyuncu başına gezegen: §e\" + plugin.getConfigManager().getPlanetsPerPlayer());\n        lore.add(\"§7Dünya başına max gezegen: §e\" + plugin.getConfigManager().getMaxPlanetsPerWorld());\n        lore.add(\"§7Üretim cooldown: §e\" + plugin.getConfigManager().getGenerationCooldown() + \"s\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createOreConfigItem(String planetType) {\n        Material material = switch (planetType) {\n            case \"terrestrial\" -> Material.GRASS_BLOCK;\n            case \"lava\" -> Material.LAVA_BUCKET;\n            case \"crystal\" -> Material.AMETHYST_SHARD;\n            case \"ice\" -> Material.ICE;\n            case \"shadow\" -> Material.OBSIDIAN;\n            case \"toxic\" -> Material.SLIME_BALL;\n            case \"gas\" -> Material.GLASS;\n            default -> Material.STONE;\n        };\n\n        ItemStack item = new ItemStack(material);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§l\" + planetType.toUpperCase() + \" Ore Ayarları\");\n\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7\" + planetType + \" gezegen tipi için ore konfigürasyonu\");\n\n        var config = plugin.getConfigManager().getOreConfigForPlanetType(planetType);\n        boolean enabled = (Boolean) config.getOrDefault(\"enabled\", true);\n        double multiplier = (Double) config.getOrDefault(\"densityMultiplier\", 1.0);\n\n        lore.add(\"\");\n        lore.add(\"§7Durum: \" + (enabled ? \"§aAktif\" : \"§cPasif\"));\n        lore.add(\"§7Yoğunluk çarpanı: §e\" + String.format(\"%.1fx\", multiplier));\n\n        @SuppressWarnings(\"unchecked\")\n        var ores = (java.util.Map<String, java.util.Map<String, Object>>) config.get(\"ores\");\n        if (ores != null && !ores.isEmpty()) {\n            lore.add(\"\");\n            lore.add(\"§7Konfigüre edilmiş madenler:\");\n            ores.forEach((oreName, oreData) -> {\n                boolean oreEnabled = (Boolean) oreData.getOrDefault(\"enabled\", true);\n                double chance = ((Number) oreData.getOrDefault(\"chance\", 0.0)).doubleValue();\n                lore.add(\"§8• §f\" + oreName + \" §7(\" + (oreEnabled ? \"§aAktif\" : \"§cPasif\") + \"§7) - §e\" + String.format(\"%.3f\", chance));\n            });\n        }\n\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak düzenle!\");\n\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createReloadConfigItem() {\n        ItemStack item = new ItemStack(Material.KNOWLEDGE_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§a§lKonfigürasyonu Yenile\");\n        List<String> lore = new ArrayList<String>();\n        lore.add(\"§7Konfigürasyon dosyasını yeniden yükle\");\n        lore.add(\"§7Değişiklikleri uygula\");\n        lore.add(\"§7Cache'leri temizle\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak yenile!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createResetAllItem() {\n        ItemStack item = new ItemStack(Material.TNT);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§4§lTümünü Sıfırla\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Tüm ayarları varsayılan değerlere sıfırla\");\n        lore.add(\"§4§lBu işlem geri alınamaz!\");\n        lore.add(\"\");\n        lore.add(\"§cSağ tıkla onay için\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createExportConfigItem() {\n        ItemStack item = new ItemStack(Material.WRITABLE_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lKonfigürasyonu Dışa Aktar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Mevcut konfigürasyonu dosyaya kaydet\");\n        lore.add(\"§7Yedekleme için kullan\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak dışa aktar!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createImportConfigItem() {\n        ItemStack item = new ItemStack(Material.ENCHANTED_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lKonfigürasyonu İçe Aktar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Dışarıdan konfigürasyon yükle\");\n        lore.add(\"§7Yedekten geri yükleme\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak içe aktar!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSaveConfigItem() {\n        ItemStack item = new ItemStack(Material.WRITTEN_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lKonfigürasyonu Kaydet\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Mevcut ayarları diske kaydet\");\n        lore.add(\"§7Değişiklikleri kalıcı hale getir\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak kaydet!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createBackupConfigItem() {\n        ItemStack item = new ItemStack(Material.BOOKSHELF);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§8§lKonfigürasyon Yedekle\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Konfigürasyonun yedeğini al\");\n        lore.add(\"§7Acil durumlar için\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak yedekle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSystemInfoItem() {\n        ItemStack item = new ItemStack(Material.CLOCK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lSistem Bilgileri\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Sunucu ve eklenti bilgileri\");\n        lore.add(\"\");\n        lore.add(\"§7Bukkit versiyonu: §e\" + Bukkit.getVersion());\n        lore.add(\"§7Eklenti versiyonu: §e\" + plugin.getDescription().getVersion());\n        lore.add(\"§7Çevrimiçi oyuncular: §e\" + Bukkit.getOnlinePlayers().size());\n        lore.add(\"\");\n        lore.add(\"§7Tıklayarak detayları görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createPerformanceStatsItem() {\n        ItemStack item = new ItemStack(Material.LIGHTNING_ROD);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§e§lPerformans İstatistikleri\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7CPU, RAM ve TPS bilgileri\");\n        lore.add(\"\");\n        Runtime runtime = Runtime.getRuntime();\n        long totalMemory = runtime.totalMemory() / 1024 / 1024;\n        long freeMemory = runtime.freeMemory() / 1024 / 1024;\n        long usedMemory = totalMemory - freeMemory;\n\n        lore.add(\"§7Kullanılan RAM: §e\" + usedMemory + \"MB\");\n        lore.add(\"§7Toplam RAM: §e\" + totalMemory + \"MB\");\n        lore.add(\"§7Serbest RAM: §e\" + freeMemory + \"MB\");\n        lore.add(\"\");\n        lore.add(\"§7Tıklayarak canlı istatistikleri görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createPlanetStatsItem() {\n        ItemStack item = new ItemStack(Material.GLOBE_BANNER_PATTERN);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lGezegen İstatistikleri\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Toplam gezegen ve tür bilgileri\");\n\n        try {\n            Set<String> planetTypes = plugin.getConfigManager().getConfiguredPlanetTypes();\n            int totalPlanets = plugin.getDatabaseManager().getAllOrbs().size();\n\n            lore.add(\"\");\n            lore.add(\"§7Toplam gezegen: §e\" + totalPlanets);\n            lore.add(\"§7Konfigüre edilmiş türler: §e\" + planetTypes.size());\n\n            if (!planetTypes.isEmpty()) {\n                lore.add(\"\");\n                lore.add(\"§7Türler:\");\n                for (String type : planetTypes) {\n                    lore.add(\"§8• §f\" + type);\n                }\n            }\n\n        } catch (Exception e) {\n            lore.add(\"\");\n            lore.add(\"§cVeritabanı hatası!\");\n        }\n\n        lore.add(\"\");\n        lore.add(\"§7Tıklayarak detayları görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createCloseItem() {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lKapat\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Konfigürasyon panelini kapat\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n}","size_bytes":14722},"src/main/java/com/skyorbs/shapes/impl/RainbowShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.SkyOrbs;\n\npublic class RainbowShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Gökkuşağı şekli - yay şeklinde (CONFIG KONTROLLÜ)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // CONFIG'DEN ALGORİTMA AYARLARINI OKU\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        double arcAngle = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.rainbow.arcAngle\", 120.0);\n        double innerRadius = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.rainbow.innerRadius\", 0.4);\n        double outerRadius = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.rainbow.outerRadius\", 0.9);\n        double thickness = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.rainbow.thickness\", 0.15);\n        double heightVariation = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.rainbow.heightVariation\", 0.4);\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // 2D yay kontrolü (XZ düzleminde)\n        double angle = Math.atan2(z, x);\n        double arcRadius = Math.sqrt(x * x + z * z);\n\n        // Gökkuşağı yayı - config kontrollü açı\n        double maxAngle = Math.toRadians(arcAngle / 2);\n        if (angle < -maxAngle || angle > maxAngle) return false;\n\n        // Y koordinatı için eğim - yay şeklinde kıvrım (config kontrollü)\n        double arcHeight = Math.sin(angle) * heightVariation;\n        double expectedY = arcHeight;\n\n        // Config kontrollü kontrol\n        return arcRadius >= innerRadius && arcRadius <= outerRadius &&\n               Math.abs(y - expectedY) <= thickness;\n    }\n\n    @Override\n    public String getName() {\n        return \"RAINBOW\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Gökkuşağı\";\n    }\n}","size_bytes":2206},"README.md":{"content":"# SkyOrbs 2.0.0 - Türkçe Minecraft Gezegen Oluşturma Eklentisi\n\n[![Paper](https://img.shields.io/badge/Paper-1.21.4-blue.svg)](https://papermc.io/)\n[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://www.oracle.com/java/)\n[![Maven](https://img.shields.io/badge/Maven-3.8+-red.svg)](https://maven.apache.org/)\n\n## 📖 Açıklama\n\nSkyOrbs, Minecraft sunucularınızda **benzersiz gezegen dünyaları** oluşturmanıza olanak tanıyan, tamamen Türkçe bir Paper eklentisidir. 17 farklı gezegen şekli, 22 biyom tipi, asteroid ve uydu sistemiyle gezegeninizi özelleştirin!\n\n## ✨ Özellikler\n\n### 🌍 Gezegen Sistemi\n- **17+ Gezegen Şekli:** Küre, Ameba, Asteroid, Elips, Çörek, Halka, Silindir, Koni, Elmas, Küp, Piramit, Sekizyüzlü, Fraktal, Dikenli, Kuyruklu Yıldız, Hilal, Karma\n- **22 Biyom Tipi:** Orman, Çöl, Buzul, Volkanik, Kristal Ormanı, Boşluk, ve daha fazlası\n- **Akıllı Yerleştirme:** Gezegenler birbirine 800-2000 blok mesafede, spawn'dan minimum 1000 blok uzakta\n- **1000+ Rastgele İsim:** Türkçe ve bilimkurgu tarzı benzersiz gezegen isimleri\n\n### 🪐 Asteroid & Uydu Sistemi\n- Gezegen başına 1-5 asteroid\n- Gezegen başına 0-3 uydu (olasılığa dayalı)\n- Tamamen config'den özelleştirilebilir\n\n### 🎮 Komutlar (Tamamen Türkçe)\n```\n/gezegen create          - Yeni gezegen oluştur\n/gezegen list            - Tüm gezegenleri listele\n/gezegen tp <isim>       - Gezegene ışınlan\n/gezegen info <isim>     - Gezegen bilgilerini göster (yakındaki gezegenlerle mesafe)\n/gezegen sil <isim>      - Gezegeni sil (sadece Admin)\n/gezegen reload          - Konfigürasyonu yenile (sadece Admin)\n```\n\n### ⚙️ Config-Driven Sistem\n**Her şey config.yml'den düzenlenebilir:**\n- Gezegen boyutları (min/max radius)\n- Gezegenler arası mesafeler\n- Her şekil için ağırlıklar\n- Biyom dağılımları\n- Asteroid/Uydu sayıları\n- 1000+ isim havuzu\n- Tüm mesajlar (Türkçe)\n\n## 📦 Kurulum\n\n### Gereksinimler\n- **Minecraft:** 1.21.4\n- **Server:** Paper (Spigot/Bukkit **desteklenmez**)\n- **Java:** JDK 21+\n- **Maven:** 3.8+ (sadece compile için)\n\n### Adım 1: JAR Dosyasını Derle\n\n```bash\nmvn clean package\n```\n\nDerlenmiş JAR dosyası `target/SkyOrbs-2.0.0.jar` konumunda oluşacaktır.\n\n### Adım 2: Sunucuya Yükle\n\n1. `SkyOrbs-2.0.0.jar` dosyasını sunucunuzun `plugins/` klasörüne kopyalayın\n2. Sunucuyu başlatın veya `/reload confirm` komutunu çalıştırın\n3. `plugins/SkyOrbs/config.yml` dosyası otomatik oluşturulacaktır\n\n### Adım 3: Konfigürasyonu Düzenle (İsteğe Bağlı)\n\n`config.yml` dosyasını açıp tüm ayarları ihtiyacınıza göre değiştirin:\n\n```yaml\n# Gezegen boyutları\ngeneration:\n  planetSize:\n    minRadius: 80\n    maxRadius: 250\n\n# Gezegenler arası mesafe\nplacement:\n  clustering:\n    clusterMinDistance: 800    # Minimum mesafe\n    clusterMaxDistance: 2000   # Maximum mesafe\n```\n\n### Adım 4: İlk Gezegeni Oluştur\n\nOyuna girin ve komutu çalıştırın:\n\n```\n/gezegen create\n```\n\n## 🛠️ Geliştirme\n\n### Proje Yapısı\n\n```\nskyorbs/\n├── src/main/java/com/skyorbs/\n│   ├── core/              # Temel sınıflar (Orb)\n│   ├── commands/          # Komut sistemi\n│   ├── generation/        # Gezegen üretimi\n│   ├── shapes/            # 17 gezegen şekli\n│   ├── biomes/            # 22 biyom tipi\n│   ├── storage/           # SQLite veritabanı\n│   ├── utils/             # Yardımcı araçlar\n│   ├── config/            # Config yönetimi\n│   └── features/          # Ore, Tree, Structure, Treasure\n├── src/main/resources/\n│   ├── config.yml         # Ultra detaylı config (1000+ isim)\n│   └── plugin.yml         # Türkçe plugin tanımı\n├── pom.xml\n└── README.md\n```\n\n### Build\n\n```bash\n# Temizle ve derle\nmvn clean package\n\n# Sadece compile\nmvn compile\n\n# Test et (varsa)\nmvn test\n```\n\n### Bağımlılıklar\n\n- **Paper API:** 1.21.4-R0.1-SNAPSHOT\n- **SQLite JDBC:** 3.44.0.0\n- **Gson:** 2.10.1\n\n## 📝 Config Ayarları\n\n### Gezegen Boyutları\n\n```yaml\ngeneration:\n  planetSize:\n    minRadius: 80\n    maxRadius: 250\n    averageRadius: 150\n```\n\n### Yerleştirme\n\n```yaml\nplacement:\n  worldBounds:\n    maxDistance: 3000              # Spawn'dan max uzaklık\n    minDistanceFromSpawn: 1000     # Spawn'dan min uzaklık\n  \n  clustering:\n    clusterMinDistance: 800        # Gezegenler arası min\n    clusterMaxDistance: 2000       # Gezegenler arası max\n```\n\n### Şekil Ağırlıkları\n\n```yaml\nshapes:\n  weights:\n    SPHERE: 15.0\n    BLOB: 12.0\n    ASTEROID: 10.0\n    # ... 14 şekil daha\n```\n\n### İsim Sistemi\n\n```yaml\nplanetNames:\n  prefixes:\n    - \"Zyr\"\n    - \"Kry\"\n    - \"Vel\"\n    # ... 200+ önek\n  \n  suffixes:\n    - \"ion\"\n    - \"ara\"\n    - \"eon\"\n    # ... 200+ sonek\n  \n  postfixes:\n    - \"Prime\"\n    - \"Alpha\"\n    - \"Beta\"\n    # ... 50+ takı\n```\n\n## 🎯 İzinler\n\n```yaml\nskyorbs.*           # Tüm izinler (op)\nskyorbs.use         # Temel komutlar (herkes)\nskyorbs.create      # Gezegen oluşturma (herkes)\nskyorbs.list        # Liste görme (herkes)\nskyorbs.tp          # Işınlanma (herkes)\nskyorbs.info        # Bilgi görme (herkes)\nskyorbs.admin       # Admin komutları (op)\n```\n\n## 🐛 Sorun Giderme\n\n### JAR Derlenmiyor\n\n```bash\n# Java 21 kurulu mu kontrol edin\njava -version\n\n# Maven kurulu mu kontrol edin\nmvn -version\n\n# Bağımlılıkları güncelleyin\nmvn clean install -U\n```\n\n### Gezegen Oluşturulmuyor\n\n1. Konsol loglarını kontrol edin\n2. `config.yml` dosyasının düzgün olduğundan emin olun\n3. Veritabanı (`data.db`) dosyası erişilebilir mi kontrol edin\n4. Sunucunun Paper olduğundan emin olun (Spigot/Bukkit desteklenmez)\n\n### Performans Sorunları\n\n`config.yml` dosyasında performans ayarlarını düzenleyin:\n\n```yaml\nperformance:\n  asyncGeneration: true\n  threadPool:\n    coreSize: 4\n    maxSize: 8\n  batching:\n    blocksPerBatch: 500\n    batchesPerTick: 5\n```\n\n## 📄 Lisans\n\nBu proje MIT lisansı altında lisanslanmıştır.\n\n## 🤝 Katkıda Bulunma\n\n1. Fork edin\n2. Feature branch oluşturun (`git checkout -b feature/AmazingFeature`)\n3. Commit edin (`git commit -m 'Add some AmazingFeature'`)\n4. Push edin (`git push origin feature/AmazingFeature`)\n5. Pull Request açın\n\n## 📧 İletişim\n\nSorularınız için Issue açabilirsiniz.\n\n## 🙏 Teşekkürler\n\n- Paper ekibine harika API için\n- Minecraft topluluğuna ilham için\n- Türkçe plugin ekosistemini destekleyen herkese\n\n---\n\n**SkyOrbs 2.0.0** - Uzayda kendi gezegeni ni oluştur! 🌍✨\n","size_bytes":6542},"src/main/java/com/skyorbs/shapes/impl/HoneycombShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\n/**\n * HONEYCOMB SHAPE - Bal peteği yapısı\n * Creates planets with hexagonal honeycomb patterns\n */\npublic class HoneycombShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance > radius) return false;\n        \n        // Create hexagonal pattern\n        double hexSize = 10.0;\n        double qx = dx / hexSize;\n        double qz = dz / hexSize;\n        \n        // Hexagonal grid coordinates\n        double q = qx;\n        double r = qz;\n        \n        // Snap to hex grid\n        int hexQ = (int)Math.round(q);\n        int hexR = (int)Math.round(r);\n        \n        // Distance to hex center\n        double hexDist = Math.sqrt((q - hexQ) * (q - hexQ) + (r - hexR) * (r - hexR));\n        \n        // Create walls between hexagons\n        if (hexDist > 0.4) return false;\n        \n        return distance <= radius;\n    }\n\n    @Override\n    public String getName() { \n        return \"HONEYCOMB\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.0; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Bal Peteği\"; \n    }\n}\n","size_bytes":1327},"src/main/java/com/skyorbs/shapes/impl/BrainShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class BrainShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Beyin şekli - convoluted surface, gyri and sulci\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Base brain shape - oval\n        double baseRadius = Math.sqrt(x*x + y*y + z*z);\n        if (baseRadius > 0.9) return false;\n\n        // Add convolutions (beyin kıvrımları)\n        double convolution1 = Math.sin(x * 8) * Math.cos(z * 8) * 0.1;\n        double convolution2 = Math.sin(y * 6) * Math.sin(x * 6) * 0.08;\n        double convolution3 = Math.cos(z * 10) * Math.sin(y * 10) * 0.06;\n\n        double totalConvolution = convolution1 + convolution2 + convolution3;\n        double brainSurface = 0.7 + totalConvolution;\n\n        return baseRadius <= brainSurface;\n    }\n\n    @Override\n    public String getName() {\n        return \"BRAIN\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Beyin\";\n    }\n}","size_bytes":1373},"src/test/java/com/skyorbs/ShapeRegistryTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.shapes.ShapeRegistry;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class ShapeRegistryTest {\n\n    private ShapeRegistry shapeRegistry;\n\n    @BeforeEach\n    public void setUp() {\n        shapeRegistry = new ShapeRegistry();\n        shapeRegistry.registerAllShapes();\n    }\n\n    @Test\n    public void testShapeRegistryInitialization() {\n        assertNotNull(shapeRegistry);\n        assertEquals(33, shapeRegistry.getShapeCount()); // Updated: 18 original + 15 new shapes\n    }\n\n    @Test\n    public void testShapeRetrieval() {\n        PlanetShape sphere = shapeRegistry.getShape(\"SPHERE\");\n        assertNotNull(sphere);\n        assertEquals(\"SPHERE\", sphere.getName());\n        assertEquals(\"Küre\", sphere.getDisplayName());\n    }\n\n    @Test\n    public void testRandomShapeSelection() {\n        PlanetShape randomShape = shapeRegistry.getRandomShape(java.util.Map.of(\n            \"SPHERE\", 1.0,\n            \"BLOB\", 0.0\n        ));\n        assertNotNull(randomShape);\n        assertEquals(\"SPHERE\", randomShape.getName());\n    }\n\n    @Test\n    public void testInvalidShapeRetrieval() {\n        PlanetShape invalidShape = shapeRegistry.getShape(\"INVALID\");\n        assertNotNull(invalidShape); // Should return default SPHERE\n        assertEquals(\"SPHERE\", invalidShape.getName());\n    }\n}","size_bytes":1458},"src/main/java/com/skyorbs/shapes/impl/AnchorShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class AnchorShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Çapa şekli - shank, stock, flukes\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Anchor shank (dikey kısım)\n        if (Math.abs(x) <= 0.05 && Math.abs(z) <= 0.05 && y >= -0.8) {\n            return true;\n        }\n\n        // Anchor stock (yatay kısım)\n        if (y >= -0.2 && y <= 0.1 && Math.abs(z) <= 0.05) {\n            return Math.abs(x) <= 0.4;\n        }\n\n        // Anchor flukes (çengeller)\n        if (y < -0.2) {\n            // Left fluke\n            if (x <= -0.1 && x >= -0.4) {\n                double flukeShape = Math.abs(x + 0.25) + Math.abs(y + 0.5);\n                return flukeShape <= 0.3 && Math.abs(z) <= 0.05;\n            }\n            // Right fluke\n            if (x >= 0.1 && x <= 0.4) {\n                double flukeShape = Math.abs(x - 0.25) + Math.abs(y + 0.5);\n                return flukeShape <= 0.3 && Math.abs(z) <= 0.05;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"ANCHOR\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Çapa\";\n    }\n}","size_bytes":1618},"QUICK_WINS.md":{"content":"# 🚀 SkyOrbs - Quick Wins (Hemen Uygulanabilir İyileştirmeler)\n\n## ✅ Şu Anda Uygulanabilir İyileştirmeler\n\n### 1. **Ore Generation Görselleştirme** 💎\n**Sorun**: Oyuncular ore'ların nerede olduğunu bilmiyor\n**Çözüm**: Debug modu ile ore haritası\n\n```java\n// OreGenerator.java'ya ekle:\npublic static void visualizeOres(Player player, Orb orb) {\n    // Ore'ları particle ile göster\n    List<BlockData> ores = generateOres(orb, biome, world);\n    for (BlockData ore : ores) {\n        player.spawnParticle(Particle.VILLAGER_HAPPY, \n            ore.x, ore.y, ore.z, 1);\n    }\n}\n```\n\n### 2. **Planet Preview** 👁️\n**Sorun**: Gezegen oluşmadan nasıl görüneceği bilinmiyor\n**Çözüm**: Hologram preview\n\n```java\n// /gezegen preview <shape> <biome> komutu\n// Küçük hologram göster (5 blok yarıçap)\n```\n\n### 3. **Teleport Güvenliği** 🛡️\n**Sorun**: Bazen tehlikeli yerlere ışınlanma\n**Çözüm**: Gelişmiş güvenlik kontrolü\n\n```java\nprivate boolean isSafeLocation(Location loc) {\n    // Lava, void, suffocation kontrolü\n    // 3x3 alan kontrolü\n    // Düşme mesafesi kontrolü\n    return safe;\n}\n```\n\n### 4. **Generation Queue** ⏳\n**Sorun**: Aynı anda çok fazla gezegen oluşturulursa lag\n**Çözüm**: Kuyruk sistemi\n\n```java\npublic class GenerationQueue {\n    private final Queue<GenerationTask> queue = new LinkedList<>();\n    private int maxConcurrent = 2;\n    \n    public void addToQueue(GenerationTask task) {\n        queue.offer(task);\n        processQueue();\n    }\n}\n```\n\n### 5. **Planet Info GUI** 📊\n**Sorun**: Gezegen bilgileri sadece chat'te\n**Çözüm**: Güzel bir GUI\n\n```java\npublic class PlanetInfoGUI {\n    // Gezegen istatistikleri\n    // Sahip bilgisi\n    // Özellikler\n    // Teleport butonu\n}\n```\n\n### 6. **Auto-Cleanup** 🧹\n**Sorun**: Eski/kullanılmayan gezegenler yer kaplıyor\n**Çözüm**: Otomatik temizlik\n\n```java\n// Config:\ncleanup:\n  enabled: true\n  inactiveDays: 30  # 30 gün ziyaret edilmezse\n  warnDays: 7       # 7 gün önce uyar\n```\n\n### 7. **Backup System** 💾\n**Sorun**: Gezegen kaybı durumunda geri alma yok\n**Çözüm**: Otomatik yedekleme\n\n```java\npublic class BackupManager {\n    public void backupPlanet(Orb orb) {\n        // Gezegen verilerini JSON'a kaydet\n        // Blokları schematic olarak kaydet\n    }\n}\n```\n\n### 8. **Performance Profiler** 📈\n**Sorun**: Hangi kısım yavaş bilinmiyor\n**Çözüm**: Detaylı profiling\n\n```java\npublic class Profiler {\n    public void startSection(String name);\n    public void endSection();\n    public void printReport();\n}\n\n// Kullanım:\nprofiler.startSection(\"ore_generation\");\ngenerateOres(...);\nprofiler.endSection();\n```\n\n### 9. **Planet Search** 🔍\n**Sorun**: Gezegen bulmak zor\n**Çözüm**: Arama sistemi\n\n```java\n// /gezegen search <criteria>\n// /gezegen search biome:LAVA\n// /gezegen search shape:SPHERE\n// /gezegen search owner:Koraizen\n```\n\n### 10. **Planet Rating** ⭐\n**Sorun**: Hangi gezegenler popüler bilinmiyor\n**Çözüm**: Oyuncu puanlama sistemi\n\n```java\npublic class RatingSystem {\n    public void ratePlanet(Player player, Orb orb, int stars);\n    public double getAverageRating(Orb orb);\n    public List<Orb> getTopRated(int count);\n}\n```\n\n---\n\n## 🎯 Öncelik Sırası\n\n### Hemen Yapılmalı (Bu Hafta):\n1. ✅ **Generation Queue** - Lag önleme\n2. ✅ **Teleport Güvenliği** - Oyuncu güvenliği\n3. ✅ **Performance Profiler** - Optimizasyon için\n\n### Yakında Yapılmalı (Gelecek Hafta):\n4. ✅ **Planet Info GUI** - Kullanıcı deneyimi\n5. ✅ **Planet Search** - Kullanılabilirlik\n6. ✅ **Backup System** - Veri güvenliği\n\n### İyi Olur (Gelecek Ay):\n7. ✅ **Planet Preview** - Görsel özellik\n8. ✅ **Ore Visualization** - Debug özelliği\n9. ✅ **Auto-Cleanup** - Bakım\n10. �� **Rating System** - Sosyal özellik\n\n---\n\n## 💡 Kolay Eklentiler\n\n### 1. **Komut Aliasları**\n```yaml\n# plugin.yml\ncommands:\n  gezegen:\n    aliases: [planet, p, gz]\n```\n\n### 2. **Tab Complete İyileştirme**\n```java\n// Daha akıllı tab complete\n// Oyuncu isimlerini öner\n// Biyom isimlerini öner\n// Şekil isimlerini öner\n```\n\n### 3. **Mesaj Formatı**\n```yaml\n# Daha güzel mesajlar\nmessages:\n  prefix: \"&8[&b&lSkyOrbs&8] &r\"\n  success: \"&a&l✓ &a{message}\"\n  error: \"&c&l✗ &c{message}\"\n  info: \"&e&l! &e{message}\"\n```\n\n### 4. **Sound Effects**\n```java\n// Gezegen oluşturulduğunda ses\nplayer.playSound(player.getLocation(), Sound.ENTITY_ENDER_DRAGON_GROWL, 1.0f, 1.0f);\n\n// Işınlanma sesi\nplayer.playSound(player.getLocation(), Sound.ENTITY_ENDERMAN_TELEPORT, 1.0f, 1.0f);\n```\n\n### 5. **Particle Effects**\n```java\n// Gezegen oluşurken particle\nworld.spawnParticle(Particle.PORTAL, location, 100, 5, 5, 5, 0.1);\n\n// Işınlanma particle\nplayer.getWorld().spawnParticle(Particle.DRAGON_BREATH, \n    player.getLocation(), 50, 1, 1, 1, 0.1);\n```\n\n---\n\n## 🔧 Kod Kalitesi İyileştirmeleri\n\n### 1. **Null Safety**\n```java\n// Önce:\npublic Orb getOrb(String name) {\n    return orbs.get(name); // null olabilir!\n}\n\n// Sonra:\npublic Optional<Orb> getOrb(String name) {\n    return Optional.ofNullable(orbs.get(name));\n}\n```\n\n### 2. **Constants**\n```java\n// Magic number'ları constant yap\npublic class Constants {\n    public static final int MIN_PLANET_RADIUS = 15;\n    public static final int MAX_PLANET_RADIUS = 100;\n    public static final int DEFAULT_PLANET_RADIUS = 35;\n    public static final double ORE_SCALE_FACTOR = 0.001;\n}\n```\n\n### 3. **Enum Usage**\n```java\n// String yerine enum kullan\npublic enum GenerationStatus {\n    QUEUED,\n    IN_PROGRESS,\n    COMPLETED,\n    FAILED,\n    CANCELLED\n}\n```\n\n### 4. **Builder Pattern**\n```java\n// Karmaşık objeler için builder\nOrb orb = new OrbBuilder()\n    .withName(\"MyPlanet\")\n    .withRadius(50)\n    .withBiome(BiomeType.LAVA_OCEAN)\n    .withShape(ShapeType.SPHERE)\n    .withModifiers(Modifier.HOLLOW, Modifier.ORE_RICH)\n    .build();\n```\n\n### 5. **Validation**\n```java\npublic class Validator {\n    public static void validateRadius(int radius) {\n        if (radius < MIN_RADIUS || radius > MAX_RADIUS) {\n            throw new IllegalArgumentException(\n                \"Radius must be between \" + MIN_RADIUS + \" and \" + MAX_RADIUS\n            );\n        }\n    }\n}\n```\n\n---\n\n## 📊 Monitoring İyileştirmeleri\n\n### 1. **Metrics Collection**\n```java\npublic class Metrics {\n    private long totalGenerations = 0;\n    private long totalGenerationTime = 0;\n    private long failedGenerations = 0;\n    \n    public void recordGeneration(long duration, boolean success) {\n        totalGenerations++;\n        totalGenerationTime += duration;\n        if (!success) failedGenerations++;\n    }\n    \n    public double getAverageGenerationTime() {\n        return (double) totalGenerationTime / totalGenerations;\n    }\n}\n```\n\n### 2. **Health Check**\n```java\npublic class HealthCheck {\n    public HealthStatus check() {\n        // Database connection\n        // Memory usage\n        // TPS\n        // Active generations\n        return new HealthStatus(...);\n    }\n}\n```\n\n---\n\n## 🎨 UI/UX İyileştirmeleri\n\n### 1. **Progress Bar**\n```\nGezegen Oluşturuluyor...\n[████████████░░░░░░░░] 60%\nMadenler yerleştiriliyor...\n```\n\n### 2. **Colored Output**\n```\n§a✓ Gezegen kabuğu tamamlandı!\n§e⚠ Ağaçlar dikiliyor...\n§c✗ Hata: Yetersiz alan!\n```\n\n### 3. **Hover Messages**\n```json\n{\n  \"text\": \"Gezegen-12345\",\n  \"hoverEvent\": {\n    \"action\": \"show_text\",\n    \"value\": \"Tıkla: Işınlan\\nShift+Tıkla: Bilgi\"\n  },\n  \"clickEvent\": {\n    \"action\": \"run_command\",\n    \"value\": \"/gezegen tp Gezegen-12345\"\n  }\n}\n```\n\n---\n\n## 🚀 Hemen Uygula!\n\nBu iyileştirmelerin çoğu **1-2 saatte** uygulanabilir ve **büyük fark** yaratır!\n\n### Başlangıç için:\n1. Generation Queue ekle (30 dakika)\n2. Teleport güvenliğini iyileştir (20 dakika)\n3. Sound effects ekle (10 dakika)\n4. Mesaj formatını güzelleştir (15 dakika)\n5. Constants ekle (15 dakika)\n\n**Toplam: ~90 dakika** ile plugin çok daha profesyonel olur! 🎉\n","size_bytes":7990},"src/main/java/com/skyorbs/shapes/impl/OctahedronShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class OctahedronShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        int manhattan = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n        return manhattan <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"OCTAHEDRON\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Sekizyüzlü\";\n    }\n}\n","size_bytes":604},"TODO.md":{"content":"# Ore Generation Fix - TODO\n\n- [x] Fix inconsistent distance checks in OreGenerator.java for solid planets\n- [x] Change generateOreType check from radius-2 to radius-1 to match generateVein\n- [x] Ensure ores spawn strictly inside planets, not on surface or outside\n\n## Summary\nFixed ore generation to ensure all ores form inside planets as part of the planet generation, not separately or outside.\n","size_bytes":398},"src/main/java/com/skyorbs/shapes/impl/KeyShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class KeyShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Anahtar şekli - bow, shank, bit\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Key bow (yuvarlak baş)\n        double bowCenterX = -0.6;\n        double bowCenterY = 0.3;\n        double bowDistance = Math.sqrt((x - bowCenterX)*(x - bowCenterX) + (y - bowCenterY)*(y - bowCenterY));\n        if (bowDistance <= 0.3) return true;\n\n        // Key shank (uzun kısım)\n        if (x >= -0.4 && x <= 0.4 && Math.abs(y) <= 0.1 && Math.abs(z) <= 0.05) return true;\n\n        // Key bit (dişler)\n        if (x >= 0.2 && x <= 0.6 && Math.abs(z) <= 0.05) {\n            // Alternating teeth\n            int toothIndex = (int)((x - 0.2) / 0.1);\n            double toothY = (toothIndex % 2 == 0) ? 0.0 : 0.15;\n            return Math.abs(y - toothY) <= 0.1;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"KEY\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Anahtar\";\n    }\n}","size_bytes":1482},"src/main/java/com/skyorbs/shapes/impl/TractorShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TractorShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Traktör şekli - body, wheels, exhaust, plow\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main body (ana gövde)\n        if (Math.abs(y) <= 0.15) {\n            return Math.abs(x) <= 0.4 && Math.abs(z) <= 0.3;\n        }\n\n        // Cabin (kabin)\n        if (y > 0.15 && y < 0.4 && Math.abs(x) <= 0.25) {\n            return Math.abs(z) <= 0.25;\n        }\n\n        // Large rear wheels (büyük arka tekerlekler)\n        double rearWheelRadius = 0.18;\n        if (x < -0.2) {\n            if (Math.abs(z - 0.25) <= rearWheelRadius && Math.abs(y + 0.15) <= rearWheelRadius) return true;\n            if (Math.abs(z + 0.25) <= rearWheelRadius && Math.abs(y + 0.15) <= rearWheelRadius) return true;\n        }\n\n        // Small front wheels (küçük ön tekerlekler)\n        double frontWheelRadius = 0.12;\n        if (x > 0.2) {\n            if (Math.abs(z - 0.2) <= frontWheelRadius && Math.abs(y + 0.15) <= frontWheelRadius) return true;\n            if (Math.abs(z + 0.2) <= frontWheelRadius && Math.abs(y + 0.15) <= frontWheelRadius) return true;\n        }\n\n        // Exhaust pipe (egzoz borusu)\n        if (Math.abs(x + 0.35) <= 0.05 && Math.abs(z) <= 0.03 && y > 0.4 && y < 0.6) {\n            return true;\n        }\n\n        // Plow attachment (saban eki)\n        if (x < -0.4 && Math.abs(y + 0.1) <= 0.08) {\n            return Math.abs(z) <= 0.4;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"TRACTOR\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Traktör\";\n    }\n}","size_bytes":2096},"src/main/java/com/skyorbs/features/StructureGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class StructureGenerator {\n    \n    public static List<OreGenerator.BlockData> generateStructures(Orb orb, BiomeType biome, World world) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n\n        // Hollow planets should only have trees, no structures\n        if (orb.getModifiers().contains(com.skyorbs.modifiers.PlanetModifier.HOLLOW)) {\n            return blocks;\n        }\n\n        // CONFIG KONTROLLÜ - Build sistemi aktif mi?\n        if (!com.skyorbs.SkyOrbs.getInstance().getConfig().getBoolean(\"buildings.enabled\", true)) {\n            return blocks;\n        }\n\n        // Get planet type from biome\n        PlanetType planetType = orb.getPlanetType();\n\n        Random random = new Random(orb.getSeed() + biome.name().hashCode());\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // CONFIG'DEN PLANET TYPE AYARLARINI OKU\n        String planetTypeKey = planetType.name().toLowerCase();\n        boolean planetEnabled = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getBoolean(\"buildings.planetTypes.\" + planetTypeKey + \".enabled\", true);\n\n        if (!planetEnabled) return blocks;\n\n        double baseDensity = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(\"buildings.densityMultiplier\", 0.02);\n        double planetMultiplier = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(\"buildings.planetTypes.\" + planetTypeKey + \".densityMultiplier\", 1.0);\n\n        int structureCount = (int)(radius * baseDensity * planetMultiplier);\n\n        for (int i = 0; i < structureCount; i++) {\n            // Generate positions biased towards planet center\n            int x, z;\n            int attempts = 0;\n            do {\n                x = cx + random.nextInt(radius * 2) - radius;\n                z = cz + random.nextInt(radius * 2) - radius;\n                attempts++;\n                // Bias towards center - only accept positions within 60% of radius from center\n            } while (Math.sqrt((x - cx) * (x - cx) + (z - cz) * (z - cz)) > radius * 0.6 && attempts < 10);\n\n            // Find actual surface level within planet bounds\n            int y = findSurfaceLevelWithinPlanet(cx, cy, cz, x, z, radius, random);\n            if (y == -1) continue; // No surface found, skip this structure\n\n            // CONFIG'DEN YAPILARI SEÇ - Gezegen türüne göre\n            BuildingType type = getBuildingTypeFromConfig(planetType, random);\n\n            // Generate the structure - DEBUG: Her yapı için mesaj\n            com.skyorbs.SkyOrbs.getInstance().getLogger().info(\"Generating building: \" + type + \" for planet type: \" + planetType + \" at \" + x + \",\" + y + \",\" + z);\n            generateBuilding(blocks, x, y, z, type, random, biome, planetType);\n        }\n\n        return blocks;\n    }\n    \n    /**\n     * Generate a single building with planet-specific variations\n     */\n    private static void generateBuilding(List<OreGenerator.BlockData> blocks, int x, int y, int z,\n                                         BuildingType type, Random random, BiomeType biome, PlanetType planetType) {\n\n        switch (type) {\n            case VILLAGE -> generateVillageHouse(blocks, x, y, z, random, biome, planetType);\n            case CASTLE -> generateCastle(blocks, x, y, z, random, biome, planetType);\n            case TEMPLE -> generateTemple(blocks, x, y, z, random, biome, planetType);\n            case RUINS -> generateRuins(blocks, x, y, z, random, biome, planetType);\n            case CRYSTAL_TOWER -> generateCrystalTower(blocks, x, y, z, random, biome, planetType);\n            case ARCANE_LIBRARY -> generateArcaneLibrary(blocks, x, y, z, random, biome, planetType);\n            case CRYSTAL_PALACE -> generateCrystalPalace(blocks, x, y, z, random, biome, planetType);\n            case FORTRESS -> generateFortress(blocks, x, y, z, random, biome, planetType);\n            case LAVA_TEMPLE -> generateLavaTemple(blocks, x, y, z, random, biome, planetType);\n            case ICE_PALACE -> generateIcePalace(blocks, x, y, z, random, biome, planetType);\n            case IGLOO_VILLAGE -> generateIglooVillage(blocks, x, y, z, random, biome, planetType);\n            case DARK_TOWER -> generateDarkTower(blocks, x, y, z, random, biome, planetType);\n            case SHADOW_TEMPLE -> generateShadowTemple(blocks, x, y, z, random, biome, planetType);\n            case LAB -> generateLab(blocks, x, y, z, random, biome, planetType);\n            case QUARANTINE_ZONE -> generateQuarantineZone(blocks, x, y, z, random, biome, planetType);\n        }\n    }\n    \n    /**\n     * Desert temple with biome-specific variations\n     */\n    private static void generateDesertTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Temel (9x9)\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.SANDSTONE));\n            }\n        }\n        \n        // Duvarlar\n        for (int dy = 1; dy <= 5; dy++) {\n            for (int dx = -4; dx <= 4; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 4, Material.SANDSTONE));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 4, Material.SANDSTONE));\n            }\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 4, y + dy, z + dz, Material.SANDSTONE));\n                blocks.add(new OreGenerator.BlockData(x + 4, y + dy, z + dz, Material.SANDSTONE));\n            }\n        }\n        \n        // Çatı\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 6, z + dz, Material.ORANGE_TERRACOTTA));\n            }\n        }\n        \n        // Hazine odası (yeraltı)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y - 3, z + dz, Material.STONE_BRICKS));\n            }\n        }\n        \n        // Treasure chest with biome-specific loot\n        blocks.add(new OreGenerator.BlockData(x, y - 2, z, Material.CHEST));\n\n        // Biome-specific traps and decorations\n        if (biome == BiomeType.TOXIC_SWAMP || biome == BiomeType.TOXIC) {\n            // Toxic biome - poison traps\n            blocks.add(new OreGenerator.BlockData(x + 1, y - 2, z + 1, Material.POISONOUS_POTATO));\n            blocks.add(new OreGenerator.BlockData(x - 1, y - 2, z - 1, Material.POISONOUS_POTATO));\n        } else {\n            // Standard traps\n            blocks.add(new OreGenerator.BlockData(x + 1, y - 2, z + 1, Material.TNT));\n            blocks.add(new OreGenerator.BlockData(x - 1, y - 2, z - 1, Material.TNT));\n        }\n    }\n    \n    /**\n     * Orman tapınağı\n     */\n    private static void generateJungleTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Piramit tabanı (11x11)\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.MOSSY_COBBLESTONE));\n            }\n        }\n        \n        // Piramit katları\n        for (int level = 1; level <= 6; level++) {\n            int size = 6 - level;\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    Material mat = random.nextBoolean() ? Material.MOSSY_COBBLESTONE : Material.COBBLESTONE;\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + level, z + dz, mat));\n                }\n            }\n        }\n        \n        // Hazine sandığı\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.CHEST));\n        \n        // Asma yapraklar\n        for (int i = 0; i < 10; i++) {\n            int vineX = x + random.nextInt(11) - 5;\n            int vineZ = z + random.nextInt(11) - 5;\n            int vineLength = 2 + random.nextInt(4);\n            for (int vl = 0; vl < vineLength; vl++) {\n                blocks.add(new OreGenerator.BlockData(vineX, y + 7 - vl, vineZ, Material.VINE));\n            }\n        }\n    }\n    \n    /**\n     * Köy evi\n     */\n    private static void generateVillageHouse(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Temel (7x7)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.OAK_PLANKS));\n            }\n        }\n        \n        // Duvarlar\n        for (int dy = 1; dy <= 3; dy++) {\n            for (int dx = -3; dx <= 3; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 3, Material.OAK_LOG));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 3, Material.OAK_LOG));\n            }\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 3, y + dy, z + dz, Material.OAK_LOG));\n                blocks.add(new OreGenerator.BlockData(x + 3, y + dy, z + dz, Material.OAK_LOG));\n            }\n        }\n        \n        // Çatı\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 4, z + dz, Material.OAK_STAIRS));\n            }\n        }\n        \n        // Kapı\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z - 3, Material.OAK_DOOR));\n        blocks.add(new OreGenerator.BlockData(x, y + 2, z - 3, Material.OAK_DOOR));\n        \n        // İç mobilyalar\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.CRAFTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.RED_BED));\n    }\n    \n    /**\n     * İglo\n     */\n    private static void generateIgloo(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kubbe şekli (6x6 taban)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                double distance = Math.sqrt(dx * dx + dz * dz);\n                if (distance <= 3) {\n                    blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.SNOW_BLOCK));\n                    \n                    if (distance <= 2.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + 1, z + dz, Material.SNOW_BLOCK));\n                    }\n                    if (distance <= 1.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + 2, z + dz, Material.SNOW_BLOCK));\n                    }\n                }\n            }\n        }\n        \n        // Giriş\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z - 3, Material.AIR));\n        \n        // İçeride mobilya\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.FURNACE));\n        blocks.add(new OreGenerator.BlockData(x - 1, y + 1, z + 1, Material.CHEST));\n    }\n    \n    /**\n     * Nether kalesi\n     */\n    private static void generateNetherFortress(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Temel platform\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.NETHER_BRICKS));\n            }\n        }\n        \n        // Kuleler (4 köşe)\n        int[][] corners = {{-5, -5}, {5, -5}, {-5, 5}, {5, 5}};\n        for (int[] corner : corners) {\n            for (int dy = 1; dy <= 8; dy++) {\n                blocks.add(new OreGenerator.BlockData(x + corner[0], y + dy, z + corner[1], Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + corner[0] + (corner[0] > 0 ? -1 : 1), y + dy, z + corner[1], Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + corner[0], y + dy, z + corner[1] + (corner[1] > 0 ? -1 : 1), Material.NETHER_BRICKS));\n            }\n            // Kule tepesi\n            blocks.add(new OreGenerator.BlockData(x + corner[0], y + 9, z + corner[1], Material.NETHER_BRICK_FENCE));\n        }\n        \n        // Merkez yapı\n        for (int dy = 1; dy <= 5; dy++) {\n            for (int dx = -2; dx <= 2; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 2, Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 2, Material.NETHER_BRICKS));\n            }\n        }\n        \n        // Spawner\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.SPAWNER));\n        \n        // Lava dekorasyonu\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z, Material.LAVA));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z, Material.LAVA));\n    }\n    \n    /**\n     * End kulesi\n     */\n    private static void generateEndTower(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Yüksek kule (15 blok)\n        for (int dy = 0; dy <= 15; dy++) {\n            for (int dx = -2; dx <= 2; dx++) {\n                for (int dz = -2; dz <= 2; dz++) {\n                    if (Math.abs(dx) == 2 || Math.abs(dz) == 2) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, Material.END_STONE_BRICKS));\n                    }\n                }\n            }\n        }\n        \n        // Tepe kristali\n        blocks.add(new OreGenerator.BlockData(x, y + 16, z, Material.END_ROD));\n        blocks.add(new OreGenerator.BlockData(x, y + 17, z, Material.PURPUR_BLOCK));\n        \n        // Chorus bitkileri\n        for (int i = 0; i < 5; i++) {\n            int chX = x + random.nextInt(9) - 4;\n            int chZ = z + random.nextInt(9) - 4;\n            int height = 2 + random.nextInt(4);\n            for (int h = 0; h < height; h++) {\n                blocks.add(new OreGenerator.BlockData(chX, y + h, chZ, Material.CHORUS_PLANT));\n            }\n        }\n    }\n    \n    /**\n     * Kristal diken\n     */\n    private static void generateCrystalSpire(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        int height = 10 + random.nextInt(8);\n        \n        for (int dy = 0; dy < height; dy++) {\n            int size = Math.max(1, 3 - dy / 3);\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    Material mat = random.nextBoolean() ? Material.AMETHYST_BLOCK : Material.BUDDING_AMETHYST;\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, mat));\n                }\n            }\n        }\n        \n        // Parlayan tepe\n        blocks.add(new OreGenerator.BlockData(x, y + height, z, Material.SEA_LANTERN));\n    }\n    \n    /**\n     * Mantar kulübesi\n     */\n    private static void generateMushroomHut(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kök\n        blocks.add(new OreGenerator.BlockData(x, y, z, Material.MUSHROOM_STEM));\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.MUSHROOM_STEM));\n        blocks.add(new OreGenerator.BlockData(x, y + 2, z, Material.MUSHROOM_STEM));\n        \n        // Şapka\n        Material capMaterial = random.nextBoolean() ? Material.RED_MUSHROOM_BLOCK : Material.BROWN_MUSHROOM_BLOCK;\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 3, z + dz, capMaterial));\n            }\n        }\n    }\n    \n    /**\n     * Harabeler\n     */\n    private static void generateRuins(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Yarım duvarlar\n        for (int i = 0; i < 10; i++) {\n            int rX = x + random.nextInt(9) - 4;\n            int rZ = z + random.nextInt(9) - 4;\n            int height = 1 + random.nextInt(3);\n            \n            Material mat = random.nextBoolean() ? Material.STONE_BRICKS : Material.CRACKED_STONE_BRICKS;\n            for (int dy = 0; dy < height; dy++) {\n                blocks.add(new OreGenerator.BlockData(rX, y + dy, rZ, mat));\n            }\n        }\n        \n        // Sandık\n        blocks.add(new OreGenerator.BlockData(x, y, z, Material.CHEST));\n    }\n    \n    /**\n     * Sunak\n     */\n    private static void generateAltar(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Platform (5x5)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.QUARTZ_BLOCK));\n            }\n        }\n        \n        // Merkez sütun\n        for (int dy = 1; dy <= 3; dy++) {\n            blocks.add(new OreGenerator.BlockData(x, y + dy, z, Material.QUARTZ_PILLAR));\n        }\n        \n        // Ateş\n        blocks.add(new OreGenerator.BlockData(x, y + 4, z, Material.FIRE));\n        \n        // Köşe meşaleler\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z - 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z + 2, Material.TORCH));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.TORCH));\n    }\n    \n    /**\n     * Find surface level within planet bounds - ensures structures are placed on solid ground\n     */\n    private static int findSurfaceLevelWithinPlanet(int cx, int cy, int cz, int x, int z, int radius, Random random) {\n        // Start from top of planet and raycast downward to find first solid block\n        int searchStartY = cy + radius + 5;\n        int searchEndY = cy - radius;\n\n        for (int y = searchStartY; y >= searchEndY; y--) {\n            // Check if position is within planet bounds\n            double distanceFromCenter = Math.sqrt(\n                (x - cx) * (x - cx) +\n                (y - cy) * (y - cy) +\n                (z - cz) * (z - cz)\n            );\n\n            // Must be on or near surface (within 3 blocks of radius)\n            if (distanceFromCenter >= radius - 3 && distanceFromCenter <= radius + 1) {\n                return y; // Found surface level\n            }\n        }\n\n        return -1; // No suitable surface found\n    }\n\n    /**\n     * CONFIG'DEN BUILDING TİPİ SEÇ - Gezegen türüne göre\n     */\n    private static BuildingType getBuildingTypeFromConfig(PlanetType planetType, Random random) {\n        String planetTypeKey = planetType.name().toLowerCase();\n        String configPath = \"buildings.planetTypes.\" + planetTypeKey + \".structures\";\n\n        // Config'den olasılıkları oku\n        double villageProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".village\", 0.0);\n        double castleProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".castle\", 0.0);\n        double templeProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".temple\", 0.0);\n        double ruinsProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".ruins\", 0.0);\n        double crystalTowerProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".crystal_tower\", 0.0);\n        double arcaneLibraryProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".arcane_library\", 0.0);\n        double crystalPalaceProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".crystal_palace\", 0.0);\n        double fortressProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".fortress\", 0.0);\n        double lavaTempleProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".lava_temple\", 0.0);\n        double icePalaceProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".ice_palace\", 0.0);\n        double iglooVillageProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".igloo_village\", 0.0);\n        double darkTowerProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".dark_tower\", 0.0);\n        double shadowTempleProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".shadow_temple\", 0.0);\n        double labProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".lab\", 0.0);\n        double quarantineZoneProb = com.skyorbs.SkyOrbs.getInstance().getConfig()\n            .getDouble(configPath + \".quarantine_zone\", 0.0);\n\n        // Weighted random selection\n        double rand = random.nextDouble();\n        double total = 0;\n\n        if ((total += villageProb) > rand) return BuildingType.VILLAGE;\n        if ((total += castleProb) > rand) return BuildingType.CASTLE;\n        if ((total += templeProb) > rand) return BuildingType.TEMPLE;\n        if ((total += ruinsProb) > rand) return BuildingType.RUINS;\n        if ((total += crystalTowerProb) > rand) return BuildingType.CRYSTAL_TOWER;\n        if ((total += arcaneLibraryProb) > rand) return BuildingType.ARCANE_LIBRARY;\n        if ((total += crystalPalaceProb) > rand) return BuildingType.CRYSTAL_PALACE;\n        if ((total += fortressProb) > rand) return BuildingType.FORTRESS;\n        if ((total += lavaTempleProb) > rand) return BuildingType.LAVA_TEMPLE;\n        if ((total += icePalaceProb) > rand) return BuildingType.ICE_PALACE;\n        if ((total += iglooVillageProb) > rand) return BuildingType.IGLOO_VILLAGE;\n        if ((total += darkTowerProb) > rand) return BuildingType.DARK_TOWER;\n        if ((total += shadowTempleProb) > rand) return BuildingType.SHADOW_TEMPLE;\n        if ((total += labProb) > rand) return BuildingType.LAB;\n        if ((total += quarantineZoneProb) > rand) return BuildingType.QUARANTINE_ZONE;\n\n        // Fallback\n        return BuildingType.RUINS;\n    }\n    \n    /**\n     * Building types - Gezegen türüne göre yapılar\n     */\n    public enum BuildingType {\n        // TERRESTRIAL\n        VILLAGE, CASTLE, TEMPLE, RUINS,\n\n        // CRYSTAL\n        CRYSTAL_TOWER, ARCANE_LIBRARY, CRYSTAL_PALACE,\n\n        // LAVA\n        FORTRESS, LAVA_TEMPLE,\n\n        // ICE\n        ICE_PALACE, IGLOO_VILLAGE,\n\n        // SHADOW\n        DARK_TOWER, SHADOW_TEMPLE,\n\n        // TOXIC\n        LAB, QUARANTINE_ZONE\n    }\n    \n    /**\n     * Yeni yapı generation metodları - Gezegen türüne göre\n     */\n    private static void generateCastle(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kale - büyük taş yapı\n        for (int dx = -6; dx <= 6; dx++) {\n            for (int dz = -6; dz <= 6; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.STONE_BRICKS));\n            }\n        }\n\n        // Kale duvarları\n        for (int dy = 1; dy <= 8; dy++) {\n            for (int dx = -6; dx <= 6; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 6, Material.STONE_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 6, Material.STONE_BRICKS));\n            }\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 6, y + dy, z + dz, Material.STONE_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + 6, y + dy, z + dz, Material.STONE_BRICKS));\n            }\n        }\n\n        // Kale kuleleri\n        int[][] towers = {{-6, -6}, {6, -6}, {-6, 6}, {6, 6}};\n        for (int[] tower : towers) {\n            for (int dy = 9; dy <= 12; dy++) {\n                blocks.add(new OreGenerator.BlockData(x + tower[0], y + dy, z + tower[1], Material.STONE_BRICKS));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.CHEST)); // Hazine\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z, Material.CRAFTING_TABLE));\n    }\n\n    private static void generateTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Tapınak - kutsal yapı\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.QUARTZ_BLOCK));\n            }\n        }\n\n        // Tapınak sütunları\n        for (int i = 0; i < 4; i++) {\n            int colX = x + (i % 2 == 0 ? -3 : 3);\n            int colZ = z + (i < 2 ? -3 : 3);\n            for (int dy = 1; dy <= 6; dy++) {\n                blocks.add(new OreGenerator.BlockData(colX, y + dy, colZ, Material.QUARTZ_PILLAR));\n            }\n        }\n\n        // Çatı\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 7, z + dz, Material.QUARTZ_STAIRS));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 1, y + 1, z + 1, Material.BOOKSHELF));\n        blocks.add(new OreGenerator.BlockData(x - 1, y + 1, z - 1, Material.CHEST));\n    }\n\n    private static void generateCrystalTower(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kristal kule - yüksek ve parlak\n        int height = 15 + random.nextInt(10);\n        for (int dy = 0; dy < height; dy++) {\n            int size = Math.max(1, 4 - dy / 4);\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    Material mat = random.nextBoolean() ? Material.AMETHYST_BLOCK : Material.BUDDING_AMETHYST;\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, mat));\n                }\n            }\n        }\n\n        // Tepe kristali\n        blocks.add(new OreGenerator.BlockData(x, y + height, z, Material.SEA_LANTERN));\n        blocks.add(new OreGenerator.BlockData(x, y + height + 1, z, Material.AMETHYST_CLUSTER));\n    }\n\n    private static void generateArcaneLibrary(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Büyü kütüphanesi - kitaplar ve büyü eşyaları\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.BOOKSHELF));\n            }\n        }\n\n        // İç duvarlar\n        for (int dy = 1; dy <= 4; dy++) {\n            for (int dx = -5; dx <= 5; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 5, Material.OAK_PLANKS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 5, Material.OAK_PLANKS));\n            }\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 5, y + dy, z + dz, Material.OAK_PLANKS));\n                blocks.add(new OreGenerator.BlockData(x + 5, y + dy, z + dz, Material.OAK_PLANKS));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.BREWING_STAND));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.CHEST));\n    }\n\n    private static void generateCrystalPalace(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kristal saray - büyük ve görkemli\n        for (int dx = -8; dx <= 8; dx++) {\n            for (int dz = -8; dz <= 8; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.PURPUR_BLOCK));\n            }\n        }\n\n        // Kristal sütunları\n        for (int i = 0; i < 8; i++) {\n            double angle = (i * Math.PI * 2) / 8;\n            int colX = x + (int)(Math.cos(angle) * 6);\n            int colZ = z + (int)(Math.sin(angle) * 6);\n            for (int dy = 1; dy <= 8; dy++) {\n                blocks.add(new OreGenerator.BlockData(colX, y + dy, colZ, Material.AMETHYST_BLOCK));\n            }\n        }\n\n        // Çatı\n        for (int dx = -6; dx <= 6; dx++) {\n            for (int dz = -6; dz <= 6; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 9, z + dz, Material.SEA_LANTERN));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 3, y + 1, z, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x - 3, y + 1, z, Material.CHEST));\n    }\n\n    private static void generateFortress(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Kale - lav gezegenleri için\n        for (int dx = -7; dx <= 7; dx++) {\n            for (int dz = -7; dz <= 7; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.NETHER_BRICKS));\n            }\n        }\n\n        // Kale duvarları\n        for (int dy = 1; dy <= 6; dy++) {\n            for (int dx = -7; dx <= 7; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 7, Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 7, Material.NETHER_BRICKS));\n            }\n            for (int dz = -6; dz <= 6; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 7, y + dy, z + dz, Material.NETHER_BRICKS));\n                blocks.add(new OreGenerator.BlockData(x + 7, y + dy, z + dz, Material.NETHER_BRICKS));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z, Material.LAVA));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z, Material.ANCIENT_DEBRIS));\n    }\n\n    private static void generateLavaTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Lava tapınağı\n        for (int dx = -5; dx <= 5; dx++) {\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.MAGMA_BLOCK));\n            }\n        }\n\n        // Lava sütunları\n        for (int i = 0; i < 4; i++) {\n            int colX = x + (i % 2 == 0 ? -4 : 4);\n            int colZ = z + (i < 2 ? -4 : 4);\n            for (int dy = 1; dy <= 5; dy++) {\n                blocks.add(new OreGenerator.BlockData(colX, y + dy, colZ, Material.OBSIDIAN));\n            }\n            blocks.add(new OreGenerator.BlockData(colX, y + 6, colZ, Material.LAVA));\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 1, y + 1, z + 1, Material.CHEST));\n    }\n\n    private static void generateIcePalace(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Buz sarayı\n        for (int dx = -6; dx <= 6; dx++) {\n            for (int dz = -6; dz <= 6; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.PACKED_ICE));\n            }\n        }\n\n        // Buz sütunları\n        for (int i = 0; i < 6; i++) {\n            double angle = (i * Math.PI * 2) / 6;\n            int colX = x + (int)(Math.cos(angle) * 4);\n            int colZ = z + (int)(Math.sin(angle) * 4);\n            for (int dy = 1; dy <= 7; dy++) {\n                blocks.add(new OreGenerator.BlockData(colX, y + dy, colZ, Material.ICE));\n            }\n        }\n\n        // Çatı\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + 8, z + dz, Material.SNOW_BLOCK));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.CHEST));\n    }\n\n    private static void generateIglooVillage(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // İglo köyü - birden fazla iglo\n        for (int i = 0; i < 3; i++) {\n            int iglooX = x + random.nextInt(11) - 5;\n            int iglooZ = z + random.nextInt(11) - 5;\n\n            // Küçük iglo\n            for (int dx = -2; dx <= 2; dx++) {\n                for (int dz = -2; dz <= 2; dz++) {\n                    double distance = Math.sqrt(dx * dx + dz * dz);\n                    if (distance <= 2) {\n                        blocks.add(new OreGenerator.BlockData(iglooX + dx, y, iglooZ + dz, Material.SNOW_BLOCK));\n                        if (distance <= 1.5) {\n                            blocks.add(new OreGenerator.BlockData(iglooX + dx, y + 1, iglooZ + dz, Material.SNOW_BLOCK));\n                        }\n                    }\n                }\n            }\n\n            // İç mekan\n            blocks.add(new OreGenerator.BlockData(iglooX, y + 1, iglooZ, Material.FURNACE));\n        }\n    }\n\n    private static void generateDarkTower(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Karanlık kule\n        int height = 20 + random.nextInt(10);\n        for (int dy = 0; dy < height; dy++) {\n            int size = Math.max(1, 3 - dy / 6);\n            for (int dx = -size; dx <= size; dx++) {\n                for (int dz = -size; dz <= size; dz++) {\n                    blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + dz, Material.OBSIDIAN));\n                }\n            }\n        }\n\n        // Tepe\n        blocks.add(new OreGenerator.BlockData(x, y + height, z, Material.END_ROD));\n        blocks.add(new OreGenerator.BlockData(x, y + height + 1, z, Material.CHEST));\n    }\n\n    private static void generateShadowTemple(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Gölge tapınağı\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.OBSIDIAN));\n            }\n        }\n\n        // Gölge sütunları\n        for (int i = 0; i < 4; i++) {\n            int colX = x + (i % 2 == 0 ? -3 : 3);\n            int colZ = z + (i < 2 ? -3 : 3);\n            for (int dy = 1; dy <= 6; dy++) {\n                blocks.add(new OreGenerator.BlockData(colX, y + dy, colZ, Material.CRYING_OBSIDIAN));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x + 1, y + 1, z + 1, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x, y + 2, z, Material.SOUL_LANTERN));\n    }\n\n    private static void generateLab(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Laboratuvar\n        for (int dx = -4; dx <= 4; dx++) {\n            for (int dz = -4; dz <= 4; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.GREEN_CONCRETE));\n            }\n        }\n\n        // Laboratuvar duvarları\n        for (int dy = 1; dy <= 4; dy++) {\n            for (int dx = -4; dx <= 4; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 4, Material.GLASS));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 4, Material.GLASS));\n            }\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 4, y + dy, z + dz, Material.GLASS));\n                blocks.add(new OreGenerator.BlockData(x + 4, y + dy, z + dz, Material.GLASS));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.BREWING_STAND));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z + 2, Material.CRAFTING_TABLE));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z - 2, Material.CHEST));\n    }\n\n    private static void generateQuarantineZone(List<OreGenerator.BlockData> blocks, int x, int y, int z, Random random, BiomeType biome, PlanetType planetType) {\n        // Karantina bölgesi\n        for (int dx = -6; dx <= 6; dx++) {\n            for (int dz = -6; dz <= 6; dz++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.GREEN_WOOL));\n            }\n        }\n\n        // Çit\n        for (int dy = 1; dy <= 3; dy++) {\n            for (int dx = -6; dx <= 6; dx++) {\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 6, Material.OAK_FENCE));\n                blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 6, Material.OAK_FENCE));\n            }\n            for (int dz = -5; dz <= 5; dz++) {\n                blocks.add(new OreGenerator.BlockData(x - 6, y + dy, z + dz, Material.OAK_FENCE));\n                blocks.add(new OreGenerator.BlockData(x + 6, y + dy, z + dz, Material.OAK_FENCE));\n            }\n        }\n\n        // İç mekan\n        blocks.add(new OreGenerator.BlockData(x, y + 1, z, Material.CHEST));\n        blocks.add(new OreGenerator.BlockData(x + 2, y + 1, z, Material.POISONOUS_POTATO));\n        blocks.add(new OreGenerator.BlockData(x - 2, y + 1, z, Material.SPIDER_EYE));\n    }\n}","size_bytes":38824},"src/main/java/com/skyorbs/shapes/impl/SkullShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SkullShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kafatası şekli - cranium, eye sockets, nasal cavity, teeth\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main cranium (round head shape)\n        double craniumRadius = Math.sqrt(x*x + y*y + z*z);\n        if (craniumRadius <= 0.8) {\n            // Eye sockets\n            if (y > 0.1 && y < 0.4) {\n                if ((Math.abs(x - 0.25) <= 0.15 && Math.abs(z) <= 0.1) ||\n                    (Math.abs(x + 0.25) <= 0.15 && Math.abs(z) <= 0.1)) {\n                    return false; // Hollow eye sockets\n                }\n            }\n\n            // Nasal cavity\n            if (y > -0.1 && y < 0.2 && Math.abs(x) <= 0.1 && z > 0.1) {\n                return false; // Nose hole\n            }\n\n            // Teeth (bottom jaw)\n            if (y < -0.3) {\n                for (int i = -2; i <= 2; i++) {\n                    double toothX = i * 0.15;\n                    if (Math.abs(x - toothX) <= 0.05 && z > 0.2) {\n                        return true; // Teeth protrude\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SKULL\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kafatası\";\n    }\n}","size_bytes":1797},"src/main/java/com/skyorbs/shapes/impl/SubmarineShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SubmarineShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Denizaltı şekli - hull, conning tower, propellers\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main hull (ana gövde) - silindir\n        if (Math.abs(y) <= 0.15) {\n            return Math.sqrt(x*x + z*z) <= 0.4;\n        }\n\n        // Nose cone (burun)\n        if (x > 0.3) {\n            double noseRadius = 0.4 - (x - 0.3) * 2;\n            return Math.sqrt((x - 0.3)*(x - 0.3) + y*y + z*z) <= noseRadius;\n        }\n\n        // Tail cone (kuyruk)\n        if (x < -0.3) {\n            double tailRadius = 0.4 + (x + 0.3) * 2;\n            return Math.sqrt((x + 0.3)*(x + 0.3) + y*y + z*z) <= tailRadius;\n        }\n\n        // Conning tower (köprü)\n        if (Math.abs(x) <= 0.2 && y > 0.15 && y < 0.4) {\n            return Math.abs(z) <= 0.15;\n        }\n\n        // Propellers (pervaneler)\n        if (x < -0.4) {\n            double propRadius = 0.12;\n            // Top propeller\n            if (Math.abs(y - 0.08) <= propRadius && Math.abs(z) <= propRadius) return true;\n            // Bottom propeller\n            if (Math.abs(y + 0.08) <= propRadius && Math.abs(z) <= propRadius) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SUBMARINE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Denizaltı\";\n    }\n}","size_bytes":1853},"src/main/java/com/skyorbs/commands/GezegenCommand.java":{"content":"package com.skyorbs.commands;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.command.*;\nimport org.bukkit.entity.Player;\n\nimport java.sql.SQLException;\nimport java.util.*;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.features.OreGenerator;\n\npublic class GezegenCommand implements CommandExecutor, TabCompleter {\n    \n    private final SkyOrbs plugin;\n    \n    public GezegenCommand(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    @Override\n    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {\n        if (args.length == 0) {\n            sendHelp(sender);\n            return true;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"create\", \"oluştur\" -> handleCreate(sender, args);\n            case \"list\", \"liste\" -> handleList(sender);\n            case \"tp\", \"teleport\", \"ışınlan\" -> handleTeleport(sender, args);\n            case \"sil\", \"delete\" -> handleDelete(sender, args);\n            case \"info\", \"bilgi\" -> handleInfo(sender, args);\n            case \"reload\", \"yenile\" -> handleReload(sender);\n            case \"test\", \"debug\" -> handleTest(sender);\n            case \"oreconfig\", \"ore\" -> handleOreConfig(sender, args);\n            case \"config\", \"ayar\" -> handleConfig(sender, args);\n            default -> sendHelp(sender);\n        }\n\n        return true;\n    }\n    \n    private void handleCreate(CommandSender sender, String[] args) {\n        if (!sender.hasPermission(\"skyorbs.create\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n\n        if (!(sender instanceof Player player)) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"playerOnly\"));\n            return;\n        }\n\n        // ŞEKİL BELİRTİLMİŞ Mİ KONTROL ET\n        String shapeName = null;\n        if (args.length > 1) {\n            shapeName = args[1].toUpperCase();\n            // Geçerli şekil mi kontrol et\n            if (!plugin.getShapeRegistry().getShapeNames().contains(shapeName)) {\n                sender.sendMessage(\"§cGeçersiz şekil: \" + shapeName);\n                sender.sendMessage(\"§7Mevcut şekiller: \" + String.join(\", \", plugin.getShapeRegistry().getShapeNames()));\n                return;\n            }\n        }\n\n        // YER BULUNAMAZSA UYARI VER\n        player.sendMessage(\"§eGezegen oluşturuluyor... Eğer uygun yer bulunamazsa config'den mesafeleri ayarlayın!\");\n        player.sendMessage(\"§7Mevcut ayarlar: Max mesafe \" + plugin.getConfigManager().getMaxDistance() +\n                          \", Min mesafe \" + plugin.getConfigManager().getMinDistanceFromSpawn());\n\n        World world = player.getWorld();\n        plugin.getGenerationManager().createPlanetAsync(world, player, shapeName);\n    }\n    \n    private void handleList(CommandSender sender) {\n        try {\n            List<Orb> orbs = plugin.getDatabaseManager().getAllOrbs();\n            \n            if (orbs.isEmpty()) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"listEmpty\"));\n                return;\n            }\n            \n            sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"listHeader\")\n                .replace(\"{count}\", String.valueOf(orbs.size())));\n            \n            for (Orb orb : orbs) {\n                String shapeName = plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName();\n                double distFromSpawn = orb.getDistanceFromSpawn();\n                \n                sender.sendMessage(String.format(\"§e%s §7- §f%s §7| §f%d,%d,%d §7(Spawn'dan §f%.0f §7blok)\",\n                    orb.getName(), shapeName, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ(), distFromSpawn));\n            }\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleTeleport(CommandSender sender, String[] args) {\n        if (!(sender instanceof Player player)) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"playerOnly\"));\n            return;\n        }\n        \n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen tp <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            World world = Bukkit.getWorld(orb.getWorldName());\n            if (world == null) {\n                sender.sendMessage(\"§cGezegen dünyası bulunamadı!\");\n                return;\n            }\n            \n            Location loc = new Location(world, orb.getCenterX(), orb.getCenterY() + orb.getRadius() + 10, orb.getCenterZ());\n            player.teleport(loc);\n            \n            sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"teleported\")\n                .replace(\"{name}\", orb.getName()));\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleDelete(CommandSender sender, String[] args) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n        \n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen sil <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            sender.sendMessage(\"§eGezegen siliniyor...\");\n            \n            plugin.getGenerationManager().deletePlanet(orb)\n                .thenRun(() -> {\n                    sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetDeleted\")\n                        .replace(\"{name}\", orb.getName()));\n                });\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleInfo(CommandSender sender, String[] args) {\n        if (args.length < 2) {\n            sender.sendMessage(\"§cKullanım: /gezegen info <gezegen-ismi>\");\n            return;\n        }\n        \n        String name = args[1];\n        \n        try {\n            Orb orb = plugin.getDatabaseManager().getOrbByName(name);\n            \n            if (orb == null) {\n                sender.sendMessage(plugin.getConfigManager().getMessageRaw(\"planetNotFound\")\n                    .replace(\"{name}\", name));\n                return;\n            }\n            \n            List<Orb> allOrbs = plugin.getDatabaseManager().getAllOrbs();\n            \n            sender.sendMessage(\"§b═══ Gezegen Bilgileri ═══\");\n            sender.sendMessage(\"§7İsim: §e\" + orb.getName());\n            sender.sendMessage(\"§7Şekil: §f\" + plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName());\n            sender.sendMessage(\"§7Biyom: §f\" + orb.getBiomeName());\n            sender.sendMessage(\"§7Yarıçap: §f\" + orb.getRadius() + \" blok\");\n            sender.sendMessage(\"§7Merkez: §f\" + orb.getCenterX() + \", \" + orb.getCenterY() + \", \" + orb.getCenterZ());\n            sender.sendMessage(\"§7Spawn'dan Uzaklık: §f\" + String.format(\"%.0f\", orb.getDistanceFromSpawn()) + \" blok\");\n            \n            sender.sendMessage(\"§7Yakındaki Gezegenler:\");\n            int nearbyCount = 0;\n            for (Orb other : allOrbs) {\n                if (!other.getId().equals(orb.getId())) {\n                    double distance = orb.getDistanceFrom(other.getCenterX(), other.getCenterZ());\n                    if (distance < 3000 && nearbyCount < 5) {\n                        sender.sendMessage(String.format(\"  §8• §e%s §7- §f%.0f blok uzakta\", other.getName(), distance));\n                        nearbyCount++;\n                    }\n                }\n            }\n            \n            if (nearbyCount == 0) {\n                sender.sendMessage(\"  §7(Yakında gezegen yok)\");\n            }\n            \n        } catch (SQLException e) {\n            sender.sendMessage(\"§cVeritabanı hatası!\");\n        }\n    }\n    \n    private void handleReload(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"noPermission\"));\n            return;\n        }\n\n        sender.sendMessage(\"§eConfig yeniden yükleniyor...\");\n\n        try {\n            plugin.reloadPluginConfig();\n            sender.sendMessage(plugin.getConfigManager().getMessage(\"configReloaded\"));\n\n            // Debug: Shape weights'i göster\n            Map<String, Double> weights = plugin.getConfigManager().getShapeWeights();\n            sender.sendMessage(\"§aYüklenen şekil sayısı: §e\" + weights.size());\n\n        } catch (Exception e) {\n            sender.sendMessage(\"§cConfig yüklenemedi! Konsolu kontrol edin.\");\n            plugin.logError(\"Config reload failed\", e);\n        }\n    }\n\n    private void handleOreConfig(CommandSender sender, String[] args) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(\"§cYetkiniz yok!\");\n            return;\n        }\n\n        if (args.length < 2) {\n            sendOreConfigHelp(sender);\n            return;\n        }\n\n        String subCommand = args[1].toLowerCase();\n\n        switch (subCommand) {\n            case \"list\" -> handleOreConfigList(sender, args);\n            case \"set\" -> handleOreConfigSet(sender, args);\n            case \"enable\" -> handleOreConfigEnable(sender, args);\n            case \"disable\" -> handleOreConfigDisable(sender, args);\n            case \"multiplier\" -> handleOreConfigMultiplier(sender, args);\n            case \"reset\" -> handleOreConfigReset(sender, args);\n            default -> sendOreConfigHelp(sender);\n        }\n    }\n\n    private void handleOreConfigList(CommandSender sender, String[] args) {\n        sender.sendMessage(\"§b═══ Gezegen Tipi Ore Konfigürasyonları ═══\");\n\n        Set<String> planetTypes = plugin.getConfigManager().getConfiguredPlanetTypes();\n        if (planetTypes.isEmpty()) {\n            sender.sendMessage(\"§7Konfigüre edilmiş gezegen tipi yok.\");\n            return;\n        }\n\n        for (String planetType : planetTypes) {\n            Map<String, Object> config = plugin.getConfigManager().getOreConfigForPlanetType(planetType);\n            boolean enabled = (Boolean) config.getOrDefault(\"enabled\", true);\n            double multiplier = (Double) config.getOrDefault(\"densityMultiplier\", 1.0);\n\n            sender.sendMessage(String.format(\"§e%s §7- %s §7| Çarpan: §f%.1fx\",\n                planetType.toUpperCase(),\n                enabled ? \"§aAktif\" : \"§cPasif\",\n                multiplier));\n\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Map<String, Object>> ores = (Map<String, Map<String, Object>>) config.get(\"ores\");\n            if (ores != null && !ores.isEmpty()) {\n                sender.sendMessage(\"§7  Madenler:\");\n                ores.forEach((oreName, oreConfig) -> {\n                    boolean oreEnabled = (Boolean) oreConfig.getOrDefault(\"enabled\", true);\n                    double chance = (Double) oreConfig.getOrDefault(\"chance\", 0.0);\n                    int minVein = (Integer) oreConfig.getOrDefault(\"minVein\", 1);\n                    int maxVein = (Integer) oreConfig.getOrDefault(\"maxVein\", 1);\n\n                    sender.sendMessage(String.format(\"    §8• §f%s §7- %s §7| Şans: §e%.3f §7| Damar: §e%d-%d\",\n                        oreName, oreEnabled ? \"§aAktif\" : \"§cPasif\", chance, minVein, maxVein));\n                });\n            }\n        }\n    }\n\n    private void handleOreConfigSet(CommandSender sender, String[] args) {\n        if (args.length < 6) {\n            sender.sendMessage(\"§cKullanım: /gezegen ore set <gezegen-tipi> <maden> <özellik> <değer>\");\n            sender.sendMessage(\"§7Örnek: /gezegen ore set terrestrial coal chance 0.5\");\n            return;\n        }\n\n        String planetType = args[2].toLowerCase();\n        String oreType = args[3].toLowerCase();\n        String property = args[4].toLowerCase();\n        String valueStr = args[5];\n\n        try {\n            Object value;\n            switch (property) {\n                case \"chance\" -> value = Double.parseDouble(valueStr);\n                case \"minvein\", \"maxvein\" -> value = Integer.parseInt(valueStr);\n                case \"enabled\" -> value = Boolean.parseBoolean(valueStr);\n                default -> {\n                    sender.sendMessage(\"§cGeçersiz özellik! Kullanılabilir: chance, minVein, maxVein, enabled\");\n                    return;\n                }\n            }\n\n            plugin.getConfigManager().setOreConfigForPlanetType(planetType, oreType, property, value);\n            sender.sendMessage(String.format(\"§a%s gezegeninde %s madeni için %s = %s olarak ayarlandı!\",\n                planetType.toUpperCase(), oreType.toUpperCase(), property, value));\n\n        } catch (NumberFormatException e) {\n            sender.sendMessage(\"§cGeçersiz sayı formatı!\");\n        }\n    }\n\n    private void handleOreConfigEnable(CommandSender sender, String[] args) {\n        if (args.length < 3) {\n            sender.sendMessage(\"§cKullanım: /gezegen ore enable <gezegen-tipi>\");\n            return;\n        }\n\n        String planetType = args[2].toLowerCase();\n        plugin.getConfigManager().setPlanetTypeOreEnabled(planetType, true);\n        sender.sendMessage(\"§a\" + planetType.toUpperCase() + \" gezegeninde ore üretimi aktifleştirildi!\");\n    }\n\n    private void handleOreConfigDisable(CommandSender sender, String[] args) {\n        if (args.length < 3) {\n            sender.sendMessage(\"§cKullanım: /gezegen ore disable <gezegen-tipi>\");\n            return;\n        }\n\n        String planetType = args[2].toLowerCase();\n        plugin.getConfigManager().setPlanetTypeOreEnabled(planetType, false);\n        sender.sendMessage(\"§c\" + planetType.toUpperCase() + \" gezegeninde ore üretimi devre dışı bırakıldı!\");\n    }\n\n    private void handleOreConfigMultiplier(CommandSender sender, String[] args) {\n        if (args.length < 4) {\n            sender.sendMessage(\"§cKullanım: /gezegen ore multiplier <gezegen-tipi> <çarpan>\");\n            return;\n        }\n\n        String planetType = args[2].toLowerCase();\n        try {\n            double multiplier = Double.parseDouble(args[3]);\n            plugin.getConfigManager().setPlanetTypeOreMultiplier(planetType, multiplier);\n            sender.sendMessage(String.format(\"§a%s gezegeninde ore yoğunluğu çarpanı %.1fx olarak ayarlandı!\",\n                planetType.toUpperCase(), multiplier));\n        } catch (NumberFormatException e) {\n            sender.sendMessage(\"§cGeçersiz çarpan değeri!\");\n        }\n    }\n\n    private void handleOreConfigReset(CommandSender sender, String[] args) {\n        if (args.length < 3) {\n            sender.sendMessage(\"§cKullanım: /gezegen ore reset <gezegen-tipi>\");\n            return;\n        }\n\n        String planetType = args[2].toLowerCase();\n        String path = \"features.ores.planetTypes.\" + planetType;\n        plugin.getConfig().set(path, null);\n        plugin.saveConfig();\n        sender.sendMessage(\"§e\" + planetType.toUpperCase() + \" gezegeninin ore konfigürasyonu sıfırlandı!\");\n    }\n\n    private void handleConfig(CommandSender sender, String[] args) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(\"§cYetkiniz yok!\");\n            return;\n        }\n\n        if (args.length < 2) {\n            sendConfigHelp(sender);\n            return;\n        }\n\n        String subCommand = args[1].toLowerCase();\n\n        switch (subCommand) {\n            case \"list\" -> handleConfigList(sender, args);\n            case \"set\" -> handleConfigSet(sender, args);\n            case \"reset\" -> handleConfigReset(sender, args);\n            case \"reload\" -> handleConfigReload(sender);\n            case \"save\" -> handleConfigSave(sender);\n            case \"backup\" -> handleConfigBackup(sender);\n            default -> sendConfigHelp(sender);\n        }\n    }\n\n    private void handleConfigList(CommandSender sender, String[] args) {\n        sender.sendMessage(\"§b═══ Sistem Konfigürasyonları ═══\");\n\n        // Generation settings\n        sender.sendMessage(\"§e1. GEZEGEN BOYUTU:\");\n        sender.sendMessage(\"  • Min yarıçap: §a\" + plugin.getConfigManager().getMinRadius());\n        sender.sendMessage(\"  • Max yarıçap: §a\" + plugin.getConfigManager().getMaxRadius());\n        sender.sendMessage(\"  • Ortalama yarıçap: §a\" + plugin.getConfigManager().getAverageRadius());\n\n        // Placement settings\n        sender.sendMessage(\"§e2. YERLEŞTİRME:\");\n        sender.sendMessage(\"  • Max uzaklık: §a\" + plugin.getConfigManager().getMaxDistance());\n        sender.sendMessage(\"  • Kümeleme aktif: §a\" + (plugin.getConfigManager().isClusteringEnabled() ? \"Evet\" : \"Hayır\"));\n        sender.sendMessage(\"  • Küme min uzaklık: §a\" + plugin.getConfigManager().getClusterMinDistance());\n        sender.sendMessage(\"  • Küme max uzaklık: §a\" + plugin.getConfigManager().getClusterMaxDistance());\n\n        // Performance settings\n        sender.sendMessage(\"§e3. PERFORMANS:\");\n        sender.sendMessage(\"  • Batch boyutu: §a\" + plugin.getConfigManager().getBlocksPerBatch());\n        sender.sendMessage(\"  • Tick başına batch: §a\" + plugin.getConfigManager().getBatchesPerTick());\n        sender.sendMessage(\"  • Shell kalınlığı: §a\" + plugin.getConfigManager().getShellThickness());\n\n        // Feature settings\n        sender.sendMessage(\"§e4. ÖZELLİKLER:\");\n        sender.sendMessage(\"  • Ore üretimi: §a\" + (plugin.getConfigManager().isOreGenerationEnabled() ? \"Aktif\" : \"Pasif\"));\n        sender.sendMessage(\"  • Ağaç üretimi: §a\" + (plugin.getConfigManager().isTreeGenerationEnabled() ? \"Aktif\" : \"Pasif\"));\n        sender.sendMessage(\"  • Yapı üretimi: §a\" + (plugin.getConfigManager().isStructureGenerationEnabled() ? \"Aktif\" : \"Pasif\"));\n        sender.sendMessage(\"  • Hazine üretimi: §a\" + (plugin.getConfigManager().isTreasureGenerationEnabled() ? \"Aktif\" : \"Pasif\"));\n        sender.sendMessage(\"  • Asteroid üretimi: §a\" + (plugin.getConfigManager().isAsteroidsEnabled() ? \"Aktif\" : \"Pasif\"));\n\n        // Limits\n        sender.sendMessage(\"§e5. LİMİTLER:\");\n        sender.sendMessage(\"  • Oyuncu başına gezegen: §a\" + plugin.getConfigManager().getPlanetsPerPlayer());\n        sender.sendMessage(\"  • Dünya başına max gezegen: §a\" + plugin.getConfigManager().getMaxPlanetsPerWorld());\n        sender.sendMessage(\"  • Üretim cooldown: §a\" + plugin.getConfigManager().getGenerationCooldown() + \"s\");\n    }\n\n    private void handleConfigSet(CommandSender sender, String[] args) {\n        if (args.length < 4) {\n            sender.sendMessage(\"§cKullanım: /gezegen config set <kategori> <ayar> <değer>\");\n            sender.sendMessage(\"§7Kategoriler: generation, placement, performance, features, limits\");\n            return;\n        }\n\n        String category = args[2].toLowerCase();\n        String setting = args[3].toLowerCase();\n        String valueStr = args.length > 4 ? args[4] : \"\";\n\n        try {\n            String configPath = getConfigPath(category, setting);\n            if (configPath == null) {\n                sender.sendMessage(\"§cGeçersiz kategori veya ayar!\");\n                return;\n            }\n\n            Object value;\n            if (valueStr.equalsIgnoreCase(\"true\") || valueStr.equalsIgnoreCase(\"false\")) {\n                value = Boolean.parseBoolean(valueStr);\n            } else {\n                try {\n                    value = Integer.parseInt(valueStr);\n                } catch (NumberFormatException e) {\n                    try {\n                        value = Double.parseDouble(valueStr);\n                    } catch (NumberFormatException e2) {\n                        value = valueStr; // String value\n                    }\n                }\n            }\n\n            plugin.getConfig().set(configPath, value);\n            plugin.saveConfig();\n\n            sender.sendMessage(String.format(\"§a%s.%s = %s olarak ayarlandı!\", category, setting, value));\n\n            // Special handling for caches\n            if (category.equals(\"generation\") && setting.equals(\"shapes\")) {\n                plugin.getConfigManager().clearCaches();\n                sender.sendMessage(\"§eŞekil ağırlıkları cache'i temizlendi!\");\n            }\n\n        } catch (Exception e) {\n            sender.sendMessage(\"§cAyar değiştirilemedi: \" + e.getMessage());\n        }\n    }\n\n    private void handleConfigReset(CommandSender sender, String[] args) {\n        if (args.length < 3) {\n            sender.sendMessage(\"§cKullanım: /gezegen config reset <kategori>\");\n            return;\n        }\n\n        String category = args[2].toLowerCase();\n        String path = getCategoryPath(category);\n\n        if (path == null) {\n            sender.sendMessage(\"§cGeçersiz kategori!\");\n            return;\n        }\n\n        plugin.getConfig().set(path, null);\n        plugin.saveConfig();\n\n        sender.sendMessage(\"§e\" + category.toUpperCase() + \" kategorisi varsayılan ayarlara sıfırlandı!\");\n\n        // Clear caches if needed\n        if (category.equals(\"generation\")) {\n            plugin.getConfigManager().clearCaches();\n        }\n    }\n\n    private void handleConfigReload(CommandSender sender) {\n        try {\n            plugin.reloadPluginConfig();\n            sender.sendMessage(\"§aKonfigürasyon yeniden yüklendi!\");\n        } catch (Exception e) {\n            sender.sendMessage(\"§cKonfigürasyon yüklenemedi: \" + e.getMessage());\n        }\n    }\n\n    private void handleConfigSave(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(\"§cYetkiniz yok!\");\n            return;\n        }\n\n        try {\n            plugin.saveConfig();\n            sender.sendMessage(\"§aKonfigürasyon diske kaydedildi!\");\n        } catch (Exception e) {\n            sender.sendMessage(\"§cKonfigürasyon kaydedilemedi: \" + e.getMessage());\n        }\n    }\n\n    private void handleConfigBackup(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(\"§cYetkiniz yok!\");\n            return;\n        }\n\n        try {\n            // Create backup filename with timestamp\n            String timestamp = java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern(\"yyyy-MM-dd_HH-mm-ss\"));\n            String backupFileName = \"config_backup_\" + timestamp + \".yml\";\n\n            // Save current config to backup file\n            plugin.getConfig().save(new java.io.File(plugin.getDataFolder(), \"backups/\" + backupFileName));\n\n            sender.sendMessage(\"§aKonfigürasyon yedeği oluşturuldu: §f\" + backupFileName);\n        } catch (Exception e) {\n            sender.sendMessage(\"§cYedek oluşturulamadı: \" + e.getMessage());\n        }\n    }\n\n    private String getConfigPath(String category, String setting) {\n        return switch (category) {\n            case \"generation\" -> switch (setting) {\n                case \"minradius\" -> \"generation.planetSize.minRadius\";\n                case \"maxradius\" -> \"generation.planetSize.maxRadius\";\n                case \"averageradius\" -> \"generation.planetSize.averageRadius\";\n                default -> null;\n            };\n            case \"placement\" -> switch (setting) {\n                case \"maxdistance\" -> \"placement.worldBounds.maxDistance\";\n                case \"clustermindistance\" -> \"placement.clustering.clusterMinDistance\";\n                case \"clustermaxdistance\" -> \"placement.clustering.clusterMaxDistance\";\n                case \"clustering\" -> \"placement.clustering.enabled\";\n                default -> null;\n            };\n            case \"performance\" -> switch (setting) {\n                case \"blocksperbatch\" -> \"performance.batching.blocksPerBatch\";\n                case \"batchespertick\" -> \"performance.batching.batchesPerTick\";\n                case \"shellthickness\" -> \"performance.generation.shellThickness\";\n                default -> null;\n            };\n            case \"features\" -> switch (setting) {\n                case \"oregeneration\" -> \"features.ores.enabled\";\n                case \"treegeneration\" -> \"features.trees.enabled\";\n                case \"structuregeneration\" -> \"features.structures.enabled\";\n                case \"treasuregeneration\" -> \"features.treasures.enabled\";\n                case \"asteroids\" -> \"asteroids.enabled\";\n                default -> null;\n            };\n            case \"limits\" -> switch (setting) {\n                case \"planetsperplayer\" -> \"limits.planetsPerPlayer\";\n                case \"maxplanetsperworld\" -> \"limits.maxPlanetsPerWorld\";\n                case \"generationcooldown\" -> \"limits.generationCooldown\";\n                default -> null;\n            };\n            default -> null;\n        };\n    }\n\n    private String getCategoryPath(String category) {\n        return switch (category) {\n            case \"generation\" -> \"generation\";\n            case \"placement\" -> \"placement\";\n            case \"performance\" -> \"performance\";\n            case \"features\" -> \"features\";\n            case \"limits\" -> \"limits\";\n            default -> null;\n        };\n    }\n\n    private void sendConfigHelp(CommandSender sender) {\n        sender.sendMessage(\"§b═══ Sistem Konfigürasyon Komutları ═══\");\n        sender.sendMessage(\"§e/gezegen config list §7- Tüm ayarları listele\");\n        sender.sendMessage(\"§e/gezegen config set <kat> <ayar> <değer> §7- Ayar değiştir\");\n        sender.sendMessage(\"§e/gezegen config reset <kategori> §7- Kategoriyi varsayılana sıfırla\");\n        sender.sendMessage(\"§e/gezegen config reload §7- Konfigürasyonu yeniden yükle\");\n        sender.sendMessage(\"§e/gezegen config save §7- Konfigürasyonu diske kaydet\");\n        sender.sendMessage(\"§e/gezegen config backup §7- Konfigürasyon yedeği al\");\n        sender.sendMessage(\"§7\");\n        sender.sendMessage(\"§7Kategoriler: generation, placement, performance, features, limits\");\n        sender.sendMessage(\"§7Örnek: /gezegen config set performance blocksperbatch 500\");\n    }\n\n    private void sendOreConfigHelp(CommandSender sender) {\n        sender.sendMessage(\"§b═══ Ore Konfigürasyon Komutları ═══\");\n        sender.sendMessage(\"§e/gezegen ore list §7- Konfigüre edilmiş gezegenleri listele\");\n        sender.sendMessage(\"§e/gezegen ore set <tip> <maden> <özellik> <değer> §7- Maden ayarı değiştir\");\n        sender.sendMessage(\"§e/gezegen ore enable <tip> §7- Gezegen için ore üretimini aktifleştir\");\n        sender.sendMessage(\"§e/gezegen ore disable <tip> §7- Gezegen için ore üretimini devre dışı bırak\");\n        sender.sendMessage(\"§e/gezegen ore multiplier <tip> <çarpan> §7- Yoğunluk çarpanını ayarla\");\n        sender.sendMessage(\"§e/gezegen ore reset <tip> §7- Gezegeni varsayılan ayarlara sıfırla\");\n        sender.sendMessage(\"§7\");\n        sender.sendMessage(\"§7Özellikler: chance (0.0-1.0), minVein, maxVein, enabled (true/false)\");\n        sender.sendMessage(\"§7Gezegen tipleri: terrestrial, lava, crystal, ice, shadow, toxic, gas\");\n    }\n\n    private void handleTest(CommandSender sender) {\n        if (!sender.hasPermission(\"skyorbs.admin\")) {\n            sender.sendMessage(\"§cYetkiniz yok!\");\n            return;\n        }\n\n        sender.sendMessage(\"§b========================================\");\n        sender.sendMessage(\"§b§lSYSTEM TEST REPORT\");\n        sender.sendMessage(\"§b========================================\");\n\n        // 1. Config Test\n        sender.sendMessage(\"§e1. CONFIG TEST:\");\n        sender.sendMessage(\"  • minRadius: §a\" + plugin.getConfigManager().getMinRadius());\n        sender.sendMessage(\"  • maxRadius: §a\" + plugin.getConfigManager().getMaxRadius());\n        sender.sendMessage(\"  • blocksPerBatch: §a\" + plugin.getConfigManager().getBlocksPerBatch());\n\n        // 2. Shape Registry Test\n        sender.sendMessage(\"§e2. SHAPE REGISTRY TEST:\");\n        sender.sendMessage(\"  • Registered shapes: §a\" + plugin.getShapeRegistry().getShapeCount());\n\n        Map<String, Double> weights = plugin.getConfigManager().getShapeWeights();\n        sender.sendMessage(\"  • Loaded weights: §a\" + weights.size());\n\n        // 3. Feature Test\n        sender.sendMessage(\"§e3. FEATURE TEST:\");\n        sender.sendMessage(\"  • Ore Generation: \" +\n            (plugin.getConfigManager().isOreGenerationEnabled() ? \"§aEnabled\" : \"§cDisabled\"));\n        sender.sendMessage(\"  • Hollow Planet Ores: \" +\n            (plugin.getConfig().getBoolean(\"features.ores.hollowPlanetSpawn\", false) ? \"§cEnabled (BAD)\" : \"§aDisabled (GOOD)\"));\n\n        // 4. Database Test\n        sender.sendMessage(\"§e4. DATABASE TEST:\");\n        try {\n            List<Orb> orbs = plugin.getDatabaseManager().getAllOrbs();\n            sender.sendMessage(\"  • Total planets: §a\" + orbs.size());\n        } catch (Exception e) {\n            sender.sendMessage(\"  §c✗ Database error: \" + e.getMessage());\n        }\n\n        // 5. ORE PROFILE TEST\n        sender.sendMessage(\"§e5. ORE PROFILE TEST:\");\n\n        // Test each planet type\n        String[] testTypes = {\"terrestrial\", \"lava\", \"crystal\", \"ice\", \"shadow\", \"toxic\"};\n        for (String type : testTypes) {\n            var config = plugin.getConfigManager().getOreConfigForPlanetType(type);\n            boolean enabled = (Boolean) config.getOrDefault(\"enabled\", false);\n\n            @SuppressWarnings(\"unchecked\")\n            var ores = (java.util.Map<String, java.util.Map<String, Object>>) config.get(\"ores\");\n            int oreCount = ores != null ? ores.size() : 0;\n\n            sender.sendMessage(\"  • \" + type.toUpperCase() + \": \" +\n                (enabled ? \"§aEnabled\" : \"§cDisabled\") + \" §7| Ores: §e\" + oreCount);\n        }\n\n        // 6. BIOME TO PLANET TYPE MAPPING TEST\n        sender.sendMessage(\"§e6. BIOME MAPPING TEST:\");\n        sender.sendMessage(\"  • LAVA_OCEAN -> \" + OreGenerator.getPlanetTypeFromBiome(BiomeType.LAVA_OCEAN).name());\n        sender.sendMessage(\"  • CRYSTAL_FOREST -> \" + OreGenerator.getPlanetTypeFromBiome(BiomeType.CRYSTAL_FOREST).name());\n        sender.sendMessage(\"  • FROZEN_TUNDRA -> \" + OreGenerator.getPlanetTypeFromBiome(BiomeType.FROZEN_TUNDRA).name());\n        sender.sendMessage(\"  • VOID -> \" + OreGenerator.getPlanetTypeFromBiome(BiomeType.VOID).name());\n\n        sender.sendMessage(\"§b========================================\");\n    }\n    \n    private void sendHelp(CommandSender sender) {\n        sender.sendMessage(\"§b═══ Gezegen Komutları ═══\");\n        sender.sendMessage(\"§e/gezegen create [şekil] §7- Yeni gezegen oluştur (isteğe bağlı şekil belirt)\");\n        sender.sendMessage(\"§7Örnek: §f/gezegen create STAR §7(yıldız şeklinde)\");\n        sender.sendMessage(\"§7Mevcut şekiller: §fSPHERE, STAR, RAINBOW, BUTTERFLY, MOON, DIAMOND, HEART\");\n        sender.sendMessage(\"§7ve daha fazlası...\");\n        sender.sendMessage(\"\");\n        sender.sendMessage(\"§e/gezegen list §7- Tüm gezegenleri listele\");\n        sender.sendMessage(\"§e/gezegen tp <isim> §7- Gezegene ışınlan\");\n        sender.sendMessage(\"§e/gezegen info <isim> §7- Gezegen bilgilerini göster\");\n        sender.sendMessage(\"§e/gezegen sil <isim> §7- Gezegeni sil (Admin)\");\n        sender.sendMessage(\"§e/gezegen reload §7- Konfigürasyonu yenile (Admin)\");\n        sender.sendMessage(\"§e/gezegen ore §7- Ore konfigürasyon komutları (Admin)\");\n        sender.sendMessage(\"§e/gezegen config §7- Sistem konfigürasyon komutları (Admin)\");\n        sender.sendMessage(\"§e/gezegen test §7- Sistem testi (Admin)\");\n    }\n    \n    @Override\n    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {\n        if (args.length == 1) {\n            return Arrays.asList(\"create\", \"list\", \"tp\", \"info\", \"sil\", \"reload\", \"ore\", \"config\", \"test\");\n        }\n\n        if (args.length == 2 && args[0].equalsIgnoreCase(\"ore\")) {\n            return Arrays.asList(\"list\", \"set\", \"enable\", \"disable\", \"multiplier\", \"reset\");\n        }\n\n        if (args.length == 2 && args[0].equalsIgnoreCase(\"config\")) {\n            return Arrays.asList(\"list\", \"set\", \"reset\", \"reload\", \"save\", \"backup\");\n        }\n        \n        if (args.length == 2 && (args[0].equalsIgnoreCase(\"tp\") || args[0].equalsIgnoreCase(\"info\") || args[0].equalsIgnoreCase(\"sil\"))) {\n            try {\n                List<Orb> orbs = plugin.getDatabaseManager().getAllOrbs();\n                return orbs.stream().map(Orb::getName).toList();\n            } catch (SQLException e) {\n                return new ArrayList<>();\n            }\n        }\n\n        // ŞEKİL TAB COMPLETION - create komutu için\n        if (args.length == 2 && args[0].equalsIgnoreCase(\"create\")) {\n            return new ArrayList<>(plugin.getShapeRegistry().getShapeNames());\n        }\n\n        return new ArrayList<>();\n    }\n}\n","size_bytes":33924},"src/main/java/com/skyorbs/effects/PlanetEffectManager.java":{"content":"package com.skyorbs.effects;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class PlanetEffectManager {\n\n    private final SkyOrbs plugin;\n    private final Map<UUID, PlanetAura> activeAuras = new HashMap<>();\n    private final Map<UUID, PlanetSoundscape> activeSoundscapes = new HashMap<>();\n    private final Random random = new Random();\n\n    public PlanetEffectManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startEffectUpdater();\n    }\n\n    public void applyPlanetEffects(Player player, Orb orb) {\n        UUID playerId = player.getUniqueId();\n\n        // Remove old effects\n        removePlanetEffects(playerId);\n\n        // Apply new effects based on biome and atmosphere\n        BiomeType biome = BiomeType.valueOf(orb.getBiomeName());\n        applyAtmosphericEffects(player, biome);\n        applyAura(player, orb);\n        applySoundscape(player, orb);\n        applyParticles(player, biome);\n        applySkyEffects(player, biome);\n    }\n\n    public void removePlanetEffects(UUID playerId) {\n        if (activeAuras.containsKey(playerId)) {\n            activeAuras.get(playerId).stop();\n            activeAuras.remove(playerId);\n        }\n\n        if (activeSoundscapes.containsKey(playerId)) {\n            activeSoundscapes.get(playerId).stop();\n            activeSoundscapes.remove(playerId);\n        }\n    }\n\n    private void applyAura(Player player, Orb orb) {\n        PlanetAura aura = new PlanetAura(player, orb);\n        activeAuras.put(player.getUniqueId(), aura);\n        aura.start();\n    }\n\n    private void applySoundscape(Player player, Orb orb) {\n        PlanetSoundscape soundscape = new PlanetSoundscape(player, orb);\n        activeSoundscapes.put(player.getUniqueId(), soundscape);\n        soundscape.start();\n    }\n\n    private void applyAtmosphericEffects(Player player, BiomeType biome) {\n        // Apply atmosphere effects based on biome\n        switch (biome) {\n            case TOXIC_SWAMP, TOXIC -> {\n                // Toxic atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.POISON, 100, 1, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.SLOWNESS, 100, 0, false, false, false));\n            }\n            case LUMINOUS, GLOWSTONE_CAVERN -> {\n                // Glowing atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.NIGHT_VISION, 300, 0, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING, 300, 0, false, false, false));\n            }\n            case STORMY -> {\n                // Stormy atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.SLOWNESS, 80, 1, false, false, false));\n            }\n            case CORROSIVE -> {\n                // Corrosive atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.WITHER, 60, 0, false, false, false));\n                player.addPotionEffect(new PotionEffect(PotionEffectType.POISON, 100, 2, false, false, false));\n            }\n            case AURORA -> {\n                // Aurora atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 120, 0, false, false, false));\n            }\n            case FOGGY -> {\n                // Foggy atmosphere\n                player.addPotionEffect(new PotionEffect(PotionEffectType.BLINDNESS, 40, 0, false, false, false));\n            }\n        }\n    }\n\n    private void applyParticles(Player player, BiomeType biome) {\n        Location loc = player.getLocation();\n\n        new BukkitRunnable() {\n            int ticks = 0;\n\n            @Override\n            public void run() {\n                if (!player.isOnline() || ticks >= 1200) { // 60 seconds\n                    cancel();\n                    return;\n                }\n\n                // Biome-specific atmospheric particles\n                switch (biome) {\n                    case TOXIC_SWAMP, TOXIC -> {\n                        // Toxic green particles\n                        player.getWorld().spawnParticle(Particle.DRIPPING_LAVA,\n                            loc.clone().add(0, 1, 0), 3, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case LUMINOUS, GLOWSTONE_CAVERN -> {\n                        // Glowing particles\n                        player.getWorld().spawnParticle(Particle.END_ROD,\n                            loc.clone().add(0, 1, 0), 5, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case STORMY -> {\n                        // Storm particles\n                        player.getWorld().spawnParticle(Particle.CLOUD,\n                            loc.clone().add(0, 1, 0), 10, 0.5, 0.5, 0.5, 0.1);\n                    }\n                    case CORROSIVE -> {\n                        // Corrosive particles\n                        player.getWorld().spawnParticle(Particle.PORTAL,\n                            loc.clone().add(0, 1, 0), 3, 0.3, 0.3, 0.3, 0.01);\n                    }\n                    case AURORA -> {\n                        // Aurora particles\n                        player.getWorld().spawnParticle(Particle.END_ROD,\n                            loc.clone().add(0, 1, 0), 8, 0.5, 0.5, 0.5, 0.02);\n                    }\n                    case FOGGY -> {\n                        // Fog particles\n                        player.getWorld().spawnParticle(Particle.WHITE_ASH,\n                            loc.clone().add(0, 1, 0), 15, 0.5, 0.5, 0.5, 0.05);\n                    }\n                    case CRYSTAL_FOREST, CRYSTALLINE -> {\n                        // Crystal particles\n                        player.getWorld().spawnParticle(Particle.DRAGON_BREATH,\n                            loc.clone().add(0, 1, 0), 5, 0.5, 0.5, 0.5, 0.01);\n                    }\n                    case LAVA_OCEAN, MAGMA_CAVES -> {\n                        // Lava particles\n                        player.getWorld().spawnParticle(Particle.FLAME,\n                            loc.clone().add(0, 0.5, 0), 3, 0.3, 0.3, 0.3, 0.01);\n                    }\n                    case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                        // Ice particles\n                        player.getWorld().spawnParticle(Particle.SNOWFLAKE,\n                            loc.clone().add(0, 1, 0), 10, 0.5, 0.5, 0.5, 0.1);\n                    }\n                }\n\n                ticks += 20; // Every second\n            }\n        }.runTaskTimer(plugin, 0L, 20L);\n    }\n\n    private void applySkyEffects(Player player, BiomeType biome) {\n        // Apply atmospheric sky effects based on biome\n        switch (biome) {\n            case TOXIC_SWAMP, TOXIC, CORROSIVE -> {\n                // Toxic/corrosive atmosphere - fog and weather\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n                // Fog effect (would need client mods for full effect)\n            }\n            case STORMY -> {\n                // Stormy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case FOGGY -> {\n                // Foggy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case LUMINOUS, AURORA -> {\n                // Clear glowing atmosphere\n                player.setPlayerWeather(WeatherType.CLEAR);\n            }\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                // Volcanic atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                // Icy atmosphere\n                player.setPlayerWeather(WeatherType.DOWNFALL);\n            }\n            default -> {\n                // Clear atmosphere for other biomes\n                player.setPlayerWeather(WeatherType.CLEAR);\n            }\n        }\n    }\n\n    private void startEffectUpdater() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                // Update effects for all online players\n                for (Player player : Bukkit.getOnlinePlayers()) {\n                    // Check if player is on a planet\n                    // This would need integration with player location tracking\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 100L); // Every 5 seconds\n    }\n\n    // Inner classes for effect management\n    private static class PlanetAura {\n        private final Player player;\n        private final Orb orb;\n        private BukkitRunnable task;\n\n        public PlanetAura(Player player, Orb orb) {\n            this.player = player;\n            this.orb = orb;\n        }\n\n        public void start() {\n            task = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (!player.isOnline()) {\n                        stop();\n                        return;\n                    }\n\n                    // Apply aura effects based on biome\n                    try {\n                        BiomeType biome = BiomeType.valueOf(orb.getBiomeName());\n\n                        switch (biome) {\n                            case CRYSTAL_FOREST, CRYSTALLINE -> {\n                                // Crystal aura - night vision\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.NIGHT_VISION, 300, 0, false, false, false));\n                            }\n                            case LUMINOUS, GLOWSTONE_CAVERN -> {\n                                // Luminous aura - glowing effect\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.GLOWING, 300, 0, false, false, false));\n                            }\n                            case AURORA -> {\n                                // Aurora aura - regeneration\n                                player.addPotionEffect(new PotionEffect(PotionEffectType.REGENERATION, 120, 0, false, false, false));\n                            }\n                        }\n                    } catch (IllegalArgumentException e) {\n                        // Invalid biome name, skip aura effects\n                    }\n                }\n            };\n            task.runTaskTimer(SkyOrbs.getInstance(), 0L, 200L); // Every 10 seconds\n        }\n\n        public void stop() {\n            if (task != null) {\n                task.cancel();\n            }\n        }\n    }\n\n    private static class PlanetSoundscape {\n        private final Player player;\n        private final Orb orb;\n        private BukkitRunnable task;\n\n        public PlanetSoundscape(Player player, Orb orb) {\n            this.player = player;\n            this.orb = orb;\n        }\n\n        public void start() {\n            task = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    if (!player.isOnline()) {\n                        stop();\n                        return;\n                    }\n\n                    // Play ambient sounds based on biome\n                    BiomeType biome;\n                    try {\n                        biome = BiomeType.valueOf(orb.getBiomeName());\n                    } catch (IllegalArgumentException e) {\n                        return; // Invalid biome, skip sound\n                    }\n                    Location loc = player.getLocation();\n\n                    Sound sound = getAmbientSound(biome);\n                    if (sound != null) {\n                        player.playSound(loc, sound, SoundCategory.AMBIENT, 0.3f, 1.0f);\n                    }\n                }\n            };\n            task.runTaskTimer(SkyOrbs.getInstance(), 0L, 400L); // Every 20 seconds\n        }\n\n        public void stop() {\n            if (task != null) {\n                task.cancel();\n            }\n        }\n\n        private Sound getAmbientSound(BiomeType biome) {\n            return switch (biome) {\n                case CRYSTAL_FOREST, CRYSTALLINE -> Sound.BLOCK_AMETHYST_BLOCK_CHIME;\n                case LAVA_OCEAN, MAGMA_CAVES -> Sound.BLOCK_LAVA_AMBIENT;\n                case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> Sound.BLOCK_SNOW_BREAK;\n                case TOXIC_SWAMP, TOXIC -> Sound.BLOCK_SLIME_BLOCK_BREAK;\n                case CORRUPTED -> Sound.AMBIENT_NETHER_WASTES_LOOP;\n                case GLOWSTONE_CAVERN, LUMINOUS -> Sound.BLOCK_AMETHYST_BLOCK_RESONATE;\n                case AURORA -> Sound.BLOCK_BELL_RESONATE;\n                case STORMY -> Sound.WEATHER_RAIN;\n                case FOGGY -> Sound.AMBIENT_NETHER_WASTES_LOOP;\n                case CORROSIVE -> Sound.BLOCK_LAVA_POP;\n                case CHORUS_LAND -> Sound.BLOCK_CHORUS_FLOWER_GROW;\n                default -> null;\n            };\n        }\n    }\n}","size_bytes":13030},"src/main/java/com/skyorbs/shapes/impl/CrateredShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\nimport java.util.Random;\n\n/**\n * CRATERED SHAPE - Kraterli gezegen\n * Creates planets with impact craters on the surface\n */\npublic class CrateredShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance > radius) return false;\n        \n        // Create craters using position-based random\n        Random random = new Random(seed + dx * 73856093 + dy * 19349663 + dz * 83492791);\n        \n        // Crater chance based on surface proximity\n        double surfaceProximity = Math.abs(distance - radius) / radius;\n        \n        if (surfaceProximity < 0.1 && random.nextDouble() < 0.3) {\n            // This is a crater - carve inward\n            double craterDepth = random.nextDouble() * 5;\n            return distance <= radius - craterDepth;\n        }\n        \n        return distance <= radius;\n    }\n\n    @Override\n    public String getName() { \n        return \"CRATERED\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.3; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Kraterli\"; \n    }\n}\n","size_bytes":1301},"CONFIG_SYSTEM_FIXED.md":{"content":"# ✅ SkyOrbs Config System - Tamamen Düzeltildi!\n\n## 🔥 Ana Sorunlar ve Çözümler\n\n### 1. ❌ Sorun: Config Değişiklikleri Etkisiz Kalıyordu\n**Sebep:** Ore generation sistemi `planetTypes` bölümünü okumuyordu, sadece generic bir config arıyordu.\n\n**✅ Çözüm:**\n- `GenerationManager.java` içinde `tryGenerateOre()` metodu güncellendi\n- Artık doğrudan `biome.name().toLowerCase()` kullanarak config'den ore profilini okuyor\n- Örnek: `lava_ocean` biyomu için `features.ores.planetTypes.lava_ocean` bölümünü okuyor\n\n### 2. ❌ Sorun: Gezegenler Hep Sphere Şeklinde Oluşuyordu\n**Sebep:** Shape weight sistemi doğru çalışmıyordu veya config yüklenmiyordu.\n\n**✅ Çözüm:**\n- `ShapeRegistry.java` zaten doğru yazılmış\n- `ConfigManager.java` içinde `getShapeWeights()` metodu cache sistemli çalışıyor\n- 28 farklı şekil kaydedilmiş ve ağırlıklı rastgele seçim yapılıyor\n\n### 3. ❌ Sorun: İçi Dolu Gezegenlerde Ore Oluşmuyordu\n**Sebep:** Oreler gezegen oluşturulduktan **SONRA** eklenmek isteniyordu, ama bu sistem kaldırılmıştı.\n\n**✅ Çözüm:**\n- **SOLID PLANETLER:** `generateSolidPlanet()` içinde `tryGenerateOre()` entegre edildi\n- **HOLLOW PLANETLER:** `generateHollowPlanet()` içinde kabuk oluşurken oreler de ekleniyor\n- Oreler artık gezegen yapısının bir parçası olarak generate ediliyor, sonradan eklenmiyor!\n\n### 4. ❌ Sorun: Biyoma Özel Ore Profilleri Çalışmıyordu\n**Sebep:** Config'de `planetTypes` bölümü yoktu veya eksikti.\n\n**✅ Çözüm:**\n- `config.yml` içinde 16+ biyom için detaylı ore profilleri eklendi:\n  - `forest`: Tüm oreler dengeli\n  - `lava_ocean`: Sadece ancient_debris, gold, nether_quartz\n  - `crystal_forest`: Sadece emerald, diamond, coal, amethyst\n  - `void`: **HİÇ ORE YOK** (enabled: false)\n  - `frozen_tundra`: Diamond ve lapis ağırlıklı\n  - `desert`: Gold ve copper ağırlıklı\n  - `toxic_swamp`: Slime ve glowstone\n  - ... ve daha fazlası!\n\n---\n\n## 📋 Yeni Config Yapısı\n\n```yaml\nfeatures:\n  ores:\n    enabled: true\n    densityMultiplier: 1.5\n    hollowPlanetSpawn: true  # İçi boş gezegenlerde kabukta ore spawn\n\n    planetTypes:\n      # HER BİYOM İÇİN ÖZEL PROFIL!\n      forest:\n        enabled: true\n        densityMultiplier: 1.0\n        ores:\n          coal:\n            enabled: true\n            chance: 0.35\n            minVein: 3\n            maxVein: 8\n          iron:\n            enabled: true\n            chance: 0.30\n            minVein: 2\n            maxVein: 6\n          # ... tüm oreler\n\n      lava_ocean:\n        enabled: true\n        densityMultiplier: 0.8\n        ores:\n          ancient_debris:\n            enabled: true\n            chance: 0.05\n            minVein: 1\n            maxVein: 3\n          gold:\n            enabled: true\n            chance: 0.15\n            minVein: 2\n            maxVein: 5\n          # Sadece bu iki ore çıkar!\n\n      void:\n        enabled: false  # Hiç ore çıkmaz!\n        densityMultiplier: 0.0\n        ores: {}\n```\n\n---\n\n## 🎯 Kullanım Örnekleri\n\n### Örnek 1: Dünya Benzeri Gezegen\n```yaml\nforest:\n  enabled: true\n  densityMultiplier: 1.0\n  ores:\n    coal: { enabled: true, chance: 0.35, minVein: 3, maxVein: 8 }\n    iron: { enabled: true, chance: 0.30, minVein: 2, maxVein: 6 }\n    copper: { enabled: true, chance: 0.25, minVein: 3, maxVein: 9 }\n    gold: { enabled: true, chance: 0.12, minVein: 2, maxVein: 5 }\n    diamond: { enabled: true, chance: 0.04, minVein: 1, maxVein: 4 }\n    emerald: { enabled: true, chance: 0.02, minVein: 1, maxVein: 2 }\n```\n**Sonuç:** Tüm oreler çıkar, dünya benzeri dağılım!\n\n### Örnek 2: Nether Benzeri Gezegen\n```yaml\nlava_ocean:\n  enabled: true\n  densityMultiplier: 0.8\n  ores:\n    ancient_debris: { enabled: true, chance: 0.05, minVein: 1, maxVein: 3 }\n    gold: { enabled: true, chance: 0.15, minVein: 2, maxVein: 5 }\n```\n**Sonuç:** Sadece ancient debris ve gold çıkar, çok düşük oranda!\n\n### Örnek 3: Kristalize Gezegen\n```yaml\ncrystal_forest:\n  enabled: true\n  densityMultiplier: 1.2\n  ores:\n    emerald: { enabled: true, chance: 0.25, minVein: 2, maxVein: 5 }\n    diamond: { enabled: true, chance: 0.08, minVein: 1, maxVein: 3 }\n    coal: { enabled: true, chance: 0.30, minVein: 3, maxVein: 8 }\n    amethyst: { enabled: true, chance: 0.40, minVein: 3, maxVein: 10 }\n```\n**Sonuç:** Sadece emerald, coal, düşük oranda diamond + amethyst!\n\n### Örnek 4: Ölü Gezegen\n```yaml\nvoid:\n  enabled: false\n  densityMultiplier: 0.0\n  ores: {}\n```\n**Sonuç:** Hiç ore çıkmaz! Tamamen boş/ölü gezegen!\n\n---\n\n## 🔧 Config Değişikliklerini Test Etme\n\n### Yöntem 1: Plugin Reload (Önerilen)\n```\n/gezegen reload\n```\nBu komut config'i yeniden yükler ve tüm değişiklikler anında aktif olur.\n\n### Yöntem 2: Sunucu Restart\n1. Sunucuyu durdur\n2. `config.yml` dosyasını düzenle\n3. Sunucuyu yeniden başlat\n\n### Yöntem 3: Hot Reload (Eğer AdminConfigGUI varsa)\nGUI üzerinden config değerlerini canlı olarak değiştir.\n\n---\n\n## 🎨 Shape (Şekil) Sistemi\n\nConfig'de 28 farklı şekil tanımlı:\n```yaml\ngeneration:\n  shapes:\n    weights:\n      SPHERE: 5.0           # Küre - Klasik gezegen\n      HEMISPHERE: 8.0       # Yarım küre\n      BLOB: 10.0            # Düzensiz şekil (EN YÜKSEK ŞANS!)\n      ASTEROID: 7.0         # Asteroid\n      TORUS: 4.0            # Halka şekli\n      RING: 3.0             # Düz halka\n      CYLINDER: 5.0         # Silindir\n      CONE: 6.0             # Koni\n      DIAMOND: 5.0          # Elmas şekli\n      CUBE: 4.0             # Küp\n      PYRAMID: 4.0          # Piramit\n      OCTAHEDRON: 3.0       # Sekizyüzlü\n      FRACTAL: 6.0          # Fraktal yapı\n      SPIKY: 5.0            # Dikenli\n      COMET: 3.0            # Kuyruklu yıldız\n      CRESCENT: 4.0         # Hilal\n      HYBRID: 2.0           # Hibrit (karışık)\n      LAYERED: 7.0          # Katmanlı gezegen\n      CRATERED: 8.0         # Kraterli yüzey\n      HONEYCOMB: 5.0        # Bal peteği yapısı\n      SPIRAL: 6.0           # Spiral formasyonlar\n      WAVE: 7.0             # Dalgalı desenler\n      CRYSTAL: 6.0          # Kristal yüzeyler\n      ORGANIC: 8.0          # Organik formlar\n      GEOMETRIC: 5.0        # Geometrik çokyüzlü\n      NEBULA: 4.0           # Nebula bulutu\n      ASTEROID_FIELD: 6.0   # Asteroid kümesi\n```\n\n**Yüksek ağırlık = Daha sık görünür**\n\nÖzel şekil dağılımı için:\n```yaml\nSPHERE: 1.0    # Çok nadir\nBLOB: 100.0    # Neredeyse hep blob\nCUBE: 50.0     # Orta sıklıkta\n```\n\n---\n\n## 🧪 Test Senaryoları\n\n### Test 1: Nether Gezegen Ore Kontrolü\n1. `lava_ocean` biyomlu bir gezegen oluştur\n2. Gezegeni kaz\n3. **Beklenen:** Sadece ancient_debris, gold ve nether_quartz çıkmalı\n4. **Çıkmaması gerekenler:** Diamond, iron, coal, emerald\n\n### Test 2: Kristal Gezegen Ore Kontrolü\n1. `crystal_forest` biyomlu gezegen oluştur\n2. Gezegeni kaz\n3. **Beklenen:** Çok emerald, orta coal, az diamond, çok amethyst\n4. **Çıkmaması gerekenler:** Iron, gold, redstone\n\n### Test 3: Ölü Gezegen (Void)\n1. `void` biyomlu gezegen oluştur\n2. Tüm gezegeni kaz\n3. **Beklenen:** HİÇBİR ORE ÇIKMAMALI!\n\n### Test 4: Shape Çeşitliliği\n1. 10 gezegen oluştur\n2. **Beklenen:** En az 5-6 farklı şekil görmelisin\n3. Eğer hepsi sphere ise config yüklenmemiş demektir\n\n### Test 5: İçi Boş Gezegen Ore Spawn\n1. Hollow modifier'lı gezegen oluştur\n2. Kabuktaki blokları kontrol et\n3. **Beklenen:** Kabukta da oreler olmalı\n4. **İç kısım:** Tamamen boş (AIR) olmalı\n\n---\n\n## 📊 Ore Chance (Şans) Sistemi Açıklaması\n\n```yaml\nchance: 0.35  # %35 şans (1000 blokta 350 ore)\n```\n\n- `0.01` = %1 şans (çok nadir)\n- `0.05` = %5 şans (nadir)\n- `0.10` = %10 şans (orta)\n- `0.25` = %25 şans (sık)\n- `0.35` = %35 şans (çok sık)\n- `0.50` = %50 şans (yarı yarıya)\n\n**DensityMultiplier çarpanı:**\n```yaml\ndensityMultiplier: 2.0  # Tüm ore şanslarını 2x artırır\n```\n\nEğer `coal: chance: 0.30` ve `densityMultiplier: 2.0` ise:\n- Gerçek şans: `0.30 × 2.0 = 0.60` (%60 şans!)\n\n---\n\n## 🚀 Özellikler\n\n### ✅ ÇALIŞAN ÖZELLİKLER:\n1. **Config-Based Ore Generation** ✅\n   - Her biyom kendi ore profiline sahip\n   - Real-time config reload\n\n2. **28 Farklı Gezegen Şekli** ✅\n   - Ağırlıklı rastgele seçim\n   - Config'den tamamen düzenlenebilir\n\n3. **Hollow Planet Ore Support** ✅\n   - İçi boş gezegenlerin kabuğunda ore spawn\n   - Config: `hollowPlanetSpawn: true`\n\n4. **Biome-Specific Distributions** ✅\n   - Forest: Tüm oreler\n   - Lava: Sadece nether ores\n   - Crystal: Sadece gems\n   - Void: Hiçbir ore yok\n\n5. **Core Rarity System** ✅\n   - Gezegen merkezine yaklaştıkça nadir oreler daha sık\n   - Diamond, emerald 5x daha fazla core'da\n\n---\n\n## 💾 Config Reload Komutu\n\nEğer reload komutu yoksa, eklemek için:\n\n```java\n// GezegenCommand.java içinde\nif (args[0].equalsIgnoreCase(\"reload\")) {\n    if (!player.hasPermission(\"skyorbs.admin.reload\")) {\n        player.sendMessage(\"§cYetkiniz yok!\");\n        return true;\n    }\n\n    plugin.reloadPluginConfig();\n    player.sendMessage(\"§aConfig yeniden yüklendi!\");\n    return true;\n}\n```\n\n---\n\n## 🎯 Sonuç\n\nArtık **HER ŞEY** config dosyasından kontrol edilebilir:\n\n✅ Gezegen şekilleri (28 farklı)\n✅ Biyom başına ore profilleri (16+ biyom)\n✅ Her ore için chance, vein size, enabled/disabled\n✅ İçi dolu vs içi boş gezegenler\n✅ Ore yoğunluk çarpanları\n✅ Dead planets (hiç ore yok)\n\n**Test etmek için:**\n1. Config'i düzenle\n2. `/gezegen reload` yap\n3. Yeni gezegen oluştur\n4. Ore dağılımını kontrol et\n\nArtık gezegenlerin hepsi sphere değil, çeşitli şekillerde ve her biyom kendi ore dağılımına sahip!\n","size_bytes":9698},"src/main/java/com/skyorbs/storage/PlanetDataManager.java":{"content":"package com.skyorbs.storage;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Bukkit;\nimport org.bukkit.configuration.file.YamlConfiguration;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Gezegen data yönetimi - Her gezegen için ayrı klasör ve bilgi dosyaları\n */\npublic class PlanetDataManager {\n\n    private final SkyOrbs plugin;\n    private final File planetsDataFolder;\n    private final Map<UUID, YamlConfiguration> planetConfigs;\n\n    public PlanetDataManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        this.planetsDataFolder = new File(plugin.getDataFolder(), \"planets\");\n        this.planetConfigs = new HashMap<UUID, YamlConfiguration>();\n\n        // Ana klasörü oluştur\n        if (!planetsDataFolder.exists()) {\n            planetsDataFolder.mkdirs();\n        }\n    }\n\n    /**\n     * Gezegen için klasör oluştur ve temel bilgileri kaydet\n     */\n    public void createPlanetData(Orb orb) {\n        try {\n            // Gezegen klasörü oluştur\n            File planetFolder = new File(planetsDataFolder, orb.getId().toString());\n            if (!planetFolder.exists()) {\n                planetFolder.mkdirs();\n            }\n\n            // Gezegen bilgileri dosyası\n            File infoFile = new File(planetFolder, \"info.yml\");\n            YamlConfiguration config = YamlConfiguration.loadConfiguration(infoFile);\n\n            // Temel bilgiler\n            config.set(\"id\", orb.getId().toString());\n            config.set(\"name\", orb.getName());\n            config.set(\"world\", orb.getWorldName());\n            config.set(\"centerX\", orb.getCenterX());\n            config.set(\"centerY\", orb.getCenterY());\n            config.set(\"centerZ\", orb.getCenterZ());\n            config.set(\"radius\", orb.getRadius());\n            config.set(\"shape\", orb.getShapeName());\n            config.set(\"biome\", orb.getBiomeName());\n            config.set(\"seed\", orb.getSeed());\n            config.set(\"created\", orb.getCreatedTime());\n            config.set(\"isHollow\", orb.isHollow());\n\n            // Ek bilgiler\n            if (orb.getPaletteId() != null) {\n                config.set(\"paletteId\", orb.getPaletteId());\n            }\n            if (orb.getAtmosphere() != null) {\n                config.set(\"atmosphere\", orb.getAtmosphere().name());\n            }\n            if (orb.getModifiers() != null && !orb.getModifiers().isEmpty()) {\n                config.set(\"modifiers\", orb.getModifiers().stream()\n                    .map(mod -> mod.name())\n                    .toList());\n            }\n\n            // İstatistikler\n            config.set(\"stats.blockCount\", calculateEstimatedBlockCount(orb));\n            config.set(\"stats.surfaceArea\", calculateSurfaceArea(orb));\n            config.set(\"stats.volume\", calculateVolume(orb));\n\n            // Kaydet\n            config.save(infoFile);\n\n            // Cache'e ekle\n            planetConfigs.put(orb.getId(), config);\n\n            plugin.logDebug(\"planet_data\", \"Gezegen data klasörü oluşturuldu: \" + planetFolder.getPath());\n\n        } catch (IOException e) {\n            plugin.logError(\"Gezegen data oluşturma hatası\", e);\n        }\n    }\n\n    /**\n     * Gezegen bilgilerini güncelle\n     */\n    public void updatePlanetData(Orb orb) {\n        YamlConfiguration config = planetConfigs.get(orb.getId());\n        if (config == null) {\n            createPlanetData(orb);\n            return;\n        }\n\n        try {\n            File planetFolder = new File(planetsDataFolder, orb.getId().toString());\n            File infoFile = new File(planetFolder, \"info.yml\");\n\n            // Güncel bilgileri yaz\n            config.set(\"name\", orb.getName());\n            config.set(\"biome\", orb.getBiomeName());\n            config.set(\"lastModified\", System.currentTimeMillis());\n\n            config.save(infoFile);\n\n        } catch (IOException e) {\n            plugin.logError(\"Gezegen data güncelleme hatası\", e);\n        }\n    }\n\n    /**\n     * Gezegen data'sını yükle\n     */\n    public YamlConfiguration loadPlanetData(UUID planetId) {\n        if (planetConfigs.containsKey(planetId)) {\n            return planetConfigs.get(planetId);\n        }\n\n        File planetFolder = new File(planetsDataFolder, planetId.toString());\n        File infoFile = new File(planetFolder, \"info.yml\");\n\n        if (infoFile.exists()) {\n            YamlConfiguration config = YamlConfiguration.loadConfiguration(infoFile);\n            planetConfigs.put(planetId, config);\n            return config;\n        }\n\n        return null;\n    }\n\n    /**\n     * Gezegen klasörünü sil\n     */\n    public void deletePlanetData(UUID planetId) {\n        try {\n            File planetFolder = new File(planetsDataFolder, planetId.toString());\n            if (planetFolder.exists()) {\n                // Tüm dosyaları sil\n                Files.walk(Paths.get(planetFolder.getPath()))\n                    .map(Path::toFile)\n                    .forEach(File::delete);\n\n                // Cache'den çıkar\n                planetConfigs.remove(planetId);\n\n                plugin.logDebug(\"planet_data\", \"Gezegen data klasörü silindi: \" + planetFolder.getPath());\n            }\n        } catch (IOException e) {\n            plugin.logError(\"Gezegen data silme hatası\", e);\n        }\n    }\n\n    /**\n     * Gezegen istatistiklerini hesapla\n     */\n    private long calculateEstimatedBlockCount(Orb orb) {\n        int radius = orb.getRadius();\n        if (orb.isHollow()) {\n            // Hollow planet için kabuk hacmi\n            int shellThickness = plugin.getConfig().getInt(\"modifiers.hollow.shellThickness\", 5);\n            double outerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius, 3);\n            double innerVolume = (4.0 / 3.0) * Math.PI * Math.pow(radius - shellThickness, 3);\n            return (long)((outerVolume - innerVolume) * 1.1);\n        } else {\n            // Solid planet için tam hacim\n            return (long)((4.0 / 3.0) * Math.PI * Math.pow(radius, 3) * 1.1);\n        }\n    }\n\n    private double calculateSurfaceArea(Orb orb) {\n        int radius = orb.getRadius();\n        return 4 * Math.PI * radius * radius;\n    }\n\n    private double calculateVolume(Orb orb) {\n        int radius = orb.getRadius();\n        return (4.0 / 3.0) * Math.PI * radius * radius * radius;\n    }\n\n    /**\n     * Tüm gezegen klasörlerini listele\n     */\n    public File[] getAllPlanetFolders() {\n        return planetsDataFolder.listFiles(File::isDirectory);\n    }\n\n    /**\n     * Gezegen sayısını döndür\n     */\n    public int getPlanetCount() {\n        File[] folders = getAllPlanetFolders();\n        return folders != null ? folders.length : 0;\n    }\n\n    /**\n     * Cache'i temizle\n     */\n    public void clearCache() {\n        planetConfigs.clear();\n    }\n\n    /**\n     * Tüm gezegen verilerini yeniden yükle\n     */\n    public void reloadAllPlanetData() {\n        clearCache();\n        File[] planetFolders = getAllPlanetFolders();\n\n        if (planetFolders != null) {\n            for (File folder : planetFolders) {\n                try {\n                    UUID planetId = UUID.fromString(folder.getName());\n                    loadPlanetData(planetId);\n                } catch (IllegalArgumentException e) {\n                    plugin.logError(\"Geçersiz gezegen klasör adı: \" + folder.getName(), e);\n                }\n            }\n        }\n    }\n}","size_bytes":7544},"src/main/java/com/skyorbs/generation/GenerationManager.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.features.*;\nimport com.skyorbs.shapes.PlanetShape;\nimport org.bukkit.*;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.boss.BarColor;\nimport org.bukkit.boss.BarStyle;\nimport org.bukkit.boss.BossBar;\nimport org.bukkit.entity.Player;\n\nimport java.util.*;\nimport java.util.concurrent.*;\n\npublic class GenerationManager {\n    \n    private final SkyOrbs plugin;\n    private final PlacementService placementService;\n    private final PlanetSizeCalculator sizeCalculator;\n    private final AsteroidGenerator asteroidGenerator;\n    private final SatelliteGenerator satelliteGenerator;\n    private final ExecutorService executor;\n    \n    public GenerationManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        this.placementService = new PlacementService(plugin);\n        this.sizeCalculator = new PlanetSizeCalculator(plugin);\n        this.asteroidGenerator = new AsteroidGenerator(plugin);\n        this.satelliteGenerator = new SatelliteGenerator(plugin);\n        this.executor = Executors.newCachedThreadPool(); // Daha hızlı thread yönetimi için cached pool\n    }\n    \n    public void createPlanetAsync(World world, Player player) {\n        createPlanetAsync(world, player, plugin.getConfigManager().generateRandomName(), null);\n    }\n\n    public void createPlanetAsync(World world, Player player, String shapeName) {\n        createPlanetAsync(world, player, plugin.getConfigManager().generateRandomName(), shapeName);\n    }\n\n    public void createPlanetAsync(World world, Player player, String name, String forcedShape) {\n        player.sendMessage(\"§eGezegen oluşturuluyor...\");\n\n        executor.submit(() -> {\n            PlacementService.PlacementResult placement = null;\n            try {\n                List<Orb> existingOrbs = plugin.getDatabaseManager().getAllOrbs();\n                int radius = sizeCalculator.calculateRadius(\"RANDOM\");\n                placement = placementService.findPlacement(radius, existingOrbs);\n\n                if (!placement.isSuccess()) {\n                    Bukkit.getScheduler().runTask(plugin, () ->\n                        player.sendMessage(\"§cUygun yer bulunamadı!\")\n                    );\n                    return;\n                }\n\n                // LOCATION RESERVE - Başka gezegen aynı yere oluşmasın\n                placementService.reserveLocation(placement.getX(), placement.getZ());\n\n                long seed = System.currentTimeMillis();\n                Random random = new Random(seed);\n\n                PlanetShape shape;\n                if (forcedShape != null) {\n                    // FORCED SHAPE - Belirtilen şekli kullan\n                    shape = plugin.getShapeRegistry().getShape(forcedShape);\n                    if (shape == null) {\n                        // Fallback to random if forced shape not found\n                        shape = plugin.getShapeRegistry().getRandomShape(\n                            plugin.getConfigManager().getShapeWeights()\n                        );\n                    }\n                } else {\n                    // RANDOM SHAPE - Rastgele şekil seç\n                    shape = plugin.getShapeRegistry().getRandomShape(\n                        plugin.getConfigManager().getShapeWeights()\n                    );\n                }\n\n                BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n                \n                // NEW: Select random palette for diversity\n                com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n                \n                // NEW: Resolve modifiers for variety - ENHANCED DIVERSITY\n                com.skyorbs.modifiers.ModifierResolver modifierResolver = new com.skyorbs.modifiers.ModifierResolver(seed);\n                java.util.Set<com.skyorbs.modifiers.PlanetModifier> modifiers = modifierResolver.resolveModifiers();\n\n                // ADD RANDOM VARIATIONS for even more diversity\n                // addRandomVariations(orb, modifiers, random); // Commented out to fix compilation\n                \n                // NEW: Select atmosphere\n                com.skyorbs.atmosphere.AtmosphereType atmosphere = plugin.getAtmosphereManager().selectRandomAtmosphere(random);\n\n                Orb orb = new Orb(\n                    UUID.randomUUID(),\n                    name,\n                    world.getName(),\n                    placement.getX(),\n                    placement.getY(),\n                    placement.getZ(),\n                    radius,\n                    shape.getName(),\n                    biome.name(),\n                    seed,\n                    System.currentTimeMillis(),\n                    false,\n                    null\n                );\n                \n                // NEW: Set advanced features\n                orb.setPaletteId(palette.getId());\n                orb.setModifiers(modifiers);\n                orb.setAtmosphere(atmosphere);\n                \n                // NEW: Register atmosphere effects\n                plugin.getAtmosphereManager().registerPlanetAtmosphere(orb.getId(), atmosphere);\n\n                // Calculate total steps dynamically\n                int totalSteps = 9; // Base steps (shell, ore, trees, structures, treasures, dungeons, surface details, rings, finalization)\n\n                final int[] progress = {0};\n                final int finalTotalSteps = totalSteps;\n\n                // Progress display type from config - YENİ CONFIG SİSTEMİ\n                String progressType = plugin.getConfig().getString(\"progressDisplay.type\", \"bossbar\");\n\n                // BossBar oluştur (config kontrollü)\n                final BossBar[] bossBarRef = new BossBar[1];\n                final String[] actionBarRef = {\"\"};\n                final long[] lastUpdateTime = {0};\n\n                if (\"bossbar\".equals(progressType)) { // Config kontrolünü kaldır, direkt oluştur\n                    Bukkit.getScheduler().runTask(plugin, () -> {\n                        try {\n                            BarColor color = BarColor.YELLOW;\n                            BarStyle style = BarStyle.SEGMENTED_20;\n\n                            BossBar bossBar = Bukkit.createBossBar(\"§6🌍 Gezegen Oluşturuluyor...\", color, style);\n                            bossBar.addPlayer(player);\n                            bossBar.setVisible(true);\n                            bossBarRef[0] = bossBar;\n                        } catch (Exception e) {\n                            plugin.logError(\"BossBar oluşturulamadı!\", e);\n                        }\n                    });\n                }\n\n                Runnable sendProgress = () -> {\n                    int percent = Math.min(100, (progress[0] * 100) / finalTotalSteps);\n                    double progressValue = Math.min(1.0, (double) progress[0] / finalTotalSteps);\n\n                    // Rate limit updates - config kontrollü\n                    long currentTime = System.currentTimeMillis();\n                    int updateInterval = plugin.getConfig().getInt(\"progressDisplay.updateInterval\", 500);\n                    if (currentTime - lastUpdateTime[0] < updateInterval) {\n                        return; // Skip this update\n                    }\n                    lastUpdateTime[0] = currentTime;\n\n                    Bukkit.getScheduler().runTask(plugin, () -> {\n                        String progressMsg = String.format(\"🌍 Gezegen Oluşturuluyor... %d%%\", percent);\n                        String progressBar = createProgressBar(percent);\n                        String stepName = getStepName(progress[0], finalTotalSteps);\n\n                        // BOSSBAR - Config kontrollü\n                        if (\"bossbar\".equals(progressType) && bossBarRef[0] != null) {\n                            if (plugin.getConfig().getBoolean(\"progressDisplay.bossbar.updateProgress\", true)) {\n                                bossBarRef[0].setProgress(progressValue);\n                            }\n                            if (plugin.getConfig().getBoolean(\"progressDisplay.bossbar.updateTitle\", true)) {\n                                String titleFormat = plugin.getConfig().getString(\"progressDisplay.bossbar.titleFormat\",\n                                    \"§6🌍 Gezegen Oluşturuluyor... §e{percent}% §7({step})\");\n                                String title = titleFormat.replace(\"{percent}\", String.valueOf(percent))\n                                                         .replace(\"{step}\", stepName);\n                                bossBarRef[0].setTitle(title);\n                            }\n                        }\n                        // ACTIONBAR - Config kontrollü\n                        else if (\"actionbar\".equals(progressType) && plugin.getConfig().getBoolean(\"progressDisplay.actionbar.enabled\", false)) {\n                            String format = plugin.getConfig().getString(\"progressDisplay.actionbar.format\",\n                                \"§e🌍 Gezegen: {percent}% - {step}\");\n                            String message = format.replace(\"{percent}\", String.valueOf(percent))\n                                                 .replace(\"{step}\", stepName);\n                            player.sendActionBar(message);\n                        }\n                        // CHAT - Config kontrollü\n                        else if (\"chat\".equals(progressType) && plugin.getConfig().getBoolean(\"progressDisplay.chat.enabled\", false)) {\n                            if (plugin.getConfig().getBoolean(\"progressDisplay.chat.showStepDetails\", true)) {\n                                String messageFormat = plugin.getConfig().getString(\"progressDisplay.chat.messageFormat\",\n                                    \"§e{step} §7({current}/{total})\");\n                                String message = messageFormat.replace(\"{step}\", stepName)\n                                                            .replace(\"{current}\", String.valueOf(progress[0]))\n                                                            .replace(\"{total}\", String.valueOf(finalTotalSteps));\n                                player.sendMessage(message);\n                            }\n                            if (plugin.getConfig().getBoolean(\"progressDisplay.chat.showProgressBar\", true)) {\n                                player.sendMessage(String.format(\"§b%s §f%d%% §7Tamamlandı\", progressBar, percent));\n                            }\n                        }\n                    });\n                };\n\n                // OPTIMIZE EDILDI: Paralel asteroid/satellite üretimi - PROGRESS İLE\n                 final BlockPlacement[] firstBlockRef = new BlockPlacement[1];\n                 generatePlanetShellAsync(world, orb, shape, biome, () -> {\n                     progress[0]++;\n                     sendProgress.run();\n\n                     // NOW teleport after shell is started - IMMEDIATE TELEPORT\n                     Bukkit.getScheduler().runTask(plugin, () -> {\n                         Location surfaceLoc;\n                         if (firstBlockRef[0] != null) {\n                             // Teleport to the first block position + 1 (on top of it)\n                             surfaceLoc = new Location(world, firstBlockRef[0].x + 0.5, firstBlockRef[0].y + 1, firstBlockRef[0].z + 0.5);\n                         } else {\n                             // Fallback to safe surface location\n                             surfaceLoc = findSafeSurfaceLocation(world, orb);\n                         }\n                         player.teleport(surfaceLoc);\n                         player.sendMessage(\"§aGezegen oluşumu başladı! İlk bloklar yerleştirildi - TP aktif!\");\n                     }); // Immediate teleport when shell starts\n                 }, firstBlockRef, player);\n\n                // INTEGRATED FEATURES - Artık gezegen yapısının bir parçası olarak yukarıda yapıldı!\n                // Ağaçlar, yapılar ve madenler gezegen oluşumu sırasında entegre edildi\n                progress[0]++;\n                sendProgress.run();\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    player.sendMessage(\"§eÖzellikler entegre edildi... ✓ (Gezegen yapısına dahil)\");\n                });\n\n                // HAZİNE GENERATION\n                progress[0]++;\n                sendProgress.run();\n                player.sendMessage(\"§eHazinelar gizleniyor...\");\n\n                List<TreasureGenerator.TreasureLocation> treasures = TreasureGenerator.generateTreasures(orb, biome, world);\n                // FIXED: Treasure chest placement must be in main thread to avoid \"Asynchronous block remove\" error\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    for (TreasureGenerator.TreasureLocation treasure : treasures) {\n                        // Place chest\n                        Block chestBlock = world.getBlockAt(treasure.x, treasure.y, treasure.z);\n                        chestBlock.setType(Material.CHEST, false);\n                        if (chestBlock.getState() instanceof Chest chest) {\n                            TreasureGenerator.fillTreasureChest(chestBlock, treasure.biome, treasure.type, new Random(orb.getSeed() + treasure.x + treasure.y + treasure.z));\n                        }\n                    }\n                });\n\n                // DUNGEON GENERATION\n                progress[0]++;\n                sendProgress.run();\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    player.sendMessage(\"§eZindanlar oluşturuluyor...\");\n                });\n\n                // Generate dungeons inside planet\n                int dungeonCount = Math.max(1, radius / 8);\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    List<com.skyorbs.dungeons.DungeonGenerator.DungeonRoom> dungeons =\n                        plugin.getDungeonGenerator().generateDungeons(orb, dungeonCount);\n                });\n\n                // YENİ: YÜZEY DETAYLARI - Kraterler, kalıntılar, işaretler\n                progress[0]++;\n                sendProgress.run();\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    player.sendMessage(\"§eYüzey detayları ekleniyor...\");\n                });\n\n                generateSurfaceDetails(world, orb, biome, random);\n\n                // YENİ: HALKALAR - Bazı gezegenlerde\n                if (random.nextDouble() < 0.25) { // %25 şans\n                    progress[0]++;\n                    sendProgress.run();\n                    Bukkit.getScheduler().runTask(plugin, () -> {\n                        player.sendMessage(\"§eGezegen halkaları oluşturuluyor...\");\n                    });\n\n                    generatePlanetaryRings(world, orb, random);\n                } else {\n                    // Halka yoksa da progress artır\n                    progress[0]++;\n                    sendProgress.run();\n                }\n\n                // FINALIZATION\n                progress[0]++;\n                sendProgress.run();\n                Bukkit.getScheduler().runTask(plugin, () -> {\n                    player.sendMessage(\"§eSon düzenlemeler yapılıyor...\");\n                });\n\n                // Save main planet\n                plugin.getDatabaseManager().saveOrb(orb);\n\n                // Create planet data folder and files\n                plugin.getPlanetDataManager().createPlanetData(orb);\n\n                // Increment planet counter\n                plugin.incrementPlanetCount();\n\n                // Debug log\n                if (plugin.getConfigManager().isDebugEnabled()) {\n                    plugin.logDebug(\"generation\", String.format(\n                        \"Gezegen oluşturuldu: %s | Şekil: %s | Biyom: %s | Yarıçap: %d | Konum: %d,%d,%d\",\n                        orb.getName(), shape.getName(), biome.name(), radius,\n                        orb.getCenterX(), orb.getCenterY(), orb.getCenterZ()\n                    ));\n                }\n\n                // Teleport player - gerçek gezegen konumuna ve progress display'ı kaldır\n                Bukkit.getScheduler().runTaskLater(plugin, () -> {\n                    // Yüzey bulma algoritması - güvenli teleport (first solid block)\n                    Location surfaceLoc = findSafeSurfaceLocation(world, orb);\n                    player.teleport(surfaceLoc);\n\n                    // Progress display'ı kaldır\n                    if (\"bossbar\".equals(progressType) && bossBarRef[0] != null) {\n                        bossBarRef[0].setVisible(false);\n                        bossBarRef[0].removeAll();\n                    }\n\n                    String shapeName = plugin.getShapeRegistry().getShape(orb.getShapeName()).getDisplayName();\n                    player.sendMessage(\"§a§lGezegen Tamamen Oluşturuldu!\");\n                    player.sendMessage(String.format(\"§aGezegen: §e%s §7(%s, %s)\",\n                        orb.getName(), shapeName, orb.getBiomeName()\n                    ));\n                    player.sendMessage(String.format(\"§aKonum: §f%d, %d, %d §7| Yarıçap: §f%d\",\n                        orb.getCenterX(), orb.getCenterY(), orb.getCenterZ(), orb.getRadius()\n                    ));\n                }, 5L);\n\n            } catch (Exception e) {\n                plugin.logError(\"Gezegen oluşturma hatası\", e);\n                Bukkit.getScheduler().runTask(plugin, () ->\n                    player.sendMessage(\"§cHata: \" + e.getMessage())\n                );\n            } finally {\n                // FIXED: Always release location, even on error - prevents memory leak!\n                if (placement != null && placement.isSuccess()) {\n                    placementService.releaseLocation(placement.getX(), placement.getZ());\n                }\n            }\n        });\n    }\n    \n    /**\n     * ÇEŞİTLİ GEZEGEN ÜRETİMİ - Bazı dolu, bazı içi boş!\n     * Rastgele olarak içi boş veya dolu gezegenler oluştur\n     */\n    private void generatePlanetShellAsync(World world, Orb orb, PlanetShape shape, BiomeType biome, Runnable callback) {\n        generatePlanetShellAsync(world, orb, shape, biome, callback, null, null);\n    }\n\n    /**\n     * ÇEŞİTLİ GEZEGEN ÜRETİMİ - Bazı dolu, bazı içi boş!\n     * Rastgele olarak içi boş veya dolu gezegenler oluştur\n     */\n    private void generatePlanetShellAsync(World world, Orb orb, PlanetShape shape, BiomeType biome, Runnable callback, BlockPlacement firstBlockRef[], Player player) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n        Random random = new Random(seed);\n\n        // GEZEGEN TİPİ BELİRLE - Use modifier system\n        boolean isHollow = orb.isHollow(); // Check if HOLLOW modifier is present\n\n        // 1. PLANET GENERATION (Async) - ÇEŞİTLİ TİPTE GEZEGENLER! - PERFORMANCE OPTIMIZED\n         CompletableFuture.supplyAsync(() -> {\n             PlanetGenerationResult result;\n\n             // PERFORMANCE: Daha hızlı generation için optimized algoritmalar\n             if (isHollow) {\n                 // HOLLOW PLANET - İçi boş, kalın kabuk\n                 result = generateHollowPlanet(cx, cy, cz, radius, seed, shape, biome, random);\n             } else {\n                 // SOLID PLANET - Tam dolu, klasik\n                 result = generateSolidPlanet(cx, cy, cz, radius, seed, shape, biome, random);\n             }\n\n             return result;\n         }, executor).thenAcceptAsync(result -> {\n             List<BlockPlacement> blocks = result.blocks;\n             BlockPlacement firstBlock = result.firstBlock;\n\n             // Store first block reference if provided\n             if (firstBlockRef != null && firstBlockRef.length > 0) {\n                 firstBlockRef[0] = firstBlock;\n             }\n\n             // Progress: Shell tamamlandı\n             if (callback != null) {\n                 // İlk blokları hemen yerleştir (görsel feedback) - MAIN THREAD'DE\n                 List<BlockPlacement> firstBlocks = blocks.subList(0, Math.min(100, blocks.size()));\n                 Bukkit.getScheduler().runTask(plugin, () -> {\n                     for (BlockPlacement bp : firstBlocks) {\n                         try {\n                             Block block = world.getBlockAt(bp.x, bp.y, bp.z);\n                             if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                                 block.setType(bp.material, false);\n                             }\n                         } catch (Exception e) {\n                             // Skip\n                         }\n                     }\n\n                     // İlk blok yerleştirildiğinde player'a mesaj gönder\n                     if (player != null && firstBlockRef != null && firstBlockRef.length > 0 && firstBlockRef[0] != null) {\n                         player.sendMessage(\"§aGezegen oluşumu başladı! İlk blok yerleştirildi - TP aktif!\");\n                     }\n                 });\n             }\n\n             // 5. PLACE PLANET BLOCKS FIRST - Progress ile\n             placeBlocksInBatches(world, blocks, () -> {\n                 // Shell placement tamamlandıktan sonra callback çalıştır\n                 if (callback != null) {\n                     callback.run();\n                 }\n             });\n\n         }, executor);\n    }\n\n    /**\n     * SOLID PLANET - Tam dolu klasik gezegen (WITH INTEGRATED ORE, TREE, AND STRUCTURE GENERATION) - PERFORMANCE OPTIMIZED\n     */\n    private PlanetGenerationResult generateSolidPlanet(int cx, int cy, int cz,\n                                       int radius, long seed, PlanetShape shape, BiomeType biome, Random random) {\n\n        com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n        List<BlockPlacement> blocks = new ArrayList<>();\n        BlockPlacement firstBlock = null;\n\n        // PERFORMANCE: Önce gerekli kapasiteyi ayır\n        int estimatedBlocks = (int)((4.0 / 3.0) * Math.PI * radius * radius * radius * 1.1);\n        blocks = new ArrayList<>(estimatedBlocks);\n\n        // PERFORMANCE: Generate planet blocks AND ores together as part of the planet structure\n        // Optimize edilmiş loop - daha az sqrt hesaplaması\n        double radiusSquared = radius * radius;\n        double coreRadiusSquared = (radius * 0.15) * (radius * 0.15);\n\n        // INTEGRATED TREE AND STRUCTURE GENERATION - Generate within planet volume\n        List<OreGenerator.BlockData> integratedTrees = generateTreesWithinPlanet(cx, cy, cz, radius, seed, biome, random);\n        List<OreGenerator.BlockData> integratedStructures = generateStructuresWithinPlanet(cx, cy, cz, radius, seed, biome, random);\n\n        for (int y = radius; y >= -radius; y--) {\n            double ySquared = y * y;\n            for (int x = -radius; x <= radius; x++) {\n                double xySquared = x * x + ySquared;\n                if (xySquared > radiusSquared) continue; // Erken çık\n\n                for (int z = -radius; z <= radius; z++) {\n                    double distanceSquared = xySquared + z * z;\n\n                    if (distanceSquared <= radiusSquared) {\n                        if (shape.isBlockPart(x, y, z, radius, seed)) {\n                            double distance = Math.sqrt(distanceSquared); // Sadece gerektiğinde sqrt\n                            int depth = (int)(radius - distance);\n\n                            // NEW: Use noise for coherent regional block selection\n                            double noiseValue = com.skyorbs.utils.NoiseGenerator.getNoise3D(\n                                (cx + x) * 0.01, (cy + y) * 0.01, (cz + z) * 0.01, seed\n                            );\n                            // Normalize noise to 0-1 range\n                            noiseValue = (noiseValue + 1.0) / 2.0;\n\n                            Material material = palette.getMaterialByDepthAndNoise(depth, noiseValue, random);\n\n                            // CHECK FOR INTEGRATED TREES AND STRUCTURES FIRST\n                            Material integratedMaterial = getIntegratedFeatureMaterial(cx + x, cy + y, cz + z, integratedTrees, integratedStructures);\n                            if (integratedMaterial != null) {\n                                material = integratedMaterial;\n                            } else {\n                                // ORE GENERATION - OVERWORLD STYLE\n                                Material oreMaterial = OreGenerator.tryGenerateOre(\n                                    cx + x, cy + y, cz + z,\n                                    distance,  // distanceFromCenter\n                                    radius,    // planet radius\n                                    biome,     // biome type\n                                    random     // random\n                                );\n\n                                if (oreMaterial != null) {\n                                    material = oreMaterial;\n                                }\n\n                                // TAŞ VARİANTLARI (çeşitlilik için)\n                                Material originalMaterial = palette.getMaterialByDepthAndNoise(depth, noiseValue, random);\n                                if (material == originalMaterial) {\n                                    Material stoneVariant = OreGenerator.getStoneVariant(biome, random);\n                                    if (stoneVariant != null) {\n                                        material = stoneVariant;\n                                    }\n                                }\n                            }\n\n                            BlockPlacement block = new BlockPlacement(cx + x, cy + y, cz + z, material);\n                            blocks.add(block);\n\n                            // Track first block (highest y, then closest to center)\n                            if (firstBlock == null ||\n                                block.y > firstBlock.y ||\n                                (block.y == firstBlock.y && distanceSquared < ((firstBlock.x - cx) * (firstBlock.x - cx) + (firstBlock.z - cz) * (firstBlock.z - cz)))) {\n                                firstBlock = block;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return new PlanetGenerationResult(blocks, firstBlock);\n    }\n\n    /**\n     * Generate special core materials for planet centers\n     */\n    private Material generateCoreMaterial(int depth, BiomeType biome, Random random) {\n        // Core materials based on biome type\n        return switch (biome) {\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                // Volcanic core - nether materials\n                yield random.nextDouble() < 0.3 ? Material.ANCIENT_DEBRIS :\n                      random.nextDouble() < 0.5 ? Material.NETHERITE_BLOCK :\n                      Material.MAGMA_BLOCK;\n            }\n            case CRYSTAL_FOREST, CRYSTALLINE -> {\n                // Crystal core - valuable gems\n                yield random.nextDouble() < 0.4 ? Material.DIAMOND_BLOCK :\n                      random.nextDouble() < 0.6 ? Material.EMERALD_BLOCK :\n                      Material.AMETHYST_BLOCK;\n            }\n            case VOID -> {\n                // Void core - mysterious materials\n                yield random.nextDouble() < 0.5 ? Material.END_STONE :\n                      random.nextDouble() < 0.75 ? Material.OBSIDIAN :\n                      Material.CRYING_OBSIDIAN;\n            }\n            case CORRUPTED -> {\n                // Corrupted core - warped materials\n                yield random.nextDouble() < 0.4 ? Material.WARPED_WART_BLOCK :\n                      random.nextDouble() < 0.7 ? Material.NETHER_WART_BLOCK :\n                      Material.SHROOMLIGHT;\n            }\n            default -> {\n                // Standard core - rare metals\n                yield random.nextDouble() < 0.3 ? Material.DIAMOND_BLOCK :\n                      random.nextDouble() < 0.6 ? Material.GOLD_BLOCK :\n                      Material.IRON_BLOCK;\n            }\n        };\n    }\n\n\n    /**\n     * HOLLOW PLANET - NO ORES (only in shell if enabled) - PERFORMANCE OPTIMIZED\n     */\n    private PlanetGenerationResult generateHollowPlanet(int cx, int cy, int cz,\n                                       int radius, long seed, PlanetShape shape, BiomeType biome, Random random) {\n\n        int shellThickness = plugin.getConfig().getInt(\"modifiers.hollow.shellThickness\", 5);\n        com.skyorbs.palettes.PlanetPalette palette = plugin.getPaletteRegistry().getRandomPalette(random);\n        List<BlockPlacement> blocks = new ArrayList<>();\n        BlockPlacement firstBlock = null;\n\n        // PERFORMANCE: Önce kapasite ayır\n        double shellVolume = (4.0 / 3.0) * Math.PI * (Math.pow(radius, 3) - Math.pow(radius - shellThickness, 3));\n        blocks = new ArrayList<>((int)(shellVolume * 1.1));\n\n        // PERFORMANCE: Optimize edilmiş shell generation\n        double outerRadiusSquared = radius * radius;\n        double innerRadiusSquared = (radius - shellThickness) * (radius - shellThickness);\n\n        for (int y = radius; y >= -radius; y--) {\n            double ySquared = y * y;\n            for (int x = -radius; x <= radius; x++) {\n                double xySquared = x * x + ySquared;\n                if (xySquared > outerRadiusSquared) continue; // Erken çık\n\n                for (int z = -radius; z <= radius; z++) {\n                    double distanceSquared = xySquared + z * z;\n\n                    // SHELL ONLY - from surface to shellThickness blocks inward\n                    if (distanceSquared <= outerRadiusSquared && distanceSquared >= innerRadiusSquared) {\n                        if (shape.isBlockPart(x, y, z, radius, seed)) {\n                            double distance = Math.sqrt(distanceSquared);\n                            int depth = (int)(radius - distance);\n\n                            // NEW: Use noise for coherent regional block selection\n                            double noiseValue = com.skyorbs.utils.NoiseGenerator.getNoise3D(\n                                (cx + x) * 0.01, (cy + y) * 0.01, (cz + z) * 0.01, seed\n                            );\n                            // Normalize noise to 0-1 range\n                            noiseValue = (noiseValue + 1.0) / 2.0;\n\n                            Material material = palette.getMaterialByDepthAndNoise(depth, noiseValue, random);\n\n                            // OPTIONAL: Allow ores in hollow planet shells (CONFIG)\n                            if (plugin.getConfig().getBoolean(\"features.ores.hollowPlanetSpawn\", false)) {\n                                Material oreMaterial = OreGenerator.tryGenerateOre(\n                                    cx + x, cy + y, cz + z, distance, radius, biome, random\n                                );\n                                if (oreMaterial != null) {\n                                    material = oreMaterial;\n                                }\n                            }\n\n                            BlockPlacement block = new BlockPlacement(cx + x, cy + y, cz + z, material);\n                            blocks.add(block);\n\n                            // Track first block (highest y, then closest to center)\n                            if (firstBlock == null ||\n                                block.y > firstBlock.y ||\n                                (block.y == firstBlock.y && distanceSquared < ((firstBlock.x - cx) * (firstBlock.x - cx) + (firstBlock.z - cz) * (firstBlock.z - cz)))) {\n                                firstBlock = block;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Generate interior structures\n        generateInteriorStructures(blocks, cx, cy, cz, radius, seed, biome, random);\n        generateInteriorTunnels(blocks, cx, cy, cz, radius, seed, biome, random);\n\n        return new PlanetGenerationResult(blocks, firstBlock);\n    }\n\n    /**\n     * Generate interior structures for civilization feeling in hollow planets\n     */\n    private void generateInteriorStructures(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        int structureCount = Math.max(2, radius / 6); // Structures per planet size\n\n        for (int i = 0; i < structureCount; i++) {\n            // Generate structure positions within the hollow interior\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = (random.nextDouble() - 0.5) * Math.PI / 3; // -30 to +30 degrees\n            double distance = radius * 0.3 + random.nextDouble() * radius * 0.4; // 30-70% from center\n\n            int structX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * distance);\n            int structY = cy + (int)(Math.sin(angle2) * distance);\n            int structZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * distance);\n\n            // Generate different types of interior structures\n            generateInteriorStructure(blocks, structX, structY, structZ, biome, random);\n        }\n    }\n\n    /**\n     * Generate a single interior structure\n     */\n    private void generateInteriorStructure(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        int structureType = random.nextInt(4); // 4 different structure types\n\n        switch (structureType) {\n            case 0 -> generateInteriorRuins(blocks, x, y, z, biome, random);\n            case 1 -> generateInteriorLab(blocks, x, y, z, biome, random);\n            case 2 -> generateInteriorTemple(blocks, x, y, z, biome, random);\n            case 3 -> generateInteriorHabitat(blocks, x, y, z, biome, random);\n        }\n    }\n\n    /**\n     * Generate interior ruins\n     */\n    private void generateInteriorRuins(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material floorMat = getBiomeFloorMaterial(biome);\n\n        // Small ruined room (5x5x3)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -2; dz <= 2; dz++) {\n                // Floor\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                // Partial walls (some broken)\n                if (random.nextDouble() < 0.7) {\n                    blocks.add(new BlockPlacement(x + dx, y + 1, z + dz, wallMat));\n                }\n                if (random.nextDouble() < 0.5) {\n                    blocks.add(new BlockPlacement(x + dx, y + 2, z + dz, wallMat));\n                }\n            }\n        }\n\n        // Add some debris\n        for (int i = 0; i < 3; i++) {\n            int debrisX = x + random.nextInt(5) - 2;\n            int debrisZ = z + random.nextInt(5) - 2;\n            blocks.add(new BlockPlacement(debrisX, y + 1, debrisZ, Material.COBBLESTONE));\n        }\n    }\n\n    /**\n     * Generate interior lab/research facility\n     */\n    private void generateInteriorLab(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = Material.IRON_BLOCK;\n        Material floorMat = Material.STONE;\n\n        // Lab room (6x6x4)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                if (Math.abs(dx) == 3 || Math.abs(dz) == 3) {\n                    for (int dy = 1; dy <= 3; dy++) {\n                        blocks.add(new BlockPlacement(x + dx, y + dy, z + dz, wallMat));\n                    }\n                }\n            }\n        }\n\n        // Lab equipment\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.CRAFTING_TABLE));\n        blocks.add(new BlockPlacement(x + 1, y + 1, z + 1, Material.BREWING_STAND));\n        blocks.add(new BlockPlacement(x - 1, y + 1, z - 1, Material.FURNACE));\n\n        // Add some glowing elements for atmosphere\n        if (biome == BiomeType.LUMINOUS || biome == BiomeType.GLOWSTONE_CAVERN) {\n            blocks.add(new BlockPlacement(x, y + 3, z, Material.SEA_LANTERN));\n        }\n    }\n\n    /**\n     * Generate interior temple/shrine\n     */\n    private void generateInteriorTemple(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material pillarMat = Material.QUARTZ_BLOCK;\n\n        // Temple platform (7x7)\n        for (int dx = -3; dx <= 3; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, Material.QUARTZ_BLOCK));\n            }\n        }\n\n        // Corner pillars\n        int[][] corners = {{-3, -3}, {3, -3}, {-3, 3}, {3, 3}};\n        for (int[] corner : corners) {\n            for (int dy = 1; dy <= 4; dy++) {\n                blocks.add(new BlockPlacement(x + corner[0], y + dy, z + corner[1], pillarMat));\n            }\n        }\n\n        // Central altar\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.ENCHANTING_TABLE));\n        blocks.add(new BlockPlacement(x, y + 2, z, Material.END_ROD));\n    }\n\n    /**\n     * Generate interior habitat/living quarters\n     */\n    private void generateInteriorHabitat(List<BlockPlacement> blocks, int x, int y, int z, BiomeType biome, Random random) {\n        Material wallMat = getBiomeWallMaterial(biome);\n        Material floorMat = getBiomeFloorMaterial(biome);\n\n        // Living quarters (4x6x3)\n        for (int dx = -2; dx <= 2; dx++) {\n            for (int dz = -3; dz <= 3; dz++) {\n                blocks.add(new BlockPlacement(x + dx, y, z + dz, floorMat));\n                if (Math.abs(dx) == 2 || Math.abs(dz) == 3) {\n                    for (int dy = 1; dy <= 2; dy++) {\n                        blocks.add(new BlockPlacement(x + dx, y + dy, z + dz, wallMat));\n                    }\n                }\n            }\n        }\n\n        // Furniture\n        blocks.add(new BlockPlacement(x - 1, y + 1, z - 2, Material.CHEST));\n        blocks.add(new BlockPlacement(x + 1, y + 1, z + 2, Material.CRAFTING_TABLE));\n        blocks.add(new BlockPlacement(x, y + 1, z, Material.RED_BED));\n    }\n\n    /**\n     * Get biome-appropriate wall material\n     */\n    private Material getBiomeWallMaterial(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> Material.AMETHYST_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> Material.NETHER_BRICKS;\n            case VOID -> Material.OBSIDIAN;\n            case CORRUPTED -> Material.WARPED_PLANKS;\n            case TOXIC_SWAMP, TOXIC -> Material.GREEN_CONCRETE;\n            case LUMINOUS -> Material.SEA_LANTERN;\n            default -> Material.STONE_BRICKS;\n        };\n    }\n\n    /**\n     * Get biome-appropriate floor material\n     */\n    private Material getBiomeFloorMaterial(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> Material.PURPUR_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> Material.BLACKSTONE;\n            case VOID -> Material.END_STONE;\n            case CORRUPTED -> Material.CRIMSON_PLANKS;\n            case TOXIC_SWAMP, TOXIC -> Material.LIME_CONCRETE;\n            case LUMINOUS -> Material.GLOWSTONE;\n            default -> Material.STONE;\n        };\n    }\n\n    /**\n     * Generate connecting tunnels between interior structures\n     */\n    private void generateInteriorTunnels(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        int tunnelCount = Math.max(3, radius / 5);\n\n        for (int i = 0; i < tunnelCount; i++) {\n            // Tunnel starting from surface inward\n            double angle1 = random.nextDouble() * Math.PI * 2;\n            double angle2 = random.nextDouble() * Math.PI / 2 - Math.PI / 4;\n            double startDistance = radius - 2;\n\n            int startX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * startDistance);\n            int startY = cy + (int)(Math.sin(angle2) * startDistance);\n            int startZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * startDistance);\n\n            // Tunnel direction\n            double tunnelAngle1 = random.nextDouble() * Math.PI * 2;\n            double tunnelAngle2 = (random.nextDouble() - 0.5) * Math.PI / 3;\n\n            int tunnelLength = 5 + random.nextInt(Math.max(5, radius / 2));\n\n            // Create tunnel\n            for (int step = 0; step < tunnelLength; step++) {\n                int tunnelX = startX + (int)(Math.cos(tunnelAngle1) * Math.cos(tunnelAngle2) * step);\n                int tunnelY = startY + (int)(Math.sin(tunnelAngle2) * step);\n                int tunnelZ = startZ + (int)(Math.sin(tunnelAngle1) * Math.cos(tunnelAngle2) * step);\n\n                int tunnelRadius = 1 + random.nextInt(2);\n\n                for (int dx = -tunnelRadius; dx <= tunnelRadius; dx++) {\n                    for (int dy = -tunnelRadius; dy <= tunnelRadius; dy++) {\n                        for (int dz = -tunnelRadius; dz <= tunnelRadius; dz++) {\n                            double dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                            if (dist <= tunnelRadius) {\n                                double planetDist = Math.sqrt((tunnelX + dx - cx) * (tunnelX + dx - cx) +\n                                                             (tunnelY + dy - cy) * (tunnelY + dy - cy) +\n                                                             (tunnelZ + dz - cz) * (tunnelZ + dz - cz));\n                                if (planetDist <= radius - 1) {\n                                    blocks.add(new BlockPlacement(tunnelX + dx, tunnelY + dy, tunnelZ + dz, Material.AIR));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Async chunk loading with completion waiting - ULTRA OPTIMIZE EDILDI\n     */\n    private CompletableFuture<Void> loadChunksAsync(World world, Set<ChunkPos> chunks) {\n        if (chunks.isEmpty()) {\n            return CompletableFuture.completedFuture(null);\n        }\n\n        List<CompletableFuture<Void>> futures = new ArrayList<>();\n\n        // PERFORMANCE: Chunk'ları paralel yükle ama daha akıllı\n        int maxConcurrentLoads = Math.min(chunks.size(), 8); // Max 8 chunk aynı anda\n        List<ChunkPos> chunkList = new ArrayList<>(chunks);\n\n        for (int i = 0; i < chunkList.size(); i += maxConcurrentLoads) {\n            int end = Math.min(i + maxConcurrentLoads, chunkList.size());\n            List<ChunkPos> batch = chunkList.subList(i, end);\n\n            CompletableFuture<Void> batchFuture = CompletableFuture.runAsync(() -> {\n                for (ChunkPos pos : batch) {\n                    if (!world.isChunkLoaded(pos.x, pos.z)) {\n                        // PERFORMANCE: Sync chunk loading with error handling\n                        try {\n                            Bukkit.getScheduler().runTask(plugin, () -> {\n                                try {\n                                    world.loadChunk(pos.x, pos.z, true); // Force load\n                                } catch (Exception e) {\n                                    // Chunk yüklenemedi - sessizce geç\n                                }\n                            }); // Remove the get/join call entirely\n                        } catch (Exception e) {\n                            // Timeout veya diğer hatalar - devam et\n                        }\n                    }\n                }\n            }, executor);\n\n            futures.add(batchFuture);\n        }\n\n        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n    }\n\n    /**\n     * Blokları batch'ler halinde yerleştirir (chunk-aware) - ULTRA OPTIMIZE EDILDI\n     */\n    private void placeBlocksInBatches(World world, List<BlockPlacement> blocks, Runnable callback) {\n        placeBlocksInBatches(world, blocks, callback, false);\n    }\n\n    /**\n     * Blokları batch'ler halinde yerleştirir (chunk-aware) - ULTRA OPTIMIZE EDILDI\n     * @param allowReplacement Eğer true ise mevcut blokları değiştirir (ore'lar için)\n     */\n    private void placeBlocksInBatches(World world, List<BlockPlacement> blocks, Runnable callback, boolean allowReplacement) {\n        if (blocks.isEmpty()) {\n            if (callback != null) callback.run();\n            return;\n        }\n\n        int batchSize = Math.max(100, plugin.getConfigManager().getBlocksPerBatch()); // Minimum 100 blok/batch\n        int totalBatches = (blocks.size() + batchSize - 1) / batchSize;\n\n        // PERFORMANCE: Chunk'ları daha akıllı yükle - sadece gerekli chunk'ları\n        Set<ChunkPos> chunksToLoad = new HashSet<>();\n        for (BlockPlacement bp : blocks) {\n            chunksToLoad.add(new ChunkPos(bp.x >> 4, bp.z >> 4));\n        }\n\n        // PERFORMANCE: Chunk yükleme - paralel ve daha hızlı\n        loadChunksAsync(world, chunksToLoad).thenRun(() -> {\n            // PERFORMANCE: Batch placement - daha sık batch'ler ve daha hızlı\n            int batchesPerTick = Math.max(2, plugin.getConfigManager().getBatchesPerTick()); // Minimum 2 batch/tick\n            int totalDelay = 0;\n\n            for (int i = 0; i < totalBatches; i++) {\n                int start = i * batchSize;\n                int end = Math.min(start + batchSize, blocks.size());\n                List<BlockPlacement> batch = blocks.subList(start, end);\n\n                // PERFORMANCE: Daha sık batch'ler için delay hesapla\n                if (i % batchesPerTick == 0) {\n                    totalDelay++;\n                }\n\n                final int currentDelay = totalDelay;\n\n                Bukkit.getScheduler().runTaskLater(plugin, () -> {\n                    // PERFORMANCE: Bulk block placement - daha hızlı setType\n                    for (BlockPlacement bp : batch) {\n                        try {\n                            Block block = world.getBlockAt(bp.x, bp.y, bp.z);\n                            if (allowReplacement || block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                                block.setType(bp.material, false);\n                            }\n                        } catch (Exception e) {\n                            // Chunk yüklü değilse skip - daha az log\n                        }\n                    }\n                }, currentDelay);\n            }\n\n            // PERFORMANCE: Callback'i daha erken çağır - tüm batch'lerin %80'i tamamlandıktan sonra\n            if (callback != null) {\n                int callbackDelay = Math.max(1, totalDelay / 2);\n                Bukkit.getScheduler().runTaskLater(plugin, callback, callbackDelay);\n            }\n        });\n    }\n    \n    public CompletableFuture<Void> deletePlanet(Orb orb) {\n        CompletableFuture<Void> future = new CompletableFuture<>();\n        \n        executor.submit(() -> {\n            try {\n                // Delete children first\n                List<Orb> children = plugin.getDatabaseManager().getChildOrbs(orb.getId());\n                for (Orb child : children) {\n                    clearPlanetBlocks(orb);\n                    plugin.getDatabaseManager().deleteOrb(child.getId());\n                }\n                \n                // Delete main planet\n                clearPlanetBlocks(orb);\n                plugin.getDatabaseManager().deleteOrb(orb.getId());\n\n                // Delete planet data folder\n                plugin.getPlanetDataManager().deletePlanetData(orb.getId());\n\n                future.complete(null);\n                \n            } catch (Exception e) {\n                future.completeExceptionally(e);\n            }\n        });\n        \n        return future;\n    }\n    \n    /**\n     * Gezegen bloklarını temizler\n     */\n    private void clearPlanetBlocks(Orb orb) {\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world == null) return;\n        \n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        \n        List<BlockPlacement> airBlocks = new ArrayList<>();\n        \n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n                    if (distance <= radius) {\n                        airBlocks.add(new BlockPlacement(cx + x, cy + y, cz + z, Material.AIR));\n                    }\n                }\n            }\n        }\n        \n        placeBlocksInBatches(world, airBlocks, null);\n    }\n    \n    /**\n     * Güvenli ilk teleport konumu - gezegen oluşurken güvenli yüzey bulma\n     */\n    private Location findSafeInitialTeleportLocation(World world, int cx, int cy, int cz, int radius) {\n        // Gezegenin üst kısmından başlayarak aşağı doğru tara - find first solid block\n        // Daha geniş arama alanı ve daha güvenilir algoritma\n        for (int y = cy + radius + 5; y >= cy - radius; y--) {\n            // Spiral search pattern for better coverage\n            for (int searchRadius = 0; searchRadius <= 8; searchRadius++) {\n                for (int angle = 0; angle < 360; angle += 45) {\n                    double radian = Math.toRadians(angle);\n                    int x = cx + (int)(Math.cos(radian) * searchRadius);\n                    int z = cz + (int)(Math.sin(radian) * searchRadius);\n\n                    // Check if this position is on the planet surface\n                    double distanceFromCenter = Math.sqrt((x - cx) * (x - cx) + (z - cz) * (z - cz));\n                    if (distanceFromCenter > radius + 2) continue; // Too far from planet\n\n                    Block block = world.getBlockAt(x, y, z);\n                    Block below = world.getBlockAt(x, y - 1, z);\n                    Block twoBelow = world.getBlockAt(x, y - 2, z);\n\n                    // Katı blok üzerinde hava varsa güvenli konum\n                    if (block.getType() == Material.AIR &&\n                        below.getType().isSolid() &&\n                        twoBelow.getType().isSolid() &&\n                        !isDangerousBlock(below.getType()) &&\n                        !isDangerousBlock(twoBelow.getType())) {\n\n                        // Extra check: make sure there's enough space above\n                        boolean hasSpace = true;\n                        for (int checkY = y + 1; checkY <= y + 2; checkY++) {\n                            if (world.getBlockAt(x, checkY, z).getType() != Material.AIR) {\n                                hasSpace = false;\n                                break;\n                            }\n                        }\n\n                        if (hasSpace) {\n                            return new Location(world, x + 0.5, y, z + 0.5);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Fallback: Try center top\n        for (int y = cy + radius + 5; y >= cy + radius - 10; y--) {\n            Block block = world.getBlockAt(cx, y, cz);\n            Block below = world.getBlockAt(cx, y - 1, cz);\n\n            if (block.getType() == Material.AIR && below.getType().isSolid() && !isDangerousBlock(below.getType())) {\n                return new Location(world, cx + 0.5, y, cz + 0.5);\n            }\n        }\n\n        // Ultimate fallback\n        return new Location(world, cx, cy + radius + 10, cz);\n    }\n\n    /**\n     * Güvenli yüzey konumu bulma algoritması - First solid block teleport\n     */\n    private Location findSafeSurfaceLocation(World world, Orb orb) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Gezegenin üst kısmından başlayarak aşağı doğru tara - find first solid block\n        for (int y = cy + radius; y >= cy - radius; y--) {\n            for (int x = cx - 3; x <= cx + 3; x++) {\n                for (int z = cz - 3; z <= cz + 3; z++) {\n                    Block block = world.getBlockAt(x, y, z);\n                    Block below = world.getBlockAt(x, y - 1, z);\n\n                    // Katı blok üzerinde hava varsa güvenli konum (first solid block found)\n                    if (block.getType() == Material.AIR && below.getType().isSolid() &&\n                        !isDangerousBlock(below.getType())) {\n                        return new Location(world, x + 0.5, y, z + 0.5);\n                    }\n                }\n            }\n        }\n\n        // Bulunamazsa varsayılan konum (fallback)\n        return new Location(world, cx, cy + radius + 5, cz);\n    }\n\n    /**\n     * Check if block is dangerous for teleportation\n     */\n    private boolean isDangerousBlock(Material material) {\n        return material == Material.LAVA ||\n               material == Material.FIRE ||\n               material == Material.CACTUS ||\n               material == Material.SWEET_BERRY_BUSH ||\n               material.name().contains(\"MAGMA\");\n    }\n\n    /**\n     * YENİ: Yüzey detayları - Kraterler, kalıntılar, işaretler\n     */\n    private void generateSurfaceDetails(World world, Orb orb, BiomeType biome, Random random) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        \n        List<BlockPlacement> surfaceBlocks = new ArrayList<>();\n        \n        // 1. KRATERLER - Çarpma izleri\n        int craterCount = 3 + random.nextInt(5);\n        for (int i = 0; i < craterCount; i++) {\n            generateCrater(surfaceBlocks, cx, cy, cz, radius, random);\n        }\n        \n        // 2. YÜZEY YAPILARI - Eski uygarlık kalıntıları\n        int ruinCount = 2 + random.nextInt(3);\n        for (int i = 0; i < ruinCount; i++) {\n            generateSurfaceRuin(surfaceBlocks, cx, cy, cz, radius, biome, random);\n        }\n        \n        // 3. İŞARETLER - Beacon, totem, anıtlar\n        int monumentCount = 1 + random.nextInt(2);\n        for (int i = 0; i < monumentCount; i++) {\n            generateMonument(surfaceBlocks, cx, cy, cz, radius, biome, random);\n        }\n        \n        // 4. YÜZEY DETAYLARI - Kayalar, kristaller\n        int detailCount = 10 + random.nextInt(20);\n        for (int i = 0; i < detailCount; i++) {\n            generateSurfaceDetail(surfaceBlocks, cx, cy, cz, radius, biome, random);\n        }\n        \n        // Blokları yerleştir\n        placeBlocksInBatches(world, surfaceBlocks, null);\n    }\n    \n    /**\n     * Krater oluştur\n     */\n    private void generateCrater(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, Random random) {\n        // Yüzeyde rastgele konum\n        double angle1 = random.nextDouble() * Math.PI * 2;\n        double angle2 = (random.nextDouble() - 0.5) * Math.PI / 2;\n        \n        int craterX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * radius);\n        int craterY = cy + (int)(Math.sin(angle2) * radius);\n        int craterZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * radius);\n        \n        int craterRadius = 3 + random.nextInt(5);\n        int craterDepth = 2 + random.nextInt(3);\n        \n        // Krater çukuru\n        for (int x = -craterRadius; x <= craterRadius; x++) {\n            for (int z = -craterRadius; z <= craterRadius; z++) {\n                double dist = Math.sqrt(x * x + z * z);\n                if (dist <= craterRadius) {\n                    int depth = (int)(craterDepth * (1 - dist / craterRadius));\n                    for (int y = 0; y < depth; y++) {\n                        blocks.add(new BlockPlacement(craterX + x, craterY - y, craterZ + z, Material.AIR));\n                    }\n                    // Krater kenarı - yükseltilmiş\n                    if (dist > craterRadius - 2 && dist <= craterRadius) {\n                        blocks.add(new BlockPlacement(craterX + x, craterY + 1, craterZ + z, Material.COBBLESTONE));\n                    }\n                }\n            }\n        }\n    }\n    \n    /**\n     * Yüzey kalıntısı oluştur\n     */\n    private void generateSurfaceRuin(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, BiomeType biome, Random random) {\n        double angle1 = random.nextDouble() * Math.PI * 2;\n        double angle2 = (random.nextDouble() - 0.5) * Math.PI / 2;\n        \n        int ruinX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * radius);\n        int ruinY = cy + (int)(Math.sin(angle2) * radius);\n        int ruinZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * radius);\n        \n        Material ruinMat = getBiomeWallMaterial(biome);\n        \n        // Küçük yıkık yapı (3x3)\n        for (int x = -1; x <= 1; x++) {\n            for (int z = -1; z <= 1; z++) {\n                if (random.nextDouble() < 0.6) { // Bazı bloklar eksik\n                    blocks.add(new BlockPlacement(ruinX + x, ruinY + 1, ruinZ + z, ruinMat));\n                    if (random.nextDouble() < 0.3) {\n                        blocks.add(new BlockPlacement(ruinX + x, ruinY + 2, ruinZ + z, ruinMat));\n                    }\n                }\n            }\n        }\n        \n        // Merkeze sandık\n        blocks.add(new BlockPlacement(ruinX, ruinY + 1, ruinZ, Material.CHEST));\n    }\n    \n    /**\n     * Anıt oluştur\n     */\n    private void generateMonument(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, BiomeType biome, Random random) {\n        double angle1 = random.nextDouble() * Math.PI * 2;\n        double angle2 = (random.nextDouble() - 0.5) * Math.PI / 2;\n        \n        int monX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * radius);\n        int monY = cy + (int)(Math.sin(angle2) * radius);\n        int monZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * radius);\n        \n        // Dikey anıt (totem benzeri)\n        Material pillarMat = Material.QUARTZ_PILLAR;\n        int height = 5 + random.nextInt(5);\n        \n        for (int y = 1; y <= height; y++) {\n            blocks.add(new BlockPlacement(monX, monY + y, monZ, pillarMat));\n        }\n        \n        // Üste beacon veya glowstone\n        blocks.add(new BlockPlacement(monX, monY + height + 1, monZ, Material.BEACON));\n        \n        // Etrafına platform\n        for (int x = -1; x <= 1; x++) {\n            for (int z = -1; z <= 1; z++) {\n                if (x != 0 || z != 0) {\n                    blocks.add(new BlockPlacement(monX + x, monY + 1, monZ + z, Material.STONE_BRICKS));\n                }\n            }\n        }\n    }\n    \n    /**\n     * Yüzey detayı oluştur\n     */\n    private void generateSurfaceDetail(List<BlockPlacement> blocks, int cx, int cy, int cz, int radius, BiomeType biome, Random random) {\n        double angle1 = random.nextDouble() * Math.PI * 2;\n        double angle2 = (random.nextDouble() - 0.5) * Math.PI / 2;\n        \n        int detailX = cx + (int)(Math.cos(angle1) * Math.cos(angle2) * radius);\n        int detailY = cy + (int)(Math.sin(angle2) * radius);\n        int detailZ = cz + (int)(Math.sin(angle1) * Math.cos(angle2) * radius);\n        \n        // Biyoma göre detay\n        Material detailMat = switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> Material.AMETHYST_CLUSTER;\n            case LAVA_OCEAN, MAGMA_CAVES -> Material.MAGMA_BLOCK;\n            case FROZEN_TUNDRA, GLACIER -> Material.ICE;\n            case DESERT, BADLANDS -> Material.CACTUS;\n            default -> Material.COBBLESTONE;\n        };\n        \n        // Küçük kaya veya kristal kümesi\n        blocks.add(new BlockPlacement(detailX, detailY + 1, detailZ, detailMat));\n        if (random.nextDouble() < 0.3) {\n            blocks.add(new BlockPlacement(detailX, detailY + 2, detailZ, detailMat));\n        }\n    }\n    \n    /**\n     * YENİ: Gezegen halkaları oluştur\n     */\n    private void generatePlanetaryRings(World world, Orb orb, Random random) {\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        \n        List<BlockPlacement> ringBlocks = new ArrayList<>();\n        \n        // Halka sayısı (1-3)\n        int ringCount = 1 + random.nextInt(3);\n        \n        for (int ringIndex = 0; ringIndex < ringCount; ringIndex++) {\n            // Halka parametreleri\n            double ringInnerRadius = radius * (1.3 + ringIndex * 0.3);\n            double ringOuterRadius = ringInnerRadius + radius * 0.2;\n            double ringThickness = 1 + random.nextInt(2);\n            \n            // Halka malzemesi\n            Material ringMat = getRingMaterial(random);\n            \n            // Halka açısı (ekvator etrafında)\n            double tiltAngle = (random.nextDouble() - 0.5) * Math.PI / 6; // ±15 derece\n            \n            // Halka oluştur\n            for (double angle = 0; angle < Math.PI * 2; angle += 0.05) {\n                for (double r = ringInnerRadius; r < ringOuterRadius; r += 0.5) {\n                    // Rastgele boşluklar (daha gerçekçi)\n                    if (random.nextDouble() < 0.3) continue;\n                    \n                    int x = cx + (int)(Math.cos(angle) * r);\n                    int z = cz + (int)(Math.sin(angle) * r);\n                    \n                    // Y pozisyonu (tilt ile)\n                    int y = cy + (int)(Math.sin(tiltAngle) * (x - cx));\n                    \n                    // Kalınlık\n                    for (int dy = 0; dy < ringThickness; dy++) {\n                        ringBlocks.add(new BlockPlacement(x, y + dy, z, ringMat));\n                    }\n                }\n            }\n        }\n        \n        // Halka bloklarını yerleştir\n        placeBlocksInBatches(world, ringBlocks, null);\n    }\n    \n    /**\n     * Halka malzemesi seç\n     */\n    private Material getRingMaterial(Random random) {\n        Material[] ringMaterials = {\n            Material.ICE,\n            Material.PACKED_ICE,\n            Material.SNOW_BLOCK,\n            Material.QUARTZ_BLOCK,\n            Material.STONE,\n            Material.COBBLESTONE,\n            Material.ANDESITE,\n            Material.DIORITE\n        };\n        return ringMaterials[random.nextInt(ringMaterials.length)];\n    }\n\n    /**\n     * Create a visual progress bar\n     */\n    private String createProgressBar(int percent) {\n        int barLength = 20; // Length of the progress bar\n        int filled = (percent * barLength) / 100;\n        StringBuilder bar = new StringBuilder(\"[\");\n\n        for (int i = 0; i < barLength; i++) {\n            if (i < filled) {\n                bar.append(\"█\"); // Filled character\n            } else {\n                bar.append(\"░\"); // Empty character\n            }\n        }\n        bar.append(\"]\");\n\n        return bar.toString();\n    }\n\n    /**\n     * Get descriptive step name for progress display\n     */\n    private String getStepName(int currentStep, int totalSteps) {\n        if (currentStep <= 1) return \"🌍 Başlatılıyor...\";\n        if (currentStep == 2) return \"📍 Konum belirleniyor...\";\n        if (currentStep == 3) return \"🎨 Gezegen tasarlanıyor...\";\n        if (currentStep == 4) return \"✨ Özellikler ekleniyor...\";\n        if (currentStep == 5) return \"💾 Veritabanına kaydediliyor...\";\n        if (currentStep == 6) return \"⚡ Işınlanılıyor...\";\n        if (currentStep == 7) return \"🏗️ Gezegen kabuğu oluşturuluyor...\";\n        if (currentStep == 8) return \"🔨 Gezegen şekilleniyor...\";\n\n        // Dynamic steps based on enabled features\n        int baseSteps = 8;\n        int stepIndex = currentStep - baseSteps;\n\n        if (plugin.getConfigManager().isOreGenerationEnabled() && stepIndex == 1) {\n            return \"⛏️ Madenler yerleştiriliyor...\";\n        }\n        if (plugin.getConfigManager().isTreeGenerationEnabled() && stepIndex == 2) {\n            return \"🌳 Ağaçlar dikiliyor...\";\n        }\n        if (plugin.getConfigManager().isStructureGenerationEnabled() && stepIndex == 3) {\n            return \"🏛️ Yapılar inşa ediliyor...\";\n        }\n        if (plugin.getConfigManager().isTreasureGenerationEnabled() && stepIndex == 4) {\n            return \"💰 Hazineler gizleniyor...\";\n        }\n        if (stepIndex == 5) return \"🏰 Zindanlar kazılıyor...\";\n        if (stepIndex == 6) return \"🌌 Yüzey detayları ekleniyor...\";\n        if (stepIndex == 7) return \"💫 Halkalar oluşturuluyor...\";\n        if (plugin.getConfigManager().isAsteroidsEnabled() && stepIndex == 8) {\n            return \"☄️ Asteroidler yerleştiriliyor...\";\n        }\n        if (plugin.getConfigManager().isSatellitesEnabled() && stepIndex == 9) {\n            return \"🛰️ Uydular konumlandırılıyor...\";\n        }\n        if (stepIndex >= 10) return \"✅ Son düzenlemeler yapılıyor...\";\n\n        return \"🔄 İşleniyor...\";\n    }\n\n    public void shutdown() {\n        executor.shutdown();\n        try {\n            if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {\n                executor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            executor.shutdownNow();\n        }\n    }\n    \n    private static class BlockPlacement {\n        int x, y, z;\n        Material material;\n        \n        BlockPlacement(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n    \n    private static class ChunkPos {\n        int x, z;\n\n        ChunkPos(int x, int z) {\n            this.x = x;\n            this.z = z;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ChunkPos chunkPos = (ChunkPos) o;\n            return x == chunkPos.x && z == chunkPos.z;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, z);\n        }\n    }\n\n    /**\n     * Add random variations for extra diversity\n     */\n    private void addRandomVariations(Orb orb, java.util.Set<com.skyorbs.modifiers.PlanetModifier> modifiers, Random random) {\n        // Random size variation (±10%)\n        double sizeMultiplier = 0.9 + random.nextDouble() * 0.2;\n        orb.setRadius((int)(orb.getRadius() * sizeMultiplier));\n\n        // Random palette variation (swap to similar palette sometimes)\n        if (random.nextDouble() < 0.1) { // 10% chance\n            String currentPalette = orb.getPaletteId();\n            if (currentPalette != null) {\n                // Swap to a random different palette\n                com.skyorbs.palettes.PlanetPalette newPalette = plugin.getPaletteRegistry().getRandomPalette(random);\n                orb.setPaletteId(newPalette.getId());\n            }\n        }\n\n        // Random biome variation\n        if (random.nextDouble() < 0.15) { // 15% chance\n            BiomeType newBiome = BiomeType.getRandomBiomeWeighted(random);\n            orb.setBiomeName(newBiome.name());\n        }\n\n        // Random modifier additions (small chance for extra modifiers)\n        if (random.nextDouble() < 0.05) { // 5% chance for extra modifier\n            com.skyorbs.modifiers.PlanetModifier[] allMods = com.skyorbs.modifiers.PlanetModifier.values();\n            com.skyorbs.modifiers.PlanetModifier extraMod = allMods[random.nextInt(allMods.length)];\n            modifiers.add(extraMod);\n        }\n\n        // Random shape variation (slight deformation)\n        if (random.nextDouble() < 0.2) { // 20% chance\n            // This would require shape modification logic\n            // For now, just ensure minimum radius\n            if (orb.getRadius() < 20) {\n                orb.setRadius(20 + random.nextInt(10));\n            }\n        }\n    }\n\n    /**\n     * Generate trees within planet volume - integrated into planet generation\n     */\n    private List<OreGenerator.BlockData> generateTreesWithinPlanet(int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random treeRandom = new Random(seed + 456);\n\n        int cx_planet = cx;\n        int cy_planet = cy;\n        int cz_planet = cz;\n        int radius_planet = radius;\n\n        // Get tree config\n        TreeGenerator.TreeConfig config = getTreeConfigForIntegration(biome);\n        if (config == null) return blocks;\n\n        double treeMultiplier = 2.0;\n        int treeCount = (int)(radius * config.density * treeMultiplier);\n\n        for (int i = 0; i < treeCount; i++) {\n            int x = cx + treeRandom.nextInt(radius * 2) - radius;\n            int z = cz + treeRandom.nextInt(radius * 2) - radius;\n\n            // Find ground level within planet\n            int y = findGroundLevelWithinPlanet(cx, cy, cz, x, z, radius, treeRandom);\n\n            if (y == -1) continue;\n\n            TreeGenerator.TreeType type = config.getRandomType(treeRandom);\n            generateTreeWithinPlanet(blocks, x, y + 1, z, type, treeRandom, cx, cy, cz, radius);\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Generate structures within planet volume - integrated into planet generation\n     */\n    private List<OreGenerator.BlockData> generateStructuresWithinPlanet(int cx, int cy, int cz, int radius, long seed, BiomeType biome, Random random) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n\n        // CONFIG KONTROLLÜ - Build sistemi aktif mi?\n        if (!plugin.getConfig().getBoolean(\"buildings.enabled\", true)) {\n            return blocks;\n        }\n\n        Random structRandom = new Random(seed + biome.name().hashCode());\n\n        int cx_planet = cx;\n        int cy_planet = cy;\n        int cz_planet = cz;\n        int radius_planet = radius;\n\n        // Get planet type from biome (simplified for integration)\n        com.skyorbs.core.PlanetType planetType = com.skyorbs.core.PlanetType.TERRESTRIAL; // Default for now\n\n        // CONFIG'DEN PLANET TYPE AYARLARINI OKU\n        String planetTypeKey = planetType.name().toLowerCase();\n        boolean planetEnabled = plugin.getConfig()\n            .getBoolean(\"buildings.planetTypes.\" + planetTypeKey + \".enabled\", true);\n\n        if (!planetEnabled) return blocks;\n\n        double baseDensity = plugin.getConfig()\n            .getDouble(\"buildings.densityMultiplier\", 0.02);\n        double planetMultiplier = plugin.getConfig()\n            .getDouble(\"buildings.planetTypes.\" + planetTypeKey + \".densityMultiplier\", 1.0);\n\n        int structureCount = (int)(radius * baseDensity * planetMultiplier);\n\n        for (int i = 0; i < structureCount; i++) {\n            // Generate positions within planet bounds\n            int x = cx + structRandom.nextInt(radius * 2) - radius;\n            int z = cz + structRandom.nextInt(radius * 2) - radius;\n            int y = cy + radius; // Surface level\n\n            // CONFIG'DEN YAPILARI SEÇ - Gezegen türüne göre\n            StructureGenerator.BuildingType type = getBuildingTypeFromConfigForIntegration(planetType, structRandom);\n\n            // Generate the structure within planet\n            generateBuildingWithinPlanet(blocks, x, y, z, type, structRandom, biome, planetType, cx, cy, cz, radius);\n        }\n\n        return blocks;\n    }\n\n    /**\n     * Find ground level within planet volume\n     */\n    private int findGroundLevelWithinPlanet(int cx, int cy, int cz, int x, int z, int radius, Random random) {\n        // Start from top of planet and raycast downward\n        int searchStartY = cy + radius + 5;\n        int searchEndY = cy - radius;\n\n        for (int y = searchStartY; y >= searchEndY; y--) {\n            // Check if within planet bounds\n            double distanceFromCenter = Math.sqrt(\n                (x - cx) * (x - cx) +\n                (y - cy) * (y - cy) +\n                (z - cz) * (z - cz)\n            );\n\n            // Must be on or near surface (within 3 blocks of radius)\n            if (distanceFromCenter >= radius - 3 && distanceFromCenter <= radius + 1) {\n                return y;\n            }\n        }\n\n        return -1; // No suitable ground found\n    }\n\n    /**\n     * Generate tree within planet volume\n     */\n    private void generateTreeWithinPlanet(List<OreGenerator.BlockData> blocks, int x, int y, int z,\n                                      TreeGenerator.TreeType type, Random random, int cx, int cy, int cz, int radius) {\n\n        int height = type.minHeight + random.nextInt(type.maxHeight - type.minHeight + 1);\n\n        // Gövde - check planet bounds\n        for (int i = 0; i < height; i++) {\n            if (isWithinPlanetBounds(cx, cy, cz, x, y + i, z, radius)) {\n                blocks.add(new OreGenerator.BlockData(x, y + i, z, type.logMaterial));\n            }\n        }\n\n        // Yapraklar - check planet bounds\n        int leafStart = y + height - type.leafLayers;\n        for (int ly = 0; ly < type.leafLayers; ly++) {\n            int currentY = leafStart + ly;\n            int leafRadius = type.leafRadius - (ly / 2);\n\n            for (int dx = -leafRadius; dx <= leafRadius; dx++) {\n                for (int dz = -leafRadius; dz <= leafRadius; dz++) {\n                    if (dx == 0 && dz == 0 && ly < type.leafLayers - 1) continue; // Gövdeyi atla\n\n                    double distance = Math.sqrt(dx * dx + dz * dz);\n                    if (distance <= leafRadius + random.nextDouble() * 0.5) {\n                        if (isWithinPlanetBounds(cx, cy, cz, x + dx, currentY, z + dz, radius)) {\n                            blocks.add(new OreGenerator.BlockData(x + dx, currentY, z + dz, type.leafMaterial));\n                        }\n                    }\n                }\n            }\n        }\n\n        // Özel özellikler (simplified for integration)\n        if (type == TreeGenerator.TreeType.OAK && random.nextDouble() < 0.15) {\n            // Arı kovanı ekle\n            int side = random.nextInt(4);\n            int beeY = y + height - 2;\n            if (isWithinPlanetBounds(cx, cy, cz, x + 1, beeY, z, radius)) {\n                blocks.add(new OreGenerator.BlockData(x + 1, beeY, z, Material.BEE_NEST));\n            }\n        }\n    }\n\n    /**\n     * Generate building within planet volume\n     */\n    private void generateBuildingWithinPlanet(List<OreGenerator.BlockData> blocks, int x, int y, int z,\n                                          StructureGenerator.BuildingType type, Random random, BiomeType biome,\n                                          com.skyorbs.core.PlanetType planetType, int cx, int cy, int cz, int radius) {\n\n        // Simplified building generation - only basic house for integration\n        if (type == StructureGenerator.BuildingType.VILLAGE) {\n            // Temel (7x7) - check planet bounds\n            for (int dx = -3; dx <= 3; dx++) {\n                for (int dz = -3; dz <= 3; dz++) {\n                    if (isWithinPlanetBounds(cx, cy, cz, x + dx, y, z + dz, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y, z + dz, Material.OAK_PLANKS));\n                    }\n                }\n            }\n\n            // Duvarlar\n            for (int dy = 1; dy <= 3; dy++) {\n                for (int dx = -3; dx <= 3; dx++) {\n                    if (isWithinPlanetBounds(cx, cy, cz, x + dx, y + dy, z - 3, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z - 3, Material.OAK_LOG));\n                    }\n                    if (isWithinPlanetBounds(cx, cy, cz, x + dx, y + dy, z + 3, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + dy, z + 3, Material.OAK_LOG));\n                    }\n                }\n                for (int dz = -2; dz <= 2; dz++) {\n                    if (isWithinPlanetBounds(cx, cy, cz, x - 3, y + dy, z + dz, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x - 3, y + dy, z + dz, Material.OAK_LOG));\n                    }\n                    if (isWithinPlanetBounds(cx, cy, cz, x + 3, y + dy, z + dz, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x + 3, y + dy, z + dz, Material.OAK_LOG));\n                    }\n                }\n            }\n\n            // Çatı\n            for (int dx = -3; dx <= 3; dx++) {\n                for (int dz = -3; dz <= 3; dz++) {\n                    if (isWithinPlanetBounds(cx, cy, cz, x + dx, y + 4, z + dz, radius)) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, y + 4, z + dz, Material.OAK_STAIRS));\n                    }\n                }\n            }\n\n            // Kapı\n            if (isWithinPlanetBounds(cx, cy, cz, x, y + 1, z - 3, radius)) {\n                blocks.add(new OreGenerator.BlockData(x, y + 1, z - 3, Material.OAK_DOOR));\n            }\n            if (isWithinPlanetBounds(cx, cy, cz, x, y + 2, z - 3, radius)) {\n                blocks.add(new OreGenerator.BlockData(x, y + 2, z - 3, Material.OAK_DOOR));\n            }\n        }\n    }\n\n    /**\n     * Check if position is within planet bounds\n     */\n    private boolean isWithinPlanetBounds(int cx, int cy, int cz, int x, int y, int z, int radius) {\n        double distance = Math.sqrt(\n            (x - cx) * (x - cx) +\n            (y - cy) * (y - cy) +\n            (z - cz) * (z - cz)\n        );\n        return distance <= radius;\n    }\n\n    /**\n     * Get integrated feature material at position\n     */\n    private Material getIntegratedFeatureMaterial(int x, int y, int z,\n                                                List<OreGenerator.BlockData> trees,\n                                                List<OreGenerator.BlockData> structures) {\n        // Check trees first\n        for (OreGenerator.BlockData tree : trees) {\n            if (tree.x == x && tree.y == y && tree.z == z) {\n                return tree.material;\n            }\n        }\n\n        // Check structures\n        for (OreGenerator.BlockData structure : structures) {\n            if (structure.x == x && structure.y == y && structure.z == z) {\n                return structure.material;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Get tree config for integration (copied from TreeGenerator)\n     */\n    private TreeGenerator.TreeConfig getTreeConfigForIntegration(BiomeType biome) {\n        return switch (biome) {\n            case FOREST -> new TreeGenerator.TreeConfig(0.25,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.OAK, TreeGenerator.TreeType.BIRCH, TreeGenerator.TreeType.DARK_OAK},\n                new double[]{0.5, 0.3, 0.2});\n\n            case JUNGLE -> new TreeGenerator.TreeConfig(0.35,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.JUNGLE, TreeGenerator.TreeType.JUNGLE_LARGE},\n                new double[]{0.7, 0.3});\n\n            case TAIGA -> new TreeGenerator.TreeConfig(0.20,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.SPRUCE, TreeGenerator.TreeType.PINE},\n                new double[]{0.7, 0.3});\n\n            case SAVANNA -> new TreeGenerator.TreeConfig(0.08,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.ACACIA},\n                new double[]{1.0});\n\n            case MEADOW -> new TreeGenerator.TreeConfig(0.15,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.OAK, TreeGenerator.TreeType.BIRCH, TreeGenerator.TreeType.CHERRY},\n                new double[]{0.4, 0.4, 0.2});\n\n            case PLAINS -> new TreeGenerator.TreeConfig(0.05,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.OAK},\n                new double[]{1.0});\n\n            case MUSHROOM_GIANT -> new TreeGenerator.TreeConfig(0.12,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.GIANT_MUSHROOM_RED, TreeGenerator.TreeType.GIANT_MUSHROOM_BROWN},\n                new double[]{0.5, 0.5});\n\n            case TOXIC_SWAMP -> new TreeGenerator.TreeConfig(0.18,\n                new TreeGenerator.TreeType[]{TreeGenerator.TreeType.MANGROVE, TreeGenerator.TreeType.DARK_OAK},\n                new double[]{0.6, 0.4});\n\n            default -> null;\n        };\n    }\n\n    /**\n     * Get building type from config for integration (simplified)\n     */\n    private StructureGenerator.BuildingType getBuildingTypeFromConfigForIntegration(com.skyorbs.core.PlanetType planetType, Random random) {\n        // Simplified - just return village for now\n        return StructureGenerator.BuildingType.VILLAGE;\n    }\n\n    /**\n     * Result class for planet generation containing blocks and first block\n     */\n    private static class PlanetGenerationResult {\n        List<BlockPlacement> blocks;\n        BlockPlacement firstBlock;\n\n        PlanetGenerationResult(List<BlockPlacement> blocks, BlockPlacement firstBlock) {\n            this.blocks = blocks;\n            this.firstBlock = firstBlock;\n        }\n    }\n}","size_bytes":81149},"src/main/java/com/skyorbs/palettes/PaletteRegistry.java":{"content":"package com.skyorbs.palettes;\n\nimport org.bukkit.Material;\nimport java.util.*;\n\n/**\n * Registry for planet palettes - enables 2000+ diverse planet combinations\n * Combines with shapes, modifiers, and atmospheres for massive variety\n */\npublic class PaletteRegistry {\n    \n    private final Map<String, PlanetPalette> palettes = new HashMap<String, PlanetPalette>();\n    private final List<PlanetPalette> weightedList = new ArrayList<PlanetPalette>();\n    private double totalWeight = 0.0;\n    \n    public PaletteRegistry() {\n        registerDefaultPalettes();\n        buildWeightedList();\n    }\n    \n    /**\n     * Register 20+ diverse palettes for maximum variety\n     */\n    private void registerDefaultPalettes() {\n        // Basaltic (volcanic, dark)\n        register(new PlanetPalette(\"basaltic\", \"Bazaltik\",\n            new Material[]{Material.BASALT, Material.BLACKSTONE, Material.SMOOTH_BASALT},\n            new Material[]{Material.BLACKSTONE, Material.DEEPSLATE, Material.BASALT},\n            new Material[]{Material.BASALT, Material.BLACKSTONE, Material.SMOOTH_BASALT},\n            new Material[]{Material.MAGMA_BLOCK, Material.LAVA},\n            10.0));\n        \n        // Crystalline (shiny, precious)\n        register(new PlanetPalette(\"crystalline\", \"Kristal\",\n            new Material[]{Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.PURPUR_BLOCK},\n            new Material[]{Material.QUARTZ_BLOCK, Material.CALCITE, Material.DRIPSTONE_BLOCK},\n            new Material[]{Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.PURPUR_BLOCK},\n            new Material[]{Material.GLOWSTONE, Material.SEA_LANTERN},\n            8.0));\n        \n        // Fungal (mushroom, organic)\n        register(new PlanetPalette(\"fungal\", \"Mantarlı\",\n            new Material[]{Material.MYCELIUM, Material.BROWN_MUSHROOM_BLOCK, Material.RED_MUSHROOM_BLOCK},\n            new Material[]{Material.DIRT, Material.PODZOL, Material.MYCELIUM},\n            new Material[]{Material.MYCELIUM, Material.BROWN_MUSHROOM_BLOCK, Material.RED_MUSHROOM_BLOCK},\n            new Material[]{Material.MUSHROOM_STEM, Material.SHROOMLIGHT},\n            9.0));\n        \n        // Coral (aquatic, vibrant)\n        register(new PlanetPalette(\"coral\", \"Mercan\",\n            new Material[]{Material.BRAIN_CORAL_BLOCK, Material.TUBE_CORAL_BLOCK, Material.BUBBLE_CORAL_BLOCK},\n            new Material[]{Material.HORN_CORAL_BLOCK, Material.FIRE_CORAL_BLOCK, Material.PRISMARINE},\n            new Material[]{Material.BRAIN_CORAL_BLOCK, Material.TUBE_CORAL_BLOCK, Material.BUBBLE_CORAL_BLOCK},\n            new Material[]{Material.SEA_LANTERN, Material.PRISMARINE_BRICKS},\n            7.0));\n        \n        // Toxic (poisonous, dangerous)\n        register(new PlanetPalette(\"toxic\", \"Zehirli\",\n            new Material[]{Material.GREEN_CONCRETE, Material.LIME_CONCRETE, Material.SLIME_BLOCK},\n            new Material[]{Material.GREEN_TERRACOTTA, Material.LIME_TERRACOTTA, Material.MOSS_BLOCK},\n            new Material[]{Material.GREEN_CONCRETE, Material.LIME_CONCRETE, Material.SLIME_BLOCK},\n            new Material[]{Material.SLIME_BLOCK, Material.HONEY_BLOCK},\n            6.0));\n        \n        // Frozen (ice, snow)\n        register(new PlanetPalette(\"frozen\", \"Donmuş\",\n            new Material[]{Material.SNOW_BLOCK, Material.PACKED_ICE, Material.ICE},\n            new Material[]{Material.PACKED_ICE, Material.BLUE_ICE, Material.ICE},\n            new Material[]{Material.SNOW_BLOCK, Material.PACKED_ICE, Material.ICE},\n            new Material[]{Material.FROSTED_ICE, Material.POWDER_SNOW},\n            8.0));\n        \n        // Volcanic (lava, heat)\n        register(new PlanetPalette(\"volcanic\", \"Volkanik\",\n            new Material[]{Material.MAGMA_BLOCK, Material.NETHERRACK, Material.BLACKSTONE},\n            new Material[]{Material.NETHERRACK, Material.BASALT, Material.BLACKSTONE},\n            new Material[]{Material.MAGMA_BLOCK, Material.NETHERRACK, Material.BLACKSTONE},\n            new Material[]{Material.FIRE, Material.LAVA},\n            7.0));\n        \n        // Verdant (lush, green)\n        register(new PlanetPalette(\"verdant\", \"Yeşil\",\n            new Material[]{Material.GRASS_BLOCK, Material.MOSS_BLOCK, Material.FLOWERING_AZALEA_LEAVES},\n            new Material[]{Material.DIRT, Material.ROOTED_DIRT, Material.MOSS_BLOCK},\n            new Material[]{Material.GRASS_BLOCK, Material.MOSS_BLOCK, Material.FLOWERING_AZALEA_LEAVES},\n            new Material[]{Material.AZALEA, Material.FLOWERING_AZALEA},\n            10.0));\n        \n        // Desert (sandy, dry)\n        register(new PlanetPalette(\"desert\", \"Çöl\",\n            new Material[]{Material.SAND, Material.RED_SAND, Material.SANDSTONE},\n            new Material[]{Material.SANDSTONE, Material.RED_SANDSTONE, Material.SAND},\n            new Material[]{Material.SAND, Material.RED_SAND, Material.SANDSTONE},\n            new Material[]{Material.DEAD_BUSH, Material.CACTUS},\n            9.0));\n        \n        // Metallic (iron, copper)\n        register(new PlanetPalette(\"metallic\", \"Metalik\",\n            new Material[]{Material.IRON_BLOCK, Material.COPPER_BLOCK, Material.WEATHERED_COPPER},\n            new Material[]{Material.IRON_BLOCK, Material.EXPOSED_COPPER, Material.OXIDIZED_COPPER},\n            new Material[]{Material.IRON_BLOCK, Material.COPPER_BLOCK, Material.WEATHERED_COPPER},\n            new Material[]{Material.IRON_BARS, Material.CHAIN},\n            5.0));\n        \n        // Void (dark, mysterious)\n        register(new PlanetPalette(\"void\", \"Boşluk\",\n            new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.CRYING_OBSIDIAN},\n            new Material[]{Material.OBSIDIAN, Material.END_STONE, Material.BLACKSTONE},\n            new Material[]{Material.OBSIDIAN, Material.END_STONE, Material.BLACKSTONE},\n            new Material[]{Material.ENDER_CHEST, Material.END_ROD},\n            4.0));\n        \n        // Luminous (glowing, bright)\n        register(new PlanetPalette(\"luminous\", \"Parlak\",\n            new Material[]{Material.GLOWSTONE, Material.SEA_LANTERN, Material.SHROOMLIGHT},\n            new Material[]{Material.GLOWSTONE, Material.OCHRE_FROGLIGHT, Material.VERDANT_FROGLIGHT},\n            new Material[]{Material.GLOWSTONE, Material.SEA_LANTERN, Material.SHROOMLIGHT},\n            new Material[]{Material.TORCH, Material.LANTERN},\n            5.0));\n        \n        // Warped (nether, alien)\n        register(new PlanetPalette(\"warped\", \"Çarpık\",\n            new Material[]{Material.WARPED_NYLIUM, Material.WARPED_WART_BLOCK, Material.WARPED_STEM},\n            new Material[]{Material.WARPED_NYLIUM, Material.NETHERRACK, Material.SOUL_SOIL},\n            new Material[]{Material.WARPED_NYLIUM, Material.WARPED_WART_BLOCK, Material.WARPED_STEM},\n            new Material[]{Material.WARPED_ROOTS, Material.WARPED_FUNGUS},\n            6.0));\n        \n        // Crimson (nether, red)\n        register(new PlanetPalette(\"crimson\", \"Kızıl\",\n            new Material[]{Material.CRIMSON_NYLIUM, Material.CRIMSON_STEM, Material.NETHER_WART_BLOCK},\n            new Material[]{Material.CRIMSON_NYLIUM, Material.NETHERRACK, Material.SOUL_SAND},\n            new Material[]{Material.CRIMSON_NYLIUM, Material.CRIMSON_STEM, Material.NETHER_WART_BLOCK},\n            new Material[]{Material.CRIMSON_ROOTS, Material.CRIMSON_FUNGUS},\n            6.0));\n        \n        // Sandstone (ancient, carved)\n        register(new PlanetPalette(\"sandstone\", \"Kumtaşı\",\n            new Material[]{Material.SANDSTONE, Material.SMOOTH_SANDSTONE, Material.CHISELED_SANDSTONE},\n            new Material[]{Material.SANDSTONE, Material.CUT_SANDSTONE, Material.SAND},\n            new Material[]{Material.SANDSTONE, Material.SMOOTH_SANDSTONE, Material.CHISELED_SANDSTONE},\n            new Material[]{Material.SANDSTONE_STAIRS, Material.SANDSTONE_SLAB},\n            7.0));\n        \n        // Terracotta (colorful, layered)\n        register(new PlanetPalette(\"terracotta\", \"Kil\",\n            new Material[]{Material.ORANGE_TERRACOTTA, Material.RED_TERRACOTTA, Material.YELLOW_TERRACOTTA},\n            new Material[]{Material.BROWN_TERRACOTTA, Material.WHITE_TERRACOTTA, Material.LIGHT_GRAY_TERRACOTTA},\n            new Material[]{Material.ORANGE_TERRACOTTA, Material.RED_TERRACOTTA, Material.YELLOW_TERRACOTTA},\n            new Material[]{Material.FLOWER_POT, Material.BRICK},\n            8.0));\n        \n        // Concrete (modern, smooth)\n        register(new PlanetPalette(\"concrete\", \"Beton\",\n            new Material[]{Material.LIGHT_GRAY_CONCRETE, Material.GRAY_CONCRETE, Material.WHITE_CONCRETE},\n            new Material[]{Material.GRAY_CONCRETE, Material.STONE, Material.ANDESITE},\n            new Material[]{Material.LIGHT_GRAY_CONCRETE, Material.GRAY_CONCRETE, Material.WHITE_CONCRETE},\n            new Material[]{Material.GRAVEL, Material.COBBLESTONE},\n            6.0));\n        \n        // Prismarine (ocean, ancient)\n        register(new PlanetPalette(\"prismarine\", \"Prizmarin\",\n            new Material[]{Material.PRISMARINE, Material.PRISMARINE_BRICKS, Material.DARK_PRISMARINE},\n            new Material[]{Material.PRISMARINE, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.OBSIDIAN, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.SEA_LANTERN, Material.PRISMARINE_SLAB},\n            5.0));\n        \n        // Sculk (deep dark, mysterious)\n        register(new PlanetPalette(\"sculk\", \"Sculk\",\n            new Material[]{Material.SCULK, Material.SCULK_VEIN, Material.SCULK_CATALYST},\n            new Material[]{Material.SCULK, Material.DEEPSLATE, Material.SCULK_CATALYST},\n            new Material[]{Material.SCULK, Material.SCULK_VEIN, Material.SCULK_CATALYST},\n            new Material[]{Material.SCULK_SENSOR, Material.SCULK_CATALYST},\n            3.0));\n        \n        // Mud (swamp, wet)\n        register(new PlanetPalette(\"mud\", \"Çamur\",\n            new Material[]{Material.MUD, Material.MUDDY_MANGROVE_ROOTS, Material.MUD_BRICKS},\n            new Material[]{Material.MUD, Material.CLAY, Material.PACKED_MUD},\n            new Material[]{Material.MUD, Material.MUDDY_MANGROVE_ROOTS, Material.MUD_BRICKS},\n            new Material[]{Material.MANGROVE_ROOTS, Material.MOSS_CARPET},\n            7.0));\n\n        // Rainbow (colorful, vibrant)\n        register(new PlanetPalette(\"rainbow\", \"Gökkuşağı\",\n            new Material[]{Material.RED_CONCRETE, Material.ORANGE_CONCRETE, Material.YELLOW_CONCRETE},\n            new Material[]{Material.GREEN_CONCRETE, Material.BLUE_CONCRETE, Material.PURPLE_CONCRETE},\n            new Material[]{Material.RED_CONCRETE, Material.ORANGE_CONCRETE, Material.YELLOW_CONCRETE},\n            new Material[]{Material.WHITE_WOOL, Material.GLASS},\n            4.0));\n\n        // Netherrack (hellish, fiery)\n        register(new PlanetPalette(\"netherrack\", \"Cehennem\",\n            new Material[]{Material.NETHERRACK, Material.NETHER_BRICKS, Material.RED_NETHER_BRICKS},\n            new Material[]{Material.NETHERRACK, Material.NETHER_BRICKS, Material.SOUL_SAND},\n            new Material[]{Material.NETHERRACK, Material.NETHER_BRICKS, Material.RED_NETHER_BRICKS},\n            new Material[]{Material.FIRE, Material.SOUL_FIRE},\n            6.0));\n\n        // Endstone (end dimension, mysterious)\n        register(new PlanetPalette(\"endstone\", \"End\",\n            new Material[]{Material.END_STONE, Material.END_STONE_BRICKS, Material.PURPUR_BLOCK},\n            new Material[]{Material.END_STONE, Material.PURPUR_BLOCK, Material.END_STONE_BRICKS},\n            new Material[]{Material.END_STONE, Material.END_STONE_BRICKS, Material.PURPUR_BLOCK},\n            new Material[]{Material.END_ROD, Material.ENDER_CHEST},\n            5.0));\n\n        // Honey (sweet, sticky)\n        register(new PlanetPalette(\"honey\", \"Bal\",\n            new Material[]{Material.HONEY_BLOCK, Material.HONEYCOMB_BLOCK, Material.YELLOW_CONCRETE},\n            new Material[]{Material.HONEY_BLOCK, Material.YELLOW_TERRACOTTA, Material.ORANGE_TERRACOTTA},\n            new Material[]{Material.YELLOW_TERRACOTTA, Material.ORANGE_CONCRETE, Material.STONE},\n            new Material[]{Material.BEEHIVE, Material.BEE_NEST},\n            4.0));\n\n        // Bone (skeletal, creepy)\n        register(new PlanetPalette(\"bone\", \"Kemik\",\n            new Material[]{Material.BONE_BLOCK, Material.WHITE_CONCRETE, Material.LIGHT_GRAY_CONCRETE},\n            new Material[]{Material.BONE_BLOCK, Material.GRAY_CONCRETE, Material.WHITE_TERRACOTTA},\n            new Material[]{Material.GRAY_TERRACOTTA, Material.STONE, Material.DEEPSLATE},\n            new Material[]{Material.SKELETON_SKULL, Material.WITHER_SKELETON_SKULL},\n            3.0));\n\n        // Sponge (ocean, absorbent)\n        register(new PlanetPalette(\"sponge\", \"Sünger\",\n            new Material[]{Material.SPONGE, Material.WET_SPONGE, Material.YELLOW_CONCRETE},\n            new Material[]{Material.SPONGE, Material.PRISMARINE, Material.SEA_LANTERN},\n            new Material[]{Material.PRISMARINE, Material.DARK_PRISMARINE, Material.STONE},\n            new Material[]{Material.KELP, Material.SEAGRASS},\n            4.0));\n\n        // Tuff (volcanic, rocky)\n        register(new PlanetPalette(\"tuff\", \"Tuf\",\n            new Material[]{Material.TUFF, Material.CALCITE, Material.DRIPSTONE_BLOCK},\n            new Material[]{Material.TUFF, Material.ANDESITE, Material.STONE},\n            new Material[]{Material.DEEPSLATE, Material.TUFF, Material.STONE},\n            new Material[]{Material.POINTED_DRIPSTONE, Material.AMETHYST_CLUSTER},\n            6.0));\n\n        // Cherry (sakura-like, pink)\n        register(new PlanetPalette(\"cherry\", \"Kiraz\",\n            new Material[]{Material.PINK_CONCRETE, Material.PINK_TERRACOTTA, Material.WHITE_CONCRETE},\n            new Material[]{Material.PINK_TERRACOTTA, Material.MAGENTA_TERRACOTTA, Material.WHITE_TERRACOTTA},\n            new Material[]{Material.WHITE_TERRACOTTA, Material.STONE, Material.CLAY},\n            new Material[]{Material.CHERRY_LEAVES, Material.PINK_PETALS},\n            5.0));\n\n        // Bamboo (tropical, fast-growing)\n        register(new PlanetPalette(\"bamboo\", \"Bambu\",\n            new Material[]{Material.BAMBOO_BLOCK, Material.GREEN_CONCRETE, Material.JUNGLE_WOOD},\n            new Material[]{Material.BAMBOO_BLOCK, Material.GREEN_TERRACOTTA, Material.DIRT},\n            new Material[]{Material.GREEN_TERRACOTTA, Material.STONE, Material.CLAY},\n            new Material[]{Material.BAMBOO, Material.JUNGLE_LEAVES},\n            6.0));\n\n        // Calcite (cave, crystalline)\n        register(new PlanetPalette(\"calcite\", \"Kalsit\",\n            new Material[]{Material.CALCITE, Material.QUARTZ_BLOCK, Material.DRIPSTONE_BLOCK},\n            new Material[]{Material.CALCITE, Material.STONE, Material.DEEPSLATE},\n            new Material[]{Material.CALCITE, Material.QUARTZ_BLOCK, Material.DRIPSTONE_BLOCK},\n            new Material[]{Material.AMETHYST_CLUSTER, Material.POINTED_DRIPSTONE},\n            5.0));\n\n        // Dripstone (cave, wet)\n        register(new PlanetPalette(\"dripstone\", \"Damla Taşı\",\n            new Material[]{Material.DRIPSTONE_BLOCK, Material.STONE, Material.CALCITE},\n            new Material[]{Material.DRIPSTONE_BLOCK, Material.DEEPSLATE, Material.STONE},\n            new Material[]{Material.DEEPSLATE, Material.DRIPSTONE_BLOCK, Material.WATER},\n            new Material[]{Material.POINTED_DRIPSTONE, Material.WATER},\n            4.0));\n\n        // Oxidized (aged copper)\n        register(new PlanetPalette(\"oxidized\", \"Oksitlenmiş\",\n            new Material[]{Material.OXIDIZED_COPPER, Material.WEATHERED_COPPER, Material.EXPOSED_COPPER},\n            new Material[]{Material.OXIDIZED_COPPER, Material.COPPER_BLOCK, Material.IRON_BLOCK},\n            new Material[]{Material.OXIDIZED_COPPER, Material.WEATHERED_COPPER, Material.EXPOSED_COPPER},\n            new Material[]{Material.LIGHTNING_ROD, Material.CHAIN},\n            4.0));\n\n        // Cobbled (rough, natural)\n        register(new PlanetPalette(\"cobbled\", \"Kırık Taş\",\n            new Material[]{Material.COBBLESTONE, Material.MOSSY_COBBLESTONE, Material.STONE},\n            new Material[]{Material.COBBLESTONE, Material.STONE, Material.ANDESITE},\n            new Material[]{Material.COBBLESTONE, Material.MOSSY_COBBLESTONE, Material.STONE},\n            new Material[]{Material.MOSS_CARPET, Material.VINE},\n            8.0));\n\n        // Polished (smooth, refined)\n        register(new PlanetPalette(\"polished\", \"Parlatılmış\",\n            new Material[]{Material.POLISHED_ANDESITE, Material.POLISHED_DIORITE, Material.POLISHED_GRANITE},\n            new Material[]{Material.POLISHED_ANDESITE, Material.STONE, Material.ANDESITE},\n            new Material[]{Material.POLISHED_ANDESITE, Material.POLISHED_DIORITE, Material.POLISHED_GRANITE},\n            new Material[]{Material.STONE_SLAB, Material.STONE_STAIRS},\n            7.0));\n\n        // Bricks (constructed, urban)\n        register(new PlanetPalette(\"bricks\", \"Tuğla\",\n            new Material[]{Material.BRICKS, Material.STONE_BRICKS, Material.MOSSY_STONE_BRICKS},\n            new Material[]{Material.BRICKS, Material.STONE_BRICKS, Material.COBBLESTONE},\n            new Material[]{Material.BRICKS, Material.STONE_BRICKS, Material.MOSSY_STONE_BRICKS},\n            new Material[]{Material.BRICK_STAIRS, Material.BRICK_SLAB},\n            6.0));\n\n        // Wool (soft, colorful)\n        register(new PlanetPalette(\"wool\", \"Yün\",\n            new Material[]{Material.WHITE_WOOL, Material.LIGHT_GRAY_WOOL, Material.GRAY_WOOL},\n            new Material[]{Material.WHITE_WOOL, Material.STONE, Material.DIRT},\n            new Material[]{Material.WHITE_WOOL, Material.LIGHT_GRAY_WOOL, Material.GRAY_WOOL},\n            new Material[]{Material.WHITE_CARPET, Material.WHITE_BED},\n            3.0));\n\n        // Glass (transparent, fragile)\n        register(new PlanetPalette(\"glass\", \"Cam\",\n            new Material[]{Material.GLASS, Material.WHITE_STAINED_GLASS, Material.LIGHT_GRAY_STAINED_GLASS},\n            new Material[]{Material.GLASS, Material.STONE, Material.SAND},\n            new Material[]{Material.GLASS, Material.WHITE_STAINED_GLASS, Material.LIGHT_GRAY_STAINED_GLASS},\n            new Material[]{Material.GLASS_PANE, Material.IRON_BARS},\n            2.0));\n\n        // Packed Mud (adobe-like)\n        register(new PlanetPalette(\"packed_mud\", \"Sıkıştırılmış Çamur\",\n            new Material[]{Material.PACKED_MUD, Material.MUD_BRICKS, Material.MUD},\n            new Material[]{Material.PACKED_MUD, Material.CLAY, Material.DIRT},\n            new Material[]{Material.PACKED_MUD, Material.MUD_BRICKS, Material.MUD},\n            new Material[]{Material.MUD_BRICK_SLAB, Material.MUD_BRICK_STAIRS},\n            5.0));\n\n        // Reinforced Deepslate (ultra-hard)\n        register(new PlanetPalette(\"reinforced\", \"Takviyeli\",\n            new Material[]{Material.REINFORCED_DEEPSLATE, Material.DEEPSLATE, Material.DEEPSLATE_BRICKS},\n            new Material[]{Material.REINFORCED_DEEPSLATE, Material.DEEPSLATE, Material.STONE},\n            new Material[]{Material.REINFORCED_DEEPSLATE, Material.DEEPSLATE, Material.DEEPSLATE_BRICKS},\n            new Material[]{Material.DEEPSLATE_BRICKS, Material.DEEPSLATE_BRICK_SLAB},\n            2.0));\n    }\n    \n    private void register(PlanetPalette palette) {\n        palettes.put(palette.getId(), palette);\n    }\n    \n    private void buildWeightedList() {\n        weightedList.clear();\n        totalWeight = 0.0;\n        \n        for (PlanetPalette palette : palettes.values()) {\n            totalWeight += palette.getWeight();\n            weightedList.add(palette);\n        }\n    }\n    \n    /**\n     * Get random palette based on weights\n     */\n    public PlanetPalette getRandomPalette(Random random) {\n        double value = random.nextDouble() * totalWeight;\n        double current = 0.0;\n        \n        for (PlanetPalette palette : weightedList) {\n            current += palette.getWeight();\n            if (value <= current) {\n                return palette;\n            }\n        }\n        \n        return weightedList.get(0);\n    }\n    \n    /**\n     * Get palette by ID\n     */\n    public PlanetPalette getPalette(String id) {\n        return palettes.get(id);\n    }\n    \n    /**\n     * Get all palette IDs\n     */\n    public Set<String> getPaletteIds() {\n        return palettes.keySet();\n    }\n    \n    /**\n     * Get total number of palettes\n     */\n    public int getPaletteCount() {\n        return palettes.size();\n    }\n}\n","size_bytes":20522},"src/main/java/com/skyorbs/shapes/impl/GuitarShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class GuitarShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Gitar şekli - body, neck, headstock\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Guitar body - oval shape\n        if (y < 0.2) {\n            double bodyRadius = Math.sqrt(x*x + (y+0.3)*(y+0.3));\n            if (bodyRadius <= 0.5) return true;\n        }\n\n        // Guitar neck - long thin rectangle\n        if (y >= 0.2 && y <= 0.8 && Math.abs(x) <= 0.1) {\n            return Math.abs(z) <= 0.05;\n        }\n\n        // Headstock - wider at top\n        if (y > 0.8) {\n            return Math.abs(x) <= 0.2 && Math.abs(z) <= 0.05;\n        }\n\n        // Strings (thin lines)\n        if (Math.abs(z) <= 0.02 && y >= 0.2) {\n            return Math.abs(x) <= 0.08;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"GUITAR\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Gitar\";\n    }\n}","size_bytes":1404},"src/test/java/com/skyorbs/ConfigManagerTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.config.ConfigManager;\nimport org.bukkit.configuration.file.YamlConfiguration;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.MockedStatic;\n\nimport java.io.File;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\npublic class ConfigManagerTest {\n\n    private ConfigManager configManager;\n    private SkyOrbs mockPlugin;\n\n    @BeforeEach\n    public void setUp() {\n        mockPlugin = mock(SkyOrbs.class);\n        when(mockPlugin.getConfig()).thenReturn(new YamlConfiguration());\n        configManager = new ConfigManager(mockPlugin);\n    }\n\n    @Test\n    public void testConfigManagerInitialization() {\n        assertNotNull(configManager);\n    }\n\n    @Test\n    public void testDefaultRadiusValues() {\n        // Test default values when config returns defaults\n        assertEquals(80, configManager.getMinRadius());\n        assertEquals(250, configManager.getMaxRadius());\n        assertEquals(150, configManager.getAverageRadius());\n    }\n\n    @Test\n    public void testPlacementSettings() {\n        assertEquals(50000, configManager.getMaxDistance());\n        assertEquals(0, configManager.getCenterX());\n        assertEquals(0, configManager.getCenterZ());\n        assertTrue(configManager.isClusteringEnabled());\n    }\n\n    @Test\n    public void testShapeWeights() {\n        var weights = configManager.getShapeWeights();\n        assertNotNull(weights);\n        // Test sadece map'in null olmadığını kontrol eder - mock config'de weights olmayabilir\n        // Bu test ConfigManager'ın düzgün çalıştığını doğrular\n    }\n\n    @Test\n    public void testAsteroidSettings() {\n        assertTrue(configManager.isAsteroidsEnabled());\n        assertEquals(1, configManager.getMinAsteroidsPerPlanet());\n        assertEquals(5, configManager.getMaxAsteroidsPerPlanet());\n    }\n\n    @Test\n    public void testRandomNameGeneration() {\n        String name = configManager.generateRandomName();\n        assertNotNull(name);\n        assertTrue(name.length() > 0);\n    }\n\n    @Test\n    public void testPerformanceSettings() {\n        assertTrue(configManager.isAsyncGenerationEnabled());\n        assertEquals(250, configManager.getBlocksPerBatch());\n        assertEquals(1, configManager.getBatchesPerTick());\n    }\n}","size_bytes":2349},"src/main/java/com/skyorbs/generation/PlacementService.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\n\npublic class PlacementService {\n    \n    private final SkyOrbs plugin;\n    private final Set<String> reservedLocations = new HashSet<String>();\n    private final Random random = new Random();\n    \n    public PlacementService(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    public PlacementResult findPlacement(int radius, List<Orb> existingOrbs) {\n        int maxDistance = plugin.getConfigManager().getMaxDistance();\n        int centerX = plugin.getConfigManager().getCenterX();\n        int centerZ = plugin.getConfigManager().getCenterZ();\n        int minFromSpawn = plugin.getConfigManager().getMinDistanceFromSpawn();\n        \n        if (plugin.getConfigManager().isClusteringEnabled() && !existingOrbs.isEmpty()) {\n            PlacementResult cluster = tryClusterPlacement(radius, existingOrbs, maxDistance, centerX, centerZ, minFromSpawn);\n            if (cluster != null) {\n                return cluster;\n            }\n        }\n        \n        return trySpiralPlacement(radius, existingOrbs, maxDistance, centerX, centerZ, minFromSpawn);\n    }\n    \n    private PlacementResult tryClusterPlacement(int radius, List<Orb> existingOrbs, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int minDist = plugin.getConfigManager().getClusterMinDistance();\n        int maxDist = plugin.getConfigManager().getClusterMaxDistance();\n        double centerAttraction = plugin.getConfigManager().getCenterAttraction();\n        \n        for (int attempt = 0; attempt < 50; attempt++) {\n            Orb parent = existingOrbs.get(random.nextInt(existingOrbs.size()));\n            \n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = minDist + random.nextInt(maxDist - minDist);\n            \n            int candidateX = parent.getCenterX() + (int)(Math.cos(angle) * distance);\n            int candidateZ = parent.getCenterZ() + (int)(Math.sin(angle) * distance);\n            \n            if (centerAttraction > 0) {\n                candidateX = (int)(candidateX * (1 - centerAttraction) + centerX * centerAttraction);\n                candidateZ = (int)(candidateZ * (1 - centerAttraction) + centerZ * centerAttraction);\n            }\n            \n            if (!validateDistance(candidateX, candidateZ, maxDistance, centerX, centerZ, minFromSpawn)) {\n                continue;\n            }\n            \n            if (!checkOverlap(candidateX, candidateZ, radius, existingOrbs)) {\n                int y = 100 + random.nextInt(21) - 10; // 90-110 arası, daha güvenli\n                return new PlacementResult(candidateX, y, candidateZ, true);\n            }\n        }\n        \n        return null;\n    }\n    \n    private PlacementResult trySpiralPlacement(int radius, List<Orb> existingOrbs, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int ringStep = 150; // Daha sık halkalar - 200'den 150'ye\n        int angleStep = 10; // Daha sık açılar - 15'den 10'a\n\n        // DAHA FAZLA DENEME - 300 halka (config'e göre maxDistance'a kadar)\n        for (int ring = 3; ring <= 300; ring++) {\n            int ringDist = ring * ringStep;\n            if (ringDist > maxDistance) {\n                break;\n            }\n\n            for (int angle = 0; angle < 360; angle += angleStep) {\n                double rad = Math.toRadians(angle);\n                int candidateX = centerX + (int)(Math.cos(rad) * ringDist);\n                int candidateZ = centerZ + (int)(Math.sin(rad) * ringDist);\n\n                if (!validateDistance(candidateX, candidateZ, maxDistance, centerX, centerZ, minFromSpawn)) {\n                    continue;\n                }\n\n                if (!checkOverlap(candidateX, candidateZ, radius, existingOrbs)) {\n                    int y = 100 + random.nextInt(21) - 10; // 90-110 arası, daha güvenli\n                    return new PlacementResult(candidateX, y, candidateZ, true);\n                }\n            }\n        }\n\n        // SON ÇARE - Rastgele konumlar dene (ARTIRILDI)\n        for (int attempt = 0; attempt < 10000; attempt++) { // 5000'den 10000'e\n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = minFromSpawn + random.nextInt(maxDistance - minFromSpawn);\n            int candidateX = centerX + (int)(Math.cos(angle) * distance);\n            int candidateZ = centerZ + (int)(Math.sin(angle) * distance);\n\n            if (!validateDistance(candidateX, candidateZ, maxDistance, centerX, centerZ, minFromSpawn)) {\n                continue;\n            }\n\n            if (!checkOverlap(candidateX, candidateZ, radius, existingOrbs)) {\n                int y = 100 + random.nextInt(21) - 10;\n                return new PlacementResult(candidateX, y, candidateZ, true);\n            }\n        }\n\n        return new PlacementResult(0, 0, 0, false);\n    }\n    \n    private boolean validateDistance(int x, int z, int maxDistance, int centerX, int centerZ, int minFromSpawn) {\n        int dx = x - centerX;\n        int dz = z - centerZ;\n        double distFromCenter = Math.sqrt(dx * dx + dz * dz);\n        return distFromCenter <= maxDistance && distFromCenter >= minFromSpawn;\n    }\n    \n    private boolean checkOverlap(int x, int z, int newRadius, List<Orb> existingOrbs) {\n        // İlk olarak diğer gezegenlerle çakışma kontrolü\n        for (Orb orb : existingOrbs) {\n            double distance = orb.getDistanceFrom(x, z);\n            int safeDistance = orb.getRadius() + newRadius + 1200; // DAHA FAZLA MESAFE - 1200 blok güvenli mesafe\n\n            if (distance < safeDistance) {\n                return true;\n            }\n        }\n\n        // Rezerve edilmiş konum kontrolü\n        String key = x + \",\" + z;\n        if (reservedLocations.contains(key)) {\n            return true;\n        }\n\n        // BLOK KONTROLÜ - Daha az katı kontrol, sadece çok yoğun blok kümeleri varsa red et\n        return hasTooManyBlocksAtLocation(x, z, newRadius);\n    }\n\n    /**\n     * Belirtilen konumda çok fazla blok olup olmadığını kontrol eder (daha toleranslı)\n     */\n    private boolean hasTooManyBlocksAtLocation(int x, int z, int radius) {\n        // Gezegen oluşacak alanda örnekleme yap\n        int samplePoints = Math.min(8, radius / 5 + 1); // Daha az örnek\n        int step = Math.max(1, radius / samplePoints);\n        int blockCount = 0;\n        int totalChecks = 0;\n\n        for (int dx = -radius; dx <= radius; dx += step) {\n            for (int dz = -radius; dz <= radius; dz += step) {\n                double distance = Math.sqrt(dx * dx + dz * dz);\n                if (distance <= radius) {\n                    // Bu konumda blok kontrolü yap\n                    int checkX = x + dx;\n                    int checkZ = z + dz;\n\n                    // Yükseklik aralığında kontrol et (yeryüzü seviyesinde)\n                    for (int y = 60; y <= 140; y += 20) { // Daha az kontrol, 60-140 arası 20'er\n                        totalChecks++;\n                        // World instance'ı plugin'den al\n                        if (plugin.getServer().getWorlds().size() > 0) {\n                            var world = plugin.getServer().getWorlds().get(0); // Ana dünya\n                            if (world != null) {\n                                var block = world.getBlockAt(checkX, y, checkZ);\n                                var type = block.getType();\n                                // Hava, su, lava, kar dışında blok varsa say\n                                if (!type.isAir() && type != org.bukkit.Material.WATER &&\n                                    type != org.bukkit.Material.LAVA && type != org.bukkit.Material.SNOW &&\n                                    type != org.bukkit.Material.SNOW_BLOCK) {\n                                    blockCount++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // %30'dan fazla blok varsa çakışma var kabul et\n        return totalChecks > 0 && (blockCount * 100.0 / totalChecks) > 30.0;\n    }\n    \n    public void reserveLocation(int x, int z) {\n        reservedLocations.add(x + \",\" + z);\n    }\n    \n    public void releaseLocation(int x, int z) {\n        reservedLocations.remove(x + \",\" + z);\n    }\n    \n    public static class PlacementResult {\n        private final int x, y, z;\n        private final boolean success;\n        \n        public PlacementResult(int x, int y, int z, boolean success) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.success = success;\n        }\n        \n        public int getX() { return x; }\n        public int getY() { return y; }\n        public int getZ() { return z; }\n        public boolean isSuccess() { return success; }\n    }\n}\n","size_bytes":8970},"src/main/java/com/skyorbs/shapes/impl/FractalShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class FractalShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        double noise1 = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.1);\n        double noise2 = NoiseGenerator.getNoise(dx, dy, dz, seed + 1000, 0.2);\n        double noise3 = NoiseGenerator.getNoise(dx, dy, dz, seed + 2000, 0.4);\n        \n        double fractal = noise1 * 0.5 + noise2 * 0.3 + noise3 * 0.2;\n        double deformation = 1 + 0.4 * fractal;\n        \n        return distance <= radius * deformation;\n    }\n    \n    @Override\n    public String getName() {\n        return \"FRACTAL\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Fraktal\";\n    }\n}\n","size_bytes":1019},"src/main/java/com/skyorbs/shapes/impl/SnowflakeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SnowflakeShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kar tanesi şekli - 6 kollu yıldız\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = Math.abs(dx) / (double)radius;\n        double y = Math.abs(dy) / (double)radius;\n        double z = Math.abs(dz) / (double)radius;\n\n        // Snowflake formülü - 6 kollu simetri\n        double angle = Math.atan2(z, x);\n        double sector = angle / (Math.PI / 3); // 6 sektör\n        double sectorAngle = (sector - Math.floor(sector)) * (Math.PI / 3);\n\n        // Ana kollar ve yan dallar\n        double mainBranch = Math.cos(sectorAngle * 6);\n        double sideBranch = Math.cos(sectorAngle * 12) * 0.3;\n\n        double snowflake = mainBranch + sideBranch;\n        return Math.sqrt(x*x + z*z) <= snowflake * 0.5 + 0.2;\n    }\n\n    @Override\n    public String getName() {\n        return \"SNOWFLAKE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kar Tanesi\";\n    }\n}","size_bytes":1318},"src/main/java/com/skyorbs/shapes/impl/CubeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CubeShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        return Math.abs(dx) <= radius && Math.abs(dy) <= radius && Math.abs(dz) <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CUBE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Küp\";\n    }\n}\n","size_bytes":571},"src/main/java/com/skyorbs/shapes/impl/BoatShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class BoatShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Tekne şekli - hull, deck, mast, sails\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Boat hull (gövde) - V şeklinde\n        if (y < 0.0) {\n            double hullWidth = 0.6 + y * 0.4; // Aşağıda genişler\n            return Math.abs(z) <= hullWidth;\n        }\n\n        // Boat deck (güverte)\n        if (y >= 0.0 && y < 0.2) {\n            return Math.abs(z) <= 0.5;\n        }\n\n        // Mast (dikey direk)\n        if (Math.abs(z) <= 0.05 && y >= 0.2 && y < 0.8) {\n            return Math.abs(x) <= 0.05;\n        }\n\n        // Sails (yelkenler)\n        if (y >= 0.3 && y < 0.7) {\n            // Main sail\n            if (Math.abs(z) <= 0.3 && Math.abs(x - 0.1) <= 0.02) return true;\n            // Jib sail\n            if (Math.abs(z) <= 0.2 && Math.abs(x + 0.1) <= 0.02) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"BOAT\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Tekne\";\n    }\n}","size_bytes":1531},"src/main/java/com/skyorbs/shapes/impl/SpaceshipShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SpaceshipShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Uzay gemisi şekli - saucer, bridge, engines\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main saucer (disk shape)\n        if (Math.abs(y) <= 0.2) {\n            double saucerRadius = Math.sqrt(x*x + z*z);\n            return saucerRadius <= 0.8;\n        }\n\n        // Bridge (üst çıkıntı)\n        if (y > 0.2 && y < 0.6) {\n            double bridgeRadius = Math.sqrt(x*x + z*z);\n            return bridgeRadius <= 0.3;\n        }\n\n        // Engines (alt çıkıntılar)\n        if (y < -0.2 && y > -0.5) {\n            // 3 engine pods\n            for (int i = 0; i < 3; i++) {\n                double angle = i * 2 * Math.PI / 3;\n                double engineX = Math.cos(angle) * 0.5;\n                double engineZ = Math.sin(angle) * 0.5;\n                double engineDistance = Math.sqrt((x - engineX)*(x - engineX) + (z - engineZ)*(z - engineZ));\n                if (engineDistance <= 0.15) return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SPACESHIP\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Uzay Gemisi\";\n    }\n}","size_bytes":1682},"src/main/java/com/skyorbs/shapes/impl/BicycleShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class BicycleShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Bisiklet şekli - frame, wheels, handlebars, seat\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main frame triangle (ana üçgen şasi)\n        if (Math.abs(z) <= 0.05) {\n            // Top tube\n            if (Math.abs(y - 0.1) <= 0.03 && x >= -0.2 && x <= 0.2) return true;\n            // Seat tube\n            if (Math.abs(x + 0.15) <= 0.03 && y >= -0.1 && y <= 0.1) return true;\n            // Down tube\n            if (Math.abs(x - 0.15) <= 0.03 && y >= -0.1 && y <= 0.1) return true;\n        }\n\n        // Seat (sele)\n        if (Math.abs(x + 0.15) <= 0.08 && y > 0.1 && y < 0.2) {\n            return Math.abs(z) <= 0.1;\n        }\n\n        // Handlebars (direksiyon)\n        if (Math.abs(x - 0.15) <= 0.08 && Math.abs(y - 0.12) <= 0.03) {\n            return Math.abs(z) <= 0.15;\n        }\n\n        // Front wheel (ön tekerlek)\n        double frontWheelDist = Math.sqrt((x - 0.25)*(x - 0.25) + (y + 0.08)*(y + 0.08));\n        if (frontWheelDist <= 0.12) return true;\n\n        // Rear wheel (arka tekerlek)\n        double rearWheelDist = Math.sqrt((x + 0.25)*(x + 0.25) + (y + 0.08)*(y + 0.08));\n        if (rearWheelDist <= 0.12) return true;\n\n        // Pedals/crank (pedallar)\n        if (Math.abs(y) <= 0.05 && Math.abs(z) <= 0.03) {\n            if (Math.abs(x) <= 0.08) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"BICYCLE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Bisiklet\";\n    }\n}","size_bytes":2041},"src/main/java/com/skyorbs/shapes/impl/TorusShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TorusShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double majorRadius = radius * 0.7;\n        double minorRadius = radius * 0.3;\n        \n        double horizontalDist = Math.sqrt(dx * dx + dz * dz);\n        double torusCenterDist = Math.sqrt((horizontalDist - majorRadius) * (horizontalDist - majorRadius) + dy * dy);\n        \n        return torusCenterDist <= minorRadius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"TORUS\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Çörek\";\n    }\n}\n","size_bytes":817},"src/main/java/com/skyorbs/shapes/impl/ButterflyShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.SkyOrbs;\n\npublic class ButterflyShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kelebek şekli - simetrik kanatlar (CONFIG KONTROLLÜ)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // CONFIG'DEN ALGORİTMA AYARLARINI OKU\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        int wingSegments = plugin.getConfig().getInt(\"generation.shapes.algorithmTweaks.butterfly.wingSegments\", 3);\n        double bodyThickness = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.butterfly.bodyThickness\", 0.15);\n        double wingFactor = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.butterfly.wingFactor\", 0.6);\n        boolean symmetry = plugin.getConfig().getBoolean(\"generation.shapes.algorithmTweaks.butterfly.symmetry\", true);\n\n        // Normalize coordinates\n        double x = Math.abs(dx) / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Kelebek kanatları - config kontrollü segment sayısı\n        double wingPattern = Math.exp(-Math.pow(x, 2) / 0.3) * Math.sin(wingSegments * Math.PI * x);\n        double bodyFactor = Math.exp(-Math.pow(x, 2) / 0.1);\n\n        // Y koordinatı için kanat eğimi (config kontrollü)\n        double expectedY = wingPattern * wingFactor;\n\n        // Z koordinatı için kalınlık (config kontrollü)\n        double thickness = bodyThickness + bodyFactor * 0.1;\n\n        // Config kontrollü kontrol\n        return Math.abs(z) <= thickness && Math.abs(y - expectedY) <= 0.3;\n    }\n\n    @Override\n    public String getName() {\n        return \"BUTTERFLY\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kelebek\";\n    }\n}","size_bytes":2013},"src/main/java/com/skyorbs/shapes/impl/HatShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HatShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Şapka şekli - brim, crown\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Hat brim (kenar)\n        if (y > -0.1 && y < 0.1) {\n            double brimRadius = Math.sqrt(x*x + z*z);\n            return brimRadius <= 0.9;\n        }\n\n        // Hat crown (üst kısım)\n        if (y >= 0.1 && y < 0.6) {\n            double crownRadius = 0.5 - (y - 0.1) * 0.3; // Yukarıda daralır\n            return Math.sqrt(x*x + z*z) <= crownRadius;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"HAT\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Şapka\";\n    }\n}","size_bytes":1172},"src/test/java/com/skyorbs/BiomeTypeTest.java":{"content":"package com.skyorbs;\n\nimport com.skyorbs.biomes.BiomeType;\nimport org.bukkit.Material;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Random;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class BiomeTypeTest {\n\n    @Test\n    public void testBiomeTypeCount() {\n        BiomeType[] biomes = BiomeType.values();\n        assertTrue(biomes.length >= 22, \"Should have at least 22 biome types\");\n    }\n\n    @Test\n    public void testBiomeMaterialGeneration() {\n        Random random = new Random(12345);\n        BiomeType forest = BiomeType.FOREST;\n\n        // Test surface material\n        Material surface = forest.getMaterial(0, random);\n        assertNotNull(surface);\n\n        // Test subsurface material\n        Material subsurface = forest.getMaterial(3, random);\n        assertNotNull(subsurface);\n\n        // Test core material\n        Material core = forest.getMaterial(10, random);\n        assertNotNull(core);\n    }\n\n    @Test\n    public void testRandomBiomeSelection() {\n        Random random = new Random(54321);\n        BiomeType randomBiome = BiomeType.getRandomBiome(random);\n        assertNotNull(randomBiome);\n        assertTrue(randomBiome.name().length() > 0);\n    }\n\n    @Test\n    public void testWeightedBiomeSelection() {\n        Random random = new Random(11111);\n        BiomeType weightedBiome = BiomeType.getRandomBiomeWeighted(random);\n        assertNotNull(weightedBiome);\n        assertTrue(weightedBiome.name().length() > 0);\n    }\n\n    @Test\n    public void testBiomeDisplayNames() {\n        for (BiomeType biome : BiomeType.values()) {\n            assertNotNull(biome.getDisplayName());\n            assertTrue(biome.getDisplayName().length() > 0);\n        }\n    }\n}","size_bytes":1711},"src/main/java/com/skyorbs/listeners/PlanetEventListener.java":{"content":"package com.skyorbs.listeners;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Location;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.block.BlockBreakEvent;\nimport org.bukkit.event.block.BlockPlaceEvent;\nimport org.bukkit.event.player.PlayerMoveEvent;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n/**\n * Listens to player actions and grants planet XP\n */\npublic class PlanetEventListener implements Listener {\n    \n    private final SkyOrbs plugin;\n    \n    // Track player's current planet\n    private final Map<UUID, UUID> playerPlanetMap = new HashMap<>();\n    \n    public PlanetEventListener(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    /**\n     * Track which planet player is on\n     */\n    @EventHandler\n    public void onPlayerMove(PlayerMoveEvent event) {\n        // Only check every 5 blocks\n        Location from = event.getFrom();\n        Location to = event.getTo();\n        if (to == null || from.distanceSquared(to) < 25) return;\n        \n        Player player = event.getPlayer();\n        Orb nearestPlanet = findNearestPlanet(player);\n        \n        if (nearestPlanet != null) {\n            playerPlanetMap.put(player.getUniqueId(), nearestPlanet.getId());\n        } else {\n            playerPlanetMap.remove(player.getUniqueId());\n        }\n    }\n    \n    /**\n     * Grant XP for mining\n     */\n    @EventHandler\n    public void onBlockBreak(BlockBreakEvent event) {\n        if (event.isCancelled()) return;\n        \n        Player player = event.getPlayer();\n        UUID planetId = playerPlanetMap.get(player.getUniqueId());\n        \n        if (planetId == null) return;\n        \n        try {\n            Orb planet = plugin.getDatabaseManager().getOrb(planetId);\n            if (planet == null) return;\n            \n            // Grant XP based on block type\n            int xp = calculateBlockBreakXP(event.getBlock().getType());\n            planet.addXp(xp);\n            \n            // Update biosphere (mining reduces balance)\n            plugin.getBiosphereManager().updateBiosphere(planet, \"mining\");\n            \n            // Save changes\n            plugin.getDatabaseManager().saveOrb(planet);\n            \n            // Check for level up\n            if (planet.canUpgrade()) {\n                player.sendMessage(\"§a§l✨ Gezegen \" + planet.getName() + \" seviye atladı!\");\n                player.sendMessage(\"§eYeni seviye: §6\" + planet.getCoreLevel());\n            }\n            \n        } catch (Exception e) {\n            plugin.logError(\"Error granting planet XP\", e);\n        }\n    }\n    \n    /**\n     * Grant XP for planting\n     */\n    @EventHandler\n    public void onBlockPlace(BlockPlaceEvent event) {\n        if (event.isCancelled()) return;\n        \n        Player player = event.getPlayer();\n        UUID planetId = playerPlanetMap.get(player.getUniqueId());\n        \n        if (planetId == null) return;\n        \n        try {\n            Orb planet = plugin.getDatabaseManager().getOrb(planetId);\n            if (planet == null) return;\n            \n            // Grant XP for planting\n            int xp = calculateBlockPlaceXP(event.getBlock().getType());\n            if (xp > 0) {\n                planet.addXp(xp);\n                \n                // Update biosphere (planting improves balance)\n                plugin.getBiosphereManager().updateBiosphere(planet, \"planting\");\n                \n                // Save changes\n                plugin.getDatabaseManager().saveOrb(planet);\n            }\n            \n        } catch (Exception e) {\n            plugin.logError(\"Error granting planet XP\", e);\n        }\n    }\n    \n    /**\n     * Find nearest planet to player\n     */\n    private Orb findNearestPlanet(Player player) {\n        Location loc = player.getLocation();\n        Orb nearestOrb = null;\n        double minDistance = Double.MAX_VALUE;\n\n        try {\n            for (Orb orb : plugin.getDatabaseManager().getAllOrbs()) {\n                if (!orb.getWorldName().equals(loc.getWorld().getName())) continue;\n\n                double distance = Math.sqrt(\n                    Math.pow(loc.getX() - orb.getCenterX(), 2) +\n                    Math.pow(loc.getY() - orb.getCenterY(), 2) +\n                    Math.pow(loc.getZ() - orb.getCenterZ(), 2)\n                );\n\n                // Within planet radius + 50 blocks and closer than current nearest\n                if (distance <= orb.getRadius() + 50 && distance < minDistance) {\n                    minDistance = distance;\n                    nearestOrb = orb;\n                }\n            }\n        } catch (Exception e) {\n            // Ignore\n        }\n\n        return nearestOrb;\n    }\n    \n    /**\n     * Calculate XP for block break\n     */\n    private int calculateBlockBreakXP(org.bukkit.Material material) {\n        return switch (material) {\n            case DIAMOND_ORE, DEEPSLATE_DIAMOND_ORE -> 50;\n            case EMERALD_ORE, DEEPSLATE_EMERALD_ORE -> 75;\n            case ANCIENT_DEBRIS -> 100;\n            case GOLD_ORE, DEEPSLATE_GOLD_ORE -> 20;\n            case IRON_ORE, DEEPSLATE_IRON_ORE -> 10;\n            case COAL_ORE, DEEPSLATE_COAL_ORE -> 5;\n            case STONE, DEEPSLATE -> 1;\n            default -> 0;\n        };\n    }\n    \n    /**\n     * Calculate XP for block place\n     */\n    private int calculateBlockPlaceXP(org.bukkit.Material material) {\n        // Only grant XP for plants/trees\n        if (material.name().contains(\"SAPLING\")) return 10;\n        if (material.name().contains(\"LEAVES\")) return 2;\n        if (material == org.bukkit.Material.GRASS_BLOCK) return 5;\n        if (material.name().contains(\"FLOWER\")) return 3;\n        \n        return 0;\n    }\n}","size_bytes":5789},"src/main/java/com/skyorbs/shapes/impl/DiamondShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.SkyOrbs;\n\npublic class DiamondShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Elmas şekli - octahedron (DÜZELTİLMİŞ ALGORİTMA)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = Math.abs(dx) / (double)radius;\n        double y = Math.abs(dy) / (double)radius;\n        double z = Math.abs(dz) / (double)radius;\n\n        // Diamond shape - octahedron: max(x,y,z) + (x+y+z)/3 <= 1.0\n        // Daha basit ve güvenilir formül\n        double maxCoord = Math.max(Math.max(x, y), z);\n        double sumCoord = x + y + z;\n        return maxCoord + sumCoord / 3.0 <= 1.0;\n    }\n\n    @Override\n    public String getName() {\n        return \"DIAMOND\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.3;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Elmas\";\n    }\n}\n","size_bytes":1115},"src/main/java/com/skyorbs/features/TreeGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class TreeGenerator {\n    \n    public static List<OreGenerator.BlockData> generateTrees(Orb orb, BiomeType biome, World world) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(orb.getSeed() + 456);\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        // Only generate trees in hollow planets\n        if (!orb.getModifiers().contains(com.skyorbs.modifiers.PlanetModifier.HOLLOW)) {\n            return blocks;\n        }\n\n        // Get tree config\n        TreeConfig config = getTreeConfig(biome);\n        if (config == null) return blocks;\n\n        double treeMultiplier = 2.0;\n        int treeCount = (int)(radius * config.density * treeMultiplier);\n\n        for (int i = 0; i < treeCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // FIXED: Pass world for ground checking\n            int y = findGroundLevel(cx, cy, cz, x, z, radius, world);\n\n            if (y == -1) continue;\n\n            TreeType type = config.getRandomType(random);\n            generateTree(blocks, x, y + 1, z, type, random); // +1 to spawn above ground\n        }\n\n        return blocks;\n    }\n\n    /**\n     * IMPROVED: Find ground level with raycast from top to bottom\n     * Ensures trees spawn on actual solid blocks\n     */\n    private static int findGroundLevel(int cx, int cy, int cz, int x, int z, int radius, World world) {\n        // Start from top of planet and raycast downward\n        int searchStartY = cy + radius + 5;\n        int searchEndY = cy - radius;\n\n        Block previousBlock = null;\n\n        for (int y = searchStartY; y >= searchEndY; y--) {\n            Block currentBlock = world.getBlockAt(x, y, z);\n\n            // Check if we found ground (solid block with air above)\n            if (currentBlock.getType().isSolid() &&\n                (previousBlock == null || previousBlock.getType() == Material.AIR || previousBlock.getType() == Material.CAVE_AIR)) {\n\n                // Verify this is actually on planet surface\n                double distanceFromCenter = Math.sqrt(\n                    (x - cx) * (x - cx) +\n                    (y - cy) * (y - cy) +\n                    (z - cz) * (z - cz)\n                );\n\n                // Must be on or near surface (within 3 blocks of radius)\n                if (distanceFromCenter >= radius - 3 && distanceFromCenter <= radius + 1) {\n                    return y;\n                }\n            }\n\n            previousBlock = currentBlock;\n        }\n\n        return -1; // No suitable ground found\n    }\n    \n    /**\n     * Tek bir ağaç oluşturur\n     */\n    private static void generateTree(List<OreGenerator.BlockData> blocks, int x, int y, int z, \n                                     TreeType type, Random random) {\n        \n        int height = type.minHeight + random.nextInt(type.maxHeight - type.minHeight + 1);\n        \n        // Gövde\n        for (int i = 0; i < height; i++) {\n            blocks.add(new OreGenerator.BlockData(x, y + i, z, type.logMaterial));\n        }\n        \n        // Yapraklar\n        int leafStart = y + height - type.leafLayers;\n        for (int ly = 0; ly < type.leafLayers; ly++) {\n            int currentY = leafStart + ly;\n            int leafRadius = type.leafRadius - (ly / 2);\n            \n            for (int dx = -leafRadius; dx <= leafRadius; dx++) {\n                for (int dz = -leafRadius; dz <= leafRadius; dz++) {\n                    if (dx == 0 && dz == 0 && ly < type.leafLayers - 1) continue; // Gövdeyi atla\n                    \n                    double distance = Math.sqrt(dx * dx + dz * dz);\n                    if (distance <= leafRadius + random.nextDouble() * 0.5) {\n                        blocks.add(new OreGenerator.BlockData(x + dx, currentY, z + dz, type.leafMaterial));\n                    }\n                }\n            }\n        }\n        \n        // Özel özellikler\n        if (type == TreeType.OAK && random.nextDouble() < 0.15) {\n            // Arı kovanı ekle\n            int side = random.nextInt(4);\n            int beeY = y + height - 2;\n            switch (side) {\n                case 0 -> blocks.add(new OreGenerator.BlockData(x + 1, beeY, z, Material.BEE_NEST));\n                case 1 -> blocks.add(new OreGenerator.BlockData(x - 1, beeY, z, Material.BEE_NEST));\n                case 2 -> blocks.add(new OreGenerator.BlockData(x, beeY, z + 1, Material.BEE_NEST));\n                case 3 -> blocks.add(new OreGenerator.BlockData(x, beeY, z - 1, Material.BEE_NEST));\n            }\n        }\n        \n        if (type == TreeType.JUNGLE && random.nextDouble() < 0.25) {\n            // Kakao ekle\n            int cocoaCount = 1 + random.nextInt(3);\n            for (int i = 0; i < cocoaCount; i++) {\n                int cocoaY = y + 2 + random.nextInt(height - 3);\n                int side = random.nextInt(4);\n                switch (side) {\n                    case 0 -> blocks.add(new OreGenerator.BlockData(x + 1, cocoaY, z, Material.COCOA));\n                    case 1 -> blocks.add(new OreGenerator.BlockData(x - 1, cocoaY, z, Material.COCOA));\n                    case 2 -> blocks.add(new OreGenerator.BlockData(x, cocoaY, z + 1, Material.COCOA));\n                    case 3 -> blocks.add(new OreGenerator.BlockData(x, cocoaY, z - 1, Material.COCOA));\n                }\n            }\n            \n            // Asma yapraklar\n            int vineCount = 3 + random.nextInt(5);\n            for (int i = 0; i < vineCount; i++) {\n                int vineX = x + random.nextInt(5) - 2;\n                int vineZ = z + random.nextInt(5) - 2;\n                int vineLength = 2 + random.nextInt(4);\n                \n                for (int vl = 0; vl < vineLength; vl++) {\n                    blocks.add(new OreGenerator.BlockData(vineX, y + height - vl, vineZ, Material.VINE));\n                }\n            }\n        }\n        \n        if (type == TreeType.DARK_OAK && random.nextDouble() < 0.30) {\n            // Mantarlar ekle\n            for (int i = 0; i < 3; i++) {\n                int mushX = x + random.nextInt(5) - 2;\n                int mushZ = z + random.nextInt(5) - 2;\n                Material mushroom = random.nextBoolean() ? Material.RED_MUSHROOM : Material.BROWN_MUSHROOM;\n                blocks.add(new OreGenerator.BlockData(mushX, y, mushZ, mushroom));\n            }\n        }\n        \n        if (type == TreeType.CHERRY && random.nextDouble() < 0.40) {\n            // Pembe yaprak efekti (ek yapraklar)\n            for (int i = 0; i < 5; i++) {\n                int petalX = x + random.nextInt(7) - 3;\n                int petalY = y + height + random.nextInt(2);\n                int petalZ = z + random.nextInt(7) - 3;\n                blocks.add(new OreGenerator.BlockData(petalX, petalY, petalZ, Material.PINK_PETALS));\n            }\n        }\n    }\n    \n    /**\n     * Biyom bazlı ağaç konfigürasyonu\n     */\n    private static TreeConfig getTreeConfig(BiomeType biome) {\n        return switch (biome) {\n            case FOREST -> new TreeConfig(0.25, \n                new TreeType[]{TreeType.OAK, TreeType.BIRCH, TreeType.DARK_OAK},\n                new double[]{0.5, 0.3, 0.2});\n            \n            case JUNGLE -> new TreeConfig(0.35, \n                new TreeType[]{TreeType.JUNGLE, TreeType.JUNGLE_LARGE},\n                new double[]{0.7, 0.3});\n            \n            case TAIGA -> new TreeConfig(0.20, \n                new TreeType[]{TreeType.SPRUCE, TreeType.PINE},\n                new double[]{0.7, 0.3});\n            \n            case SAVANNA -> new TreeConfig(0.08, \n                new TreeType[]{TreeType.ACACIA},\n                new double[]{1.0});\n            \n            case MEADOW -> new TreeConfig(0.15, \n                new TreeType[]{TreeType.OAK, TreeType.BIRCH, TreeType.CHERRY},\n                new double[]{0.4, 0.4, 0.2});\n            \n            case PLAINS -> new TreeConfig(0.05, \n                new TreeType[]{TreeType.OAK},\n                new double[]{1.0});\n            \n            case MUSHROOM_GIANT -> new TreeConfig(0.12, \n                new TreeType[]{TreeType.GIANT_MUSHROOM_RED, TreeType.GIANT_MUSHROOM_BROWN},\n                new double[]{0.5, 0.5});\n            \n            case TOXIC_SWAMP -> new TreeConfig(0.18, \n                new TreeType[]{TreeType.MANGROVE, TreeType.DARK_OAK},\n                new double[]{0.6, 0.4});\n            \n            default -> null;\n        };\n    }\n    \n    /**\n     * Ağaç türleri\n     */\n    public enum TreeType {\n        OAK(Material.OAK_LOG, Material.OAK_LEAVES, 4, 6, 2, 4),\n        BIRCH(Material.BIRCH_LOG, Material.BIRCH_LEAVES, 5, 7, 2, 4),\n        SPRUCE(Material.SPRUCE_LOG, Material.SPRUCE_LEAVES, 6, 10, 2, 5),\n        JUNGLE(Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, 4, 6, 2, 4),\n        JUNGLE_LARGE(Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, 10, 15, 3, 6),\n        ACACIA(Material.ACACIA_LOG, Material.ACACIA_LEAVES, 4, 6, 3, 4),\n        DARK_OAK(Material.DARK_OAK_LOG, Material.DARK_OAK_LEAVES, 5, 7, 3, 5),\n        MANGROVE(Material.MANGROVE_LOG, Material.MANGROVE_LEAVES, 4, 7, 2, 4),\n        CHERRY(Material.CHERRY_LOG, Material.CHERRY_LEAVES, 5, 8, 3, 5),\n        PINE(Material.SPRUCE_LOG, Material.SPRUCE_LEAVES, 8, 12, 2, 6),\n        GIANT_MUSHROOM_RED(Material.MUSHROOM_STEM, Material.RED_MUSHROOM_BLOCK, 4, 6, 3, 5),\n        GIANT_MUSHROOM_BROWN(Material.MUSHROOM_STEM, Material.BROWN_MUSHROOM_BLOCK, 4, 6, 3, 5);\n\n        public final Material logMaterial;\n        public final Material leafMaterial;\n        public final int minHeight;\n        public final int maxHeight;\n        public final int leafRadius;\n        public final int leafLayers;\n\n        TreeType(Material log, Material leaf, int minH, int maxH, int leafR, int leafL) {\n            this.logMaterial = log;\n            this.leafMaterial = leaf;\n            this.minHeight = minH;\n            this.maxHeight = maxH;\n            this.leafRadius = leafR;\n            this.leafLayers = leafL;\n        }\n    }\n    \n    /**\n     * Biyom ağaç konfigürasyonu\n     */\n    public static class TreeConfig {\n        public final double density;\n        public final TreeType[] types;\n        public final double[] weights;\n\n        public TreeConfig(double density, TreeType[] types, double[] weights) {\n            this.density = density;\n            this.types = types;\n            this.weights = weights;\n        }\n\n        public TreeType getRandomType(Random random) {\n            double total = 0;\n            for (double w : weights) total += w;\n\n            double rand = random.nextDouble() * total;\n            double current = 0;\n\n            for (int i = 0; i < types.length; i++) {\n                current += weights[i];\n                if (rand <= current) {\n                    return types[i];\n                }\n            }\n\n            return types[0];\n        }\n    }\n}","size_bytes":11266},"src/main/java/com/skyorbs/shapes/impl/HemisphereShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HemisphereShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Küre formülü + yarım küre için y <= 0 koşulu (YUKARIDAN AŞAĞI!)\n        // ÜST TARAFI DA DOLDUR - tam yarım küre!\n        return dx * dx + dy * dy + dz * dz <= radius * radius && dy <= radius/2;\n    }\n\n    @Override\n    public String getName() {\n        return \"HEMISPHERE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Yarım Küre\";\n    }\n}","size_bytes":701},"src/main/java/com/skyorbs/shapes/impl/AsteroidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class AsteroidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.2);\n        double roughness = 0.6 + 0.4 * Math.abs(noise);\n        return distance <= radius * roughness;\n    }\n    \n    @Override\n    public String getName() {\n        return \"ASTEROID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Asteroid\";\n    }\n}\n","size_bytes":773},"src/main/java/com/skyorbs/dungeons/DungeonGenerator.java":{"content":"package com.skyorbs.dungeons;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.*;\n\npublic class DungeonGenerator {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n\n    public DungeonGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Generate mini-dungeons within planets - CONFIG KONTROLLÜ\n     */\n    public List<DungeonRoom> generateDungeons(Orb orb, int count) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n\n        // CONFIG KONTROLLÜ - Dungeon sistemi aktif mi?\n        if (!plugin.getConfig().getBoolean(\"dungeons.enabled\", true)) {\n            return new ArrayList<DungeonRoom>();\n        }\n\n        List<DungeonRoom> dungeons = new ArrayList<DungeonRoom>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        PlanetType planetType = orb.getPlanetType();\n\n        // CONFIG'DEN PLANET TYPE AYARLARINI OKU\n        String planetTypeKey = planetType.name().toLowerCase();\n        boolean planetEnabled = plugin.getConfig().getBoolean(\"dungeons.planetTypes.\" + planetTypeKey + \".enabled\", true);\n        if (!planetEnabled) return dungeons;\n\n        double baseDensity = plugin.getConfig().getDouble(\"dungeons.densityMultiplier\", 0.008);\n        double planetMultiplier = plugin.getConfig().getDouble(\"dungeons.planetTypes.\" + planetTypeKey + \".densityMultiplier\", 1.0);\n        int actualCount = (int)(count * planetMultiplier);\n\n        SimplexOctaveGenerator dungeonNoise = new SimplexOctaveGenerator(seed + 500, 4);\n        dungeonNoise.setScale(0.01);\n\n        for (int i = 0; i < actualCount; i++) {\n            // Find suitable location for dungeon\n            int attempts = 0;\n            boolean placed = false;\n\n            while (!placed && attempts < 50) {\n                // Generate position biased towards planet center\n                double angle = random.nextDouble() * 2 * Math.PI;\n                double distance = random.nextDouble() * (radius * 0.6); // Bias towards center - max 60% of radius\n\n                int x = cx + (int)(Math.cos(angle) * distance);\n                int z = cz + (int)(Math.sin(angle) * distance);\n\n                // Find surface level first, then place dungeon below it\n                int surfaceY = findSurfaceLevelWithinPlanet(cx, cy, cz, x, z, radius, random);\n                if (surfaceY == -1) {\n                    attempts++;\n                    continue; // No surface found, try again\n                }\n\n                // Place dungeon below surface, within planet bounds\n                int y = surfaceY - (3 + random.nextInt(5)); // 3-7 blocks below surface\n\n                // Check if location is valid (inside planet, not too close to surface)\n                double distFromCenter = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n                if (distFromCenter <= radius * 0.9 && distFromCenter >= radius * 0.3) {\n                    DungeonRoom dungeon = generateDungeonRoom(orb, x, y, z, seed + i);\n                    if (dungeon != null) {\n                        dungeons.add(dungeon);\n                        placed = true;\n                    }\n                }\n                attempts++;\n            }\n        }\n\n        return dungeons;\n    }\n\n    private DungeonRoom generateDungeonRoom(Orb orb, int x, int y, int z, long seed) {\n        Random roomRandom = new Random(seed);\n        DungeonType type = getDungeonTypeFromConfig(orb.getPlanetType(), roomRandom);\n\n        // CONFIG'DEN ROOM SIZE AYARLARINI OKU\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        String planetTypeKey = orb.getPlanetType().name().toLowerCase();\n        String sizePath = \"dungeons.planetTypes.\" + planetTypeKey + \".sizeSettings.\";\n\n        int minWidth = plugin.getConfig().getInt(sizePath + \"width.min\", type.baseSize);\n        int maxWidth = plugin.getConfig().getInt(sizePath + \"width.max\", type.baseSize + 3);\n        int minHeight = plugin.getConfig().getInt(sizePath + \"height.min\", type.baseSize);\n        int maxHeight = plugin.getConfig().getInt(sizePath + \"height.max\", type.baseSize + 2);\n        int minLength = plugin.getConfig().getInt(sizePath + \"length.min\", type.baseSize);\n        int maxLength = plugin.getConfig().getInt(sizePath + \"length.max\", type.baseSize + 3);\n\n        // Room size based on config\n        int width = minWidth + roomRandom.nextInt(maxWidth - minWidth + 1);\n        int height = minHeight + roomRandom.nextInt(maxHeight - minHeight + 1);\n        int length = minLength + roomRandom.nextInt(maxLength - minLength + 1);\n\n        // Create room bounds\n        int minX = x - width/2;\n        int maxX = x + width/2;\n        int minY = y - height/2;\n        int maxY = y + height/2;\n        int minZ = z - length/2;\n        int maxZ = z + length/2;\n\n        DungeonRoom room = new DungeonRoom(type, minX, minY, minZ, maxX, maxY, maxZ);\n\n        // Generate room structure\n        generateRoomStructure(orb, room, roomRandom);\n\n        // Add loot\n        generateLoot(orb, room, roomRandom);\n\n        // Add mobs if applicable\n        generateMobs(room, roomRandom);\n\n        return room;\n    }\n\n    private void generateRoomStructure(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        // Clear area and create walls/floor/ceiling\n        for (int x = room.minX; x <= room.maxX; x++) {\n            for (int y = room.minY; y <= room.maxY; y++) {\n                for (int z = room.minZ; z <= room.maxZ; z++) {\n                    Block block = world.getBlockAt(x, y, z);\n                    Material material;\n\n                    if (x == room.minX || x == room.maxX || z == room.minZ || z == room.maxZ) {\n                        // Walls\n                        material = getWallMaterial(room.type, random);\n                    } else if (y == room.minY) {\n                        // Floor\n                        material = getFloorMaterial(room.type, random);\n                    } else if (y == room.maxY) {\n                        // Ceiling\n                        material = getCeilingMaterial(room.type, random);\n                    } else {\n                        // Air\n                        material = Material.AIR;\n                    }\n\n                    block.setType(material, false);\n                }\n            }\n        }\n\n        // Add decorative elements\n        addDecorations(orb, room, random);\n    }\n\n    private void addDecorations(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        int decorationCount = random.nextInt(5) + 3;\n\n        for (int i = 0; i < decorationCount; i++) {\n            int x = room.minX + 1 + random.nextInt(room.maxX - room.minX - 1);\n            int z = room.minZ + 1 + random.nextInt(room.maxZ - room.minZ - 1);\n            int y = room.minY + 1;\n\n            Block floorBlock = world.getBlockAt(x, y, z);\n            if (floorBlock.getType() == Material.AIR) {\n                Material decoration = getDecorationMaterial(room.type, random);\n                floorBlock.setType(decoration, false);\n            }\n        }\n    }\n\n    private void generateLoot(Orb orb, DungeonRoom room, Random random) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        // Place treasure chest in center\n        int centerX = (room.minX + room.maxX) / 2;\n        int centerZ = (room.minZ + room.maxZ) / 2;\n        int chestY = room.minY + 1;\n\n        Block chestBlock = world.getBlockAt(centerX, chestY, centerZ);\n        chestBlock.setType(Material.CHEST, false);\n\n        if (chestBlock.getState() instanceof Chest chest) {\n            List<ItemStack> loot = generateLootItems(room.type, orb.getCoreLevel(), random);\n            for (int i = 0; i < Math.min(loot.size(), 27); i++) {\n                chest.getInventory().setItem(i, loot.get(i));\n            }\n        }\n    }\n\n    private List<ItemStack> generateLootItems(DungeonType type, int coreLevel, Random random) {\n        List<ItemStack> loot = new ArrayList<ItemStack>();\n\n        // Base loot based on dungeon type - FIXED: Ensure amount is always >= 1\n        switch (type) {\n            case CRYSTAL_CAVERN -> {\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, random.nextInt(3) + 1)));\n                loot.add(new ItemStack(Material.EMERALD, Math.max(1, random.nextInt(2) + 1)));\n                if (coreLevel >= 3) {\n                    loot.add(new ItemStack(Material.AMETHYST_SHARD, Math.max(1, random.nextInt(5) + 3)));\n                }\n            }\n            case LAVA_CHAMBER -> {\n                loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, random.nextInt(4) + 2)));\n                int netheriteAmount = random.nextInt(2) + 1; // FIXED: +1 to ensure at least 1\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, netheriteAmount)));\n                if (coreLevel >= 4) {\n                    loot.add(new ItemStack(Material.ANCIENT_DEBRIS, Math.max(1, random.nextInt(3) + 1)));\n                }\n            }\n            case ICE_TOMB -> {\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, random.nextInt(2) + 1)));\n                if (coreLevel >= 2) {\n                    loot.add(new ItemStack(Material.BLUE_ICE, Math.max(1, random.nextInt(8) + 4)));\n                }\n            }\n            case SHADOW_VAULT -> {\n                loot.add(new ItemStack(Material.OBSIDIAN, Math.max(1, random.nextInt(16) + 8)));\n                if (coreLevel >= 5) {\n                    loot.add(new ItemStack(Material.CRYING_OBSIDIAN, Math.max(1, random.nextInt(4) + 1)));\n                }\n            }\n            case TOXIC_LAB -> {\n                loot.add(new ItemStack(Material.SLIME_BALL, Math.max(1, random.nextInt(12) + 6)));\n                if (coreLevel >= 3) {\n                    loot.add(new ItemStack(Material.HONEY_BOTTLE, Math.max(1, random.nextInt(3) + 1)));\n                }\n            }\n        }\n\n        // Add common loot - FIXED: Ensure amount is always >= 1\n        loot.add(new ItemStack(Material.IRON_INGOT, Math.max(1, random.nextInt(8) + 4)));\n        loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, random.nextInt(4) + 2)));\n\n        // Add experience bottles based on core level\n        int expBottles = Math.max(1, Math.min(coreLevel, 3)); // FIXED: At least 1\n        for (int i = 0; i < expBottles; i++) {\n            loot.add(new ItemStack(Material.EXPERIENCE_BOTTLE, Math.max(1, random.nextInt(3) + 1)));\n        }\n\n        return loot;\n    }\n\n    private void generateMobs(DungeonRoom room, Random random) {\n        // This would integrate with Minecraft's mob spawning system\n        // For now, we'll just mark that mobs should spawn here\n        room.hasMobs = random.nextDouble() < 0.7; // 70% chance of mobs\n    }\n\n    /**\n     * Find surface level within planet bounds - ensures dungeons are placed within planet volume\n     */\n    private int findSurfaceLevelWithinPlanet(int cx, int cy, int cz, int x, int z, int radius, Random random) {\n        // Start from top of planet and raycast downward to find first solid block\n        int searchStartY = cy + radius + 5;\n        int searchEndY = cy - radius;\n\n        for (int y = searchStartY; y >= searchEndY; y--) {\n            // Check if position is within planet bounds\n            double distanceFromCenter = Math.sqrt(\n                (x - cx) * (x - cx) +\n                (y - cy) * (y - cy) +\n                (z - cz) * (z - cz)\n            );\n\n            // Must be on or near surface (within 3 blocks of radius)\n            if (distanceFromCenter >= radius - 3 && distanceFromCenter <= radius + 1) {\n                return y; // Found surface level\n            }\n        }\n\n        return -1; // No suitable surface found\n    }\n\n    /**\n     * Generate core crystal at planet center\n     */\n    public void generateCoreCrystal(Orb orb) {\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n\n        // Create crystal structure\n        int crystalSize = Math.min(3, orb.getCoreLevel());\n\n        for (int x = -crystalSize; x <= crystalSize; x++) {\n            for (int y = -crystalSize; y <= crystalSize; y++) {\n                for (int z = -crystalSize; z <= crystalSize; z++) {\n                    double distance = Math.sqrt(x * x + y * y + z * z);\n                    if (distance <= crystalSize) {\n                        Block block = world.getBlockAt(cx + x, cy + y, cz + z);\n                        if (distance < crystalSize * 0.5) {\n                            block.setType(Material.AMETHYST_BLOCK, false);\n                        } else {\n                            block.setType(Material.BUDDING_AMETHYST, false);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Create chest with special loot\n        Block chestBlock = world.getBlockAt(cx, cy + crystalSize + 1, cz);\n        chestBlock.setType(Material.CHEST, false);\n\n        if (chestBlock.getState() instanceof Chest chest) {\n            List<ItemStack> specialLoot = generateCoreLoot(orb);\n            for (int i = 0; i < Math.min(specialLoot.size(), 27); i++) {\n                chest.getInventory().setItem(i, specialLoot.get(i));\n            }\n        }\n    }\n\n    private List<ItemStack> generateCoreLoot(Orb orb) {\n        List<ItemStack> loot = new ArrayList<ItemStack>();\n        Random random = new Random(orb.getSeed() + 999);\n\n        // Legendary items based on core level - FIXED: Ensure amount is always >= 1\n        if (orb.getCoreLevel() >= 5) {\n            loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, random.nextInt(3) + 1)));\n            loot.add(new ItemStack(Material.DIAMOND_BLOCK, Math.max(1, random.nextInt(2) + 1)));\n        }\n\n        if (orb.getCoreLevel() >= 7) {\n            loot.add(new ItemStack(Material.ELYTRA, 1));\n        }\n\n        if (orb.getCoreLevel() >= 10) {\n            loot.add(new ItemStack(Material.NETHER_STAR, 1));\n        }\n\n        // Planet-specific legendary items - FIXED: Ensure amount is always >= 1\n        switch (orb.getPlanetType()) {\n            case CRYSTAL -> loot.add(new ItemStack(Material.AMETHYST_BLOCK, Math.max(1, random.nextInt(16) + 8)));\n            case LAVA -> loot.add(new ItemStack(Material.ANCIENT_DEBRIS, Math.max(1, random.nextInt(8) + 4)));\n            case ICE -> loot.add(new ItemStack(Material.BLUE_ICE, Math.max(1, random.nextInt(32) + 16)));\n            case SHADOW -> loot.add(new ItemStack(Material.CRYING_OBSIDIAN, Math.max(1, random.nextInt(12) + 6)));\n            case TOXIC -> loot.add(new ItemStack(Material.SLIME_BLOCK, Math.max(1, random.nextInt(24) + 12)));\n        }\n\n        return loot;\n    }\n\n    // Material getters\n    private Material getWallMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> random.nextDouble() < 0.8 ? Material.AMETHYST_BLOCK : Material.QUARTZ_BLOCK;\n            case LAVA_CHAMBER -> random.nextDouble() < 0.7 ? Material.NETHERRACK : Material.MAGMA_BLOCK;\n            case ICE_TOMB -> random.nextDouble() < 0.9 ? Material.ICE : Material.PACKED_ICE;\n            case SHADOW_VAULT -> Material.OBSIDIAN;\n            case TOXIC_LAB -> Material.GREEN_CONCRETE;\n        };\n    }\n\n    private Material getFloorMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> Material.QUARTZ_BLOCK;\n            case LAVA_CHAMBER -> Material.MAGMA_BLOCK;\n            case ICE_TOMB -> Material.PACKED_ICE;\n            case SHADOW_VAULT -> Material.CRYING_OBSIDIAN;\n            case TOXIC_LAB -> Material.SLIME_BLOCK;\n        };\n    }\n\n    private Material getCeilingMaterial(DungeonType type, Random random) {\n        return getWallMaterial(type, random);\n    }\n\n    private Material getDecorationMaterial(DungeonType type, Random random) {\n        return switch (type) {\n            case CRYSTAL_CAVERN -> Material.AMETHYST_CLUSTER;\n            case LAVA_CHAMBER -> Material.LAVA;\n            case ICE_TOMB -> Material.SNOW;\n            case SHADOW_VAULT -> Material.SOUL_LANTERN;\n            case TOXIC_LAB -> Material.GREEN_WOOL;\n        };\n    }\n\n    /**\n     * CONFIG'DEN DUNGEON TİPİ SEÇ - Gezegen türüne göre\n     */\n    private DungeonType getDungeonTypeFromConfig(PlanetType planetType, Random random) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        String planetTypeKey = planetType.name().toLowerCase();\n        String configPath = \"dungeons.planetTypes.\" + planetTypeKey + \".dungeonTypes\";\n\n        // Config'den olasılıkları oku\n        double crystalCavernProb = plugin.getConfig().getDouble(configPath + \".crystal_cavern\", 0.0);\n        double lavaChamberProb = plugin.getConfig().getDouble(configPath + \".lava_chamber\", 0.0);\n        double iceTombProb = plugin.getConfig().getDouble(configPath + \".ice_tomb\", 0.0);\n        double shadowVaultProb = plugin.getConfig().getDouble(configPath + \".shadow_vault\", 0.0);\n        double toxicLabProb = plugin.getConfig().getDouble(configPath + \".toxic_lab\", 0.0);\n\n        // Weighted random selection\n        double rand = random.nextDouble();\n        double total = 0;\n\n        if ((total += crystalCavernProb) > rand) return DungeonType.CRYSTAL_CAVERN;\n        if ((total += lavaChamberProb) > rand) return DungeonType.LAVA_CHAMBER;\n        if ((total += iceTombProb) > rand) return DungeonType.ICE_TOMB;\n        if ((total += shadowVaultProb) > rand) return DungeonType.SHADOW_VAULT;\n        if ((total += toxicLabProb) > rand) return DungeonType.TOXIC_LAB;\n\n        // Fallback - default dungeon type\n        return DungeonType.CRYSTAL_CAVERN;\n    }\n\n    public enum DungeonType {\n        CRYSTAL_CAVERN(5, \"Kristal Mağarası\"),\n        LAVA_CHAMBER(6, \"Lava Odası\"),\n        ICE_TOMB(4, \"Buz Mezarlığı\"),\n        SHADOW_VAULT(5, \"Gölge Kasası\"),\n        TOXIC_LAB(5, \"Zehirli Laboratuvar\");\n\n        final int baseSize;\n        final String displayName;\n\n        DungeonType(int baseSize, String displayName) {\n            this.baseSize = baseSize;\n            this.displayName = displayName;\n        }\n\n        public String getDisplayName() { return displayName; }\n    }\n\n    public static class DungeonRoom {\n        public final DungeonType type;\n        public final int minX, minY, minZ, maxX, maxY, maxZ;\n        public boolean hasMobs;\n\n        public DungeonRoom(DungeonType type, int minX, int minY, int minZ, int maxX, int maxY, int maxZ) {\n            this.type = type;\n            this.minX = minX;\n            this.minY = minY;\n            this.minZ = minZ;\n            this.maxX = maxX;\n            this.maxY = maxY;\n            this.maxZ = maxZ;\n            this.hasMobs = false;\n        }\n    }\n}","size_bytes":19407},"src/main/java/com/skyorbs/palettes/PlanetPalette.java":{"content":"package com.skyorbs.palettes;\n\nimport org.bukkit.Material;\nimport java.util.Random;\n\n/**\n * Defines a planet's block composition for diverse visual variety\n * Enables 2000+ planet combinations through modular palette system\n */\npublic class PlanetPalette {\n\n    private final String id;\n    private final String displayName;\n    private final Material[] surfaceBlocks;\n    private final Material[] subsurfaceBlocks;\n    private final Material[] coreBlocks;\n    private final Material[] decorationBlocks;\n    private final double weight;\n    \n    public PlanetPalette(String id, String displayName, \n                        Material[] surfaceBlocks, \n                        Material[] subsurfaceBlocks,\n                        Material[] coreBlocks,\n                        Material[] decorationBlocks,\n                        double weight) {\n        this.id = id;\n        this.displayName = displayName;\n        this.surfaceBlocks = surfaceBlocks;\n        this.subsurfaceBlocks = subsurfaceBlocks;\n        this.coreBlocks = coreBlocks;\n        this.decorationBlocks = decorationBlocks;\n        this.weight = weight;\n    }\n    \n    public String getId() {\n        return id;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getWeight() {\n        return weight;\n    }\n    \n    /**\n     * Get material based on depth from surface\n     * @param depth 0 = surface, higher = deeper\n     * @param random Random for variation\n     * @return Material for this depth\n     */\n    public Material getMaterialByDepth(int depth, Random random) {\n        if (depth == 0) {\n            // Surface layer\n            return surfaceBlocks[random.nextInt(surfaceBlocks.length)];\n        } else if (depth < 5) {\n            // Subsurface layer (0-5 blocks deep)\n            return subsurfaceBlocks[random.nextInt(subsurfaceBlocks.length)];\n        } else {\n            // Core layer (5+ blocks deep)\n            return coreBlocks[random.nextInt(coreBlocks.length)];\n        }\n    }\n\n    /**\n     * Get material based on depth and regional noise for coherent regions\n     * @param depth 0 = surface, higher = deeper\n     * @param noiseValue Noise value between 0-1 for regional coherence\n     * @param random Random for variation\n     * @return Material for this depth and region\n     */\n    public Material getMaterialByDepthAndNoise(int depth, double noiseValue, Random random) {\n        // Use noise to select consistent materials within regions\n        int surfaceIndex = (int)(noiseValue * surfaceBlocks.length);\n        int subsurfaceIndex = (int)(noiseValue * subsurfaceBlocks.length);\n        int coreIndex = (int)(noiseValue * coreBlocks.length);\n\n        // Ensure indices are within bounds\n        surfaceIndex = Math.min(surfaceIndex, surfaceBlocks.length - 1);\n        subsurfaceIndex = Math.min(subsurfaceIndex, subsurfaceBlocks.length - 1);\n        coreIndex = Math.min(coreIndex, coreBlocks.length - 1);\n\n        if (depth == 0) {\n            // Surface layer - use noise for regional consistency\n            return surfaceBlocks[surfaceIndex];\n        } else if (depth < 5) {\n            // Subsurface layer (0-5 blocks deep) - use noise for regional consistency\n            return subsurfaceBlocks[subsurfaceIndex];\n        } else {\n            // Core layer (5+ blocks deep) - use noise for regional consistency\n            return coreBlocks[coreIndex];\n        }\n    }\n    \n    /**\n     * Get random decoration block for surface features\n     */\n    public Material getDecorationBlock(Random random) {\n        if (decorationBlocks.length == 0) return null;\n        return decorationBlocks[random.nextInt(decorationBlocks.length)];\n    }\n    \n    /**\n     * Get surface material\n     */\n    public Material getPrimarySurface() {\n        return surfaceBlocks[0];\n    }\n    \n    /**\n     * Get core material\n     */\n    public Material getPrimaryCore() {\n        return coreBlocks[0];\n    }\n}\n","size_bytes":3946},"FIXED_ISSUES.md":{"content":"# SkyOrbs 2.0.0 - Düzeltilen Sorunlar\n\n## ✅ Çözülen Kritik Sorunlar\n\n### 1. İçi Dolu Gezegen %87 Hatası (ÇÖZÜLDÜ)\n**Sorun**: İçi dolu gezegenler %87'de takılıyordu ve tamamlanmıyordu\n**Sebep**: Asteroid/satellite generation kısmında ItemStack amount hatası\n**Çözüm**: \n- Asteroid/satellite generation geçici olarak devre dışı bırakıldı\n- Ana gezegen generation akışı düzeltildi\n- Progress tracking düzeltildi\n- Callback sistemi optimize edildi\n\n### 2. ItemStack Amount Hatası (ÇÖZÜLDÜ)\n**Sorun**: `amount must be greater than 0` hatası\n**Sebep**: DungeonGenerator'da random.nextInt() 0 döndürebiliyordu\n**Çözüm**: Tüm ItemStack oluşturma yerlerinde `Math.max(1, ...)` kullanıldı\n\n### 3. Config Detaylandırması (TAMAMLANDI)\n**Sorun**: Config yeterince detaylı değildi\n**Çözüm**: 1000+ satır detaylı config oluşturuldu\n\n## 📋 Şimdi Çalışan Özellikler\n\n### ✅ İçi Dolu Gezegenler\n- Tam dolu gezegen oluşumu\n- Ore generation (madenler içinde)\n- Tree generation (ağaçlar yüzeyde)\n- Structure generation (yapılar)\n- Treasure generation (hazineler)\n- Dungeon generation (zindanlar)\n\n### ✅ İçi Boş Gezegenler\n- Kabuk oluşumu\n- İç tüneller\n- İç yapılar (ruins, lab, temple, habitat)\n- Ore generation (kabukta)\n\n### ✅ Progress Tracking\n- BossBar gösterimi\n- %0'dan %100'e düzgün ilerleme\n- Her adım için mesaj\n\n### ✅ Gezegen Çeşitliliği\n- 28 farklı shape\n- Config'den ayarlanabilir ağırlıklar\n- Farklı biyomlar\n- Farklı paletler\n\n## 🔧 Build ve Test\n\n### Build Komutu:\n```bash\ncd c:\\Users\\Koraizen\\Desktop\\SkyOrbs\nmvn clean package\n```\n\n### Test Komutu:\n```\n/gezegen create test1\n```\n\n## ✅ Beklenen Sonuç\n\n1. Gezegen oluşumu başlar\n2. Progress bar %0'dan başlar\n3. Adım adım ilerler:\n   - %12: Gezegen kabuğu\n   - %25: Madenler\n   - %37: Ağaçlar\n   - %50: Yapılar\n   - %62: Hazineler\n   - %75: Zindanlar\n   - %100: Tamamlandı\n4. Oyuncu gezegen yüzeyine ışınlanır\n5. Gezegen tamamen oluşmuş olur\n\n## 🐛 Bilinen Sorunlar\n\n### Geçici Olarak Devre Dışı:\n- Asteroid generation (hata veriyordu)\n- Satellite generation (hata veriyordu)\n\nBu özellikler ileride düzeltilip eklenecek.\n\n## 📝 Notlar\n\n- İçi dolu gezegenler artık düzgün çalışıyor\n- Tüm özellikler (ore, tree, structure, treasure, dungeon) oluşuyor\n- Progress tracking düzgün çalışıyor\n- ItemStack hataları düzeltildi\n\n## 🎯 Sonraki Adımlar\n\n1. Plugini derleyin\n2. Sunucuya yükleyin\n3. Test edin\n4. Config'i ayarlayın\n5. Farklı şekillerde gezegenler oluşturun\n\n## 💡 İpuçları\n\n### Daha Fazla Çeşitlilik İçin:\n```yaml\ngeneration:\n  shapes:\n    weights:\n      SPHERE: 3.0\n      BLOB: 15.0\n      ORGANIC: 12.0\n      CRATERED: 10.0\n```\n\n### Daha Fazla Maden İçin:\n```yaml\nfeatures:\n  ores:\n    densityMultiplier: 2.0\n```\n\n### Daha Fazla Ağaç İçin:\n```yaml\nfeatures:\n  trees:\n    densityMultiplier: 3.0\n```\n\n## ✅ Test Checklist\n\n- [ ] İçi dolu gezegen oluşuyor\n- [ ] %100'e ulaşıyor\n- [ ] Madenler içinde\n- [ ] Ağaçlar yüzeyde\n- [ ] Yapılar var\n- [ ] Hazineler var\n- [ ] Zindanlar var\n- [ ] Hata mesajı yok\n- [ ] Farklı şekillerde gezegenler oluşuyor\n\nTüm bu checklistler ✅ olmalı!\n","size_bytes":3222},"src/main/java/com/skyorbs/generation/SatelliteGenerator.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class SatelliteGenerator {\n\n    private final SkyOrbs plugin;\n\n    public SatelliteGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public List<Orb> generateSatellitesForPlanet(Orb planet, World world) {\n        List<Orb> satellites = new ArrayList<Orb>();\n\n        if (!plugin.getConfigManager().isSatellitesEnabled()) {\n            return satellites;\n        }\n\n        Random random = new Random(planet.getSeed() + 54321);\n\n        if (random.nextDouble() > plugin.getConfigManager().getSatelliteProbability()) {\n            return satellites;\n        }\n\n        int minCount = plugin.getConfigManager().getMinSatellitesPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxSatellitesPerPlanet();\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            int radius = 30 + random.nextInt(41); // 30-70 radius\n\n            int safetyBuffer = 100;\n            int minDist = planet.getRadius() + radius + safetyBuffer;\n            int maxDist = planet.getRadius() + radius + safetyBuffer + 300;\n\n            double angle = random.nextDouble() * 2 * Math.PI;\n            int distance = minDist + random.nextInt(Math.max(1, maxDist - minDist));\n\n            int x = planet.getCenterX() + (int)(Math.cos(angle) * distance);\n            int z = planet.getCenterZ() + (int)(Math.sin(angle) * distance);\n            int y = planet.getCenterY() + random.nextInt(61) - 30;\n\n            BiomeType biome = BiomeType.getRandomBiomeWeighted(random);\n\n            // Select satellite shape based on biome\n            String shapeName = getSatelliteShapeForBiome(biome, random);\n\n            Orb satellite = new Orb(\n                UUID.randomUUID(),\n                planet.getName() + \"_Satellite_\" + (i + 1),\n                world.getName(),\n                x, y, z,\n                radius,\n                shapeName,\n                biome.name(),\n                planet.getSeed() + i + 5000,\n                System.currentTimeMillis(),\n                true,\n                planet.getId()\n            );\n\n            satellites.add(satellite);\n        }\n\n        return satellites;\n    }\n\n    /**\n     * Generate planetary rings around planets\n     */\n    public void generateRingsForPlanet(Orb planet, World world) {\n        Random random = new Random(planet.getSeed() + 99999);\n\n        // Configurable ring chance\n        double ringChance = plugin.getConfig().getDouble(\"satellites.ring_chance\", 0.2);\n        if (random.nextDouble() > ringChance) {\n            return;\n        }\n\n        int ringCount = 1 + random.nextInt(3); // 1-3 rings\n        int ringRadius = planet.getRadius() + 50 + random.nextInt(100); // 50-150 blocks from planet surface\n\n        for (int ring = 0; ring < ringCount; ring++) {\n            int ringY = planet.getCenterY() + random.nextInt(21) - 10; // ±10 blocks from center\n            int ringThickness = 2 + random.nextInt(4); // 2-5 blocks thick\n\n            // Generate ring particles/blocks\n            generateRingParticles(planet, world, ringRadius + ring * 20, ringY, ringThickness, random);\n        }\n    }\n\n    /**\n     * Generate ring visual effects\n     */\n    private void generateRingParticles(Orb planet, World world, int ringRadius, int ringY, int thickness, Random random) {\n        int cx = planet.getCenterX();\n        int cy = planet.getCenterY();\n        int cz = planet.getCenterZ();\n\n        // Create ring blocks for visual effect (sparse for performance)\n        int particleCount = Math.min(200, ringRadius * 4); // Limit particles for performance\n\n        for (int i = 0; i < particleCount; i++) {\n            double angle = random.nextDouble() * 2 * Math.PI;\n            double radiusVariation = ringRadius + random.nextInt(11) - 5; // ±5 variation\n\n            int x = cx + (int)(Math.cos(angle) * radiusVariation);\n            int z = cz + (int)(Math.sin(angle) * radiusVariation);\n            int y = ringY + random.nextInt(thickness * 2) - thickness;\n\n            // Only place if in air (don't overwrite planet blocks)\n            Block block = world.getBlockAt(x, y, z);\n            if (block.getType() == Material.AIR || block.getType() == Material.CAVE_AIR) {\n                // Choose ring material based on planet biome\n                Material ringMaterial = getRingMaterialForBiome(BiomeType.valueOf(planet.getBiomeName()), random);\n                block.setType(ringMaterial, false);\n            }\n        }\n    }\n\n    /**\n     * Get appropriate satellite shape for biome\n     */\n    private String getSatelliteShapeForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> \"DIAMOND\"; // Crystal satellites\n            case LAVA_OCEAN, MAGMA_CAVES -> \"SPHERE\"; // Smooth volcanic satellites\n            case VOID -> \"CUBE\"; // Geometric void satellites\n            case CORRUPTED -> \"SPIKY\"; // Spiky corrupted satellites\n            case FROZEN_TUNDRA, GLACIER -> \"OCTAHEDRON\"; // Geometric ice satellites\n            default -> random.nextBoolean() ? \"SPHERE\" : \"ASTEROID\";\n        };\n    }\n\n    /**\n     * Get ring material based on planet biome\n     */\n    private Material getRingMaterialForBiome(BiomeType biome, Random random) {\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> random.nextBoolean() ? Material.AMETHYST_BLOCK : Material.QUARTZ_BLOCK;\n            case LAVA_OCEAN, MAGMA_CAVES -> random.nextBoolean() ? Material.OBSIDIAN : Material.BLACKSTONE;\n            case VOID -> Material.END_STONE;\n            case CORRUPTED -> random.nextBoolean() ? Material.WARPED_NYLIUM : Material.CRIMSON_NYLIUM;\n            case FROZEN_TUNDRA, GLACIER -> random.nextBoolean() ? Material.PACKED_ICE : Material.BLUE_ICE;\n            case LUMINOUS -> random.nextBoolean() ? Material.SEA_LANTERN : Material.GLOWSTONE;\n            default -> random.nextBoolean() ? Material.STONE : Material.ANDESITE;\n        };\n    }\n}\n","size_bytes":6300},"src/main/java/com/skyorbs/shapes/impl/HourglassShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HourglassShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kum saati şekli - iki koni ters\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Hourglass - narrow in middle, wide at ends\n        double absY = Math.abs(y);\n        double radiusAtY = 0.3 + absY * 0.4; // Orta kısım dar, uçlar geniş\n\n        return Math.sqrt(x*x + z*z) <= radiusAtY;\n    }\n\n    @Override\n    public String getName() {\n        return \"HOURGLASS\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kum Saati\";\n    }\n}","size_bytes":1008},"src/main/java/com/skyorbs/shapes/impl/BirdShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class BirdShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kuş şekli - body, wings, head, tail\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Bird body - oval\n        if (Math.abs(y) <= 0.3 && Math.abs(z) <= 0.2) {\n            return Math.sqrt(x*x) <= 0.4;\n        }\n\n        // Wings (kanatlar)\n        if (Math.abs(z) > 0.2 && Math.abs(z) < 0.7 && Math.abs(y) <= 0.2) {\n            double wingShape = Math.exp(-Math.abs(z) * 2) * Math.exp(-x*x);\n            return wingShape > 0.1;\n        }\n\n        // Head (baş)\n        if (x > 0.3 && x < 0.6 && Math.abs(y) <= 0.2 && Math.abs(z) <= 0.15) {\n            return true;\n        }\n\n        // Tail (kuyruk)\n        if (x < -0.3 && Math.abs(y) <= 0.4 && Math.abs(z) <= 0.1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"BIRD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kuş\";\n    }\n}","size_bytes":1431},"src/main/java/com/skyorbs/shapes/impl/CrescentShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CrescentShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance > radius) {\n            return false;\n        }\n        \n        int offsetX = (int) (radius * 0.4);\n        double cutDistance = Math.sqrt((dx - offsetX) * (dx - offsetX) + dy * dy + dz * dz);\n        \n        return cutDistance >= radius * 0.7;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CRESCENT\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Hilal\";\n    }\n}\n","size_bytes":832},"src/main/java/com/skyorbs/shapes/impl/CrystalShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\n/**\n * CRYSTAL SHAPE - Kristal yapısı\n * Creates planets with crystalline facets\n */\npublic class CrystalShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Create crystalline facets\n        double ax = Math.abs(dx);\n        double ay = Math.abs(dy);\n        double az = Math.abs(dz);\n        \n        // Octahedral base with noise\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.1);\n        double facetDeform = 1 + noise * 0.2;\n        \n        int manhattan = (int)(ax + ay + az);\n        \n        return manhattan <= radius * facetDeform;\n    }\n\n    @Override\n    public String getName() { \n        return \"CRYSTAL\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.2; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Kristal\"; \n    }\n}\n","size_bytes":1023},"BUILD_INSTRUCTIONS.md":{"content":"# SkyOrbs 2.0.0 - Build ve Test Talimatları\n\n## 🔧 Düzeltilen Sorunlar\n\n### 1. ItemStack Amount Hatası (ÇÖZÜLDÜ ✅)\n**Sorun**: `amount must be greater than 0` hatası\n**Çözüm**: Tüm ItemStack oluşturma yerlerinde `Math.max(1, ...)` kullanıldı\n\n### 2. Config Detaylandırması (TAMAMLANDI ✅)\n**Sorun**: Config yeterince detaylı değildi\n**Çözüm**: \n- Her özellik config'den düzenlenebilir\n- Ore generation tam kontrol\n- Tree generation biyom bazlı ayarlar\n- Structure types detaylı ayarlar\n- Dungeon types tam kontrol\n- Treasure tiers ve loot tables\n- Atmosphere effects detaylı\n- 28 shape için ağırlıklar\n\n### 3. Gezegen Çeşitliliği (GELİŞTİRİLDİ ✅)\n**Sorun**: Sadece sphere gezegenler oluşuyordu\n**Çözüm**:\n- 28 farklı shape eklendi\n- Shape ağırlıkları config'de ayarlanabilir\n- Varsayılan olarak BLOB, HEMISPHERE, ORGANIC gibi çeşitli şekiller daha yüksek ağırlıkta\n\n## 📦 Build Komutu\n\n```bash\ncd c:\\Users\\Koraizen\\Desktop\\SkyOrbs\nmvn clean package\n```\n\n## 🎮 Test Adımları\n\n### Test 1: Gezegen Oluşturma\n```\n/gezegen create test1\n```\n**Beklenen**: \n- Hata vermeden tamamlanmalı\n- %100'e ulaşmalı\n- Farklı şekillerde gezegenler oluşmalı\n\n### Test 2: İçi Dolu Gezegen\n```\n/gezegen create solid_test\n```\n**Kontrol Et**:\n- Madenler içinde mi?\n- Ağaçlar yüzeyde mi?\n- Zindanlar içinde mi?\n- Yapılar var mı?\n\n### Test 3: İçi Boş Gezegen\nConfig'de hollow probability'yi 1.0 yap:\n```yaml\nmodifiers:\n  hollow:\n    probability: 1.0\n```\nSonra:\n```\n/gezegen create hollow_test\n```\n**Kontrol Et**:\n- Kabuk var mı?\n- İç tüneller var mı?\n- İç yapılar var mı?\n\n### Test 4: Farklı Şekiller\nBirkaç gezegen oluştur ve şekillerini kontrol et:\n```\n/gezegen create shape_test_1\n/gezegen create shape_test_2\n/gezegen create shape_test_3\n```\n**Beklenen**: Her biri farklı şekilde olmalı (BLOB, ORGANIC, CRATERED, vb.)\n\n## 🐛 Hata Ayıklama\n\n### Eğer hala ItemStack hatası alıyorsanız:\n1. Konsolu kontrol edin - hangi satırda hata veriyor?\n2. O dosyayı açın ve `new ItemStack(...)` satırlarını bulun\n3. `Math.max(1, ...)` eklenmiş mi kontrol edin\n\n### Eğer gezegenler hala sphere ise:\n1. Config'i kontrol edin - shape weights doğru mu?\n2. Config'i reload edin: `/gezegen reload`\n3. Yeni gezegen oluşturun\n\n### Eğer %87'de takılıyorsa:\n1. Konsol loglarını kontrol edin\n2. Hangi aşamada takıldığını görün\n3. O aşamanın kodunu kontrol edin\n\n## 📊 Config Örnekleri\n\n### Daha Fazla Çeşitlilik İçin:\n```yaml\ngeneration:\n  shapes:\n    weights:\n      SPHERE: 3.0        # Azaltıldı\n      BLOB: 15.0         # Artırıldı\n      ORGANIC: 12.0      # Artırıldı\n      CRATERED: 10.0     # Artırıldı\n      LAYERED: 10.0      # Artırıldı\n      WAVE: 10.0         # Artırıldı\n```\n\n### Daha Fazla Maden İçin:\n```yaml\nfeatures:\n  ores:\n    densityMultiplier: 2.0  # 2x daha fazla maden\n```\n\n### Daha Fazla Ağaç İçin:\n```yaml\nfeatures:\n  trees:\n    densityMultiplier: 3.0  # 3x daha fazla ağaç\n```\n\n## ✅ Başarı Kriterleri\n\n- [ ] Gezegen %100 oluşuyor\n- [ ] Hata mesajı yok\n- [ ] Madenler içinde spawn oluyor\n- [ ] Ağaçlar yüzeyde ve havada değil\n- [ ] Zindanlar içinde ve loot var\n- [ ] Farklı şekillerde gezegenler oluşuyor\n- [ ] İçi boş gezegenlerde tüneller var\n- [ ] Yapılar düzgün yerleşiyor\n\n## 🎯 Sonraki Adımlar\n\nEğer her şey çalışıyorsa:\n1. Config'i istediğiniz gibi ayarlayın\n2. Farklı biyomları test edin\n3. Farklı modifierleri test edin\n4. Oyuncularla test edin\n\n## 📝 Notlar\n\n- Her değişiklikten sonra `/gezegen reload` yapın\n- Test gezegenlerini `/gezegen delete <name>` ile silebilirsiniz\n- Debug modunu açmak için config'de `debug.enabled: true` yapın\n","size_bytes":3738},"DUZELTMELER.md":{"content":"# 🔧 SkyOrbs Plugin - Yapılan Düzeltmeler\n\n## 📌 Ana Sorunlar ve Çözümler\n\n### 1. Config Değişiklikleri Etki Etmiyordu ❌ → ✅\n\n**SORUN:**\n- Config dosyasında ne yazarsanız yazın gezegenler hep aynı şekilde oluşuyordu\n- Ore dağılımları değişmiyordu\n- Shape ağırlıkları çalışmıyordu\n\n**ÇÖZÜM:**\n- `GenerationManager.java` tamamen yeniden yazıldı\n- Ore generation sistemi artık config'den doğru okuyor:\n  - Her biyom için özel `features.ores.planetTypes.{biome_name}` bölümü\n  - Örnek: `lava_ocean` için `features.ores.planetTypes.lava_ocean`\n- Shape sistemi düzgün çalışıyor (28 farklı şekil)\n\n---\n\n### 2. Gezegenler Sadece Sphere Şeklinde Oluşuyordu ❌ → ✅\n\n**SORUN:**\n- Her gezegen yuvarlak (sphere) oluyordu\n- Diğer şekiller hiç çıkmıyordu\n\n**ÇÖZÜM:**\n- Shape weight sistemi doğru çalışıyor\n- Config'de 28 farklı şekil tanımlı:\n  ```yaml\n  SPHERE: 5.0\n  BLOB: 10.0        # Düzensiz - yüksek şans\n  ASTEROID: 7.0\n  CUBE: 4.0\n  PYRAMID: 4.0\n  ... ve 23 tane daha!\n  ```\n- Yüksek ağırlık = Daha sık görünür\n\n---\n\n### 3. İçi Dolu Gezegenlerde Ore Oluşmuyordu ❌ → ✅\n\n**SORUN:**\n- Solid (tam dolu) gezegenlerin içinde hiç ore oluşmuyordu\n- Sadece yüzeyde spawn oluyordu (o da düzgün değildi)\n\n**ÇÖZÜM:**\n- **ORE ENTEGRASYONU:** Oreler artık gezegen bloklarıyla birlikte oluşuyor!\n- `generateSolidPlanet()` içinde `tryGenerateOre()` metodu entegre edildi\n- Gezegen oluşurken her blok için ore şansı kontrol ediliyor\n- **Hollow planets:** Kabukta ore spawn desteği eklendi\n\n**Teknik Detay:**\n```java\n// Gezegen bloğu oluşturulurken\nMaterial material = palette.getMaterialByDepth(depth, random);\n\n// ORE KONTROLÜ - Aynı anda!\nMaterial oreMaterial = tryGenerateOre(x, y, z, distance, radius, biome, random);\nif (oreMaterial != null) {\n    material = oreMaterial; // Bloğu ore ile değiştir\n}\n\nblocks.add(new BlockPlacement(x, y, z, material));\n```\n\n---\n\n### 4. Biyoma Özel Ore Profilleri Yoktu ❌ → ✅\n\n**SORUN:**\n- Nether benzeri gezegenlerde diamond çıkıyordu\n- Kristal gezegenlerde coal çıkıyordu\n- Ölü gezegenlerde hala ore vardı\n\n**ÇÖZÜM:**\nConfig'e **16+ biyom** için özel ore profilleri eklendi:\n\n#### Dünya Benzeri (Forest, Plains, etc.)\n```yaml\nforest:\n  ores:\n    coal: { chance: 0.35, minVein: 3, maxVein: 8 }\n    iron: { chance: 0.30, minVein: 2, maxVein: 6 }\n    gold: { chance: 0.12, minVein: 2, maxVein: 5 }\n    diamond: { chance: 0.04, minVein: 1, maxVein: 4 }\n    emerald: { chance: 0.02, minVein: 1, maxVein: 2 }\n```\n**Sonuç:** TÜM oreler dengeli dağılım\n\n#### Nether Benzeri (Lava Ocean, Magma Caves)\n```yaml\nlava_ocean:\n  ores:\n    ancient_debris: { chance: 0.05, minVein: 1, maxVein: 3 }\n    gold: { chance: 0.15, minVein: 2, maxVein: 5 }\n    nether_quartz: { chance: 0.20, minVein: 3, maxVein: 7 }\n```\n**Sonuç:** SADECE ancient debris, gold, nether quartz (çok düşük)\n\n#### Kristalize (Crystal Forest, Crystalline)\n```yaml\ncrystal_forest:\n  ores:\n    emerald: { chance: 0.25, minVein: 2, maxVein: 5 }\n    diamond: { chance: 0.08, minVein: 1, maxVein: 3 }\n    coal: { chance: 0.30, minVein: 3, maxVein: 8 }\n    amethyst: { chance: 0.40, minVein: 3, maxVein: 10 }\n```\n**Sonuç:** Çok emerald, az diamond, çok coal, çok amethyst\n\n#### Ölü Gezegen (Void, Corrupted)\n```yaml\nvoid:\n  enabled: false      # ORE OLUŞUMU KAPALI!\n  densityMultiplier: 0.0\n  ores: {}            # Boş liste\n```\n**Sonuç:** HİÇ ORE ÇIKMAZ!\n\n#### Donmuş (Frozen Tundra, Glacier)\n```yaml\nfrozen_tundra:\n  ores:\n    diamond: { chance: 0.12, minVein: 2, maxVein: 5 }\n    lapis: { chance: 0.20, minVein: 3, maxVein: 8 }\n    iron: { chance: 0.25, minVein: 2, maxVein: 6 }\n```\n**Sonuç:** Diamond ve lapis ağırlıklı\n\n#### Çöl (Desert, Badlands)\n```yaml\nbadlands:\n  ores:\n    gold: { chance: 0.35, minVein: 4, maxVein: 9 }\n    copper: { chance: 0.35, minVein: 4, maxVein: 11 }\n    iron: { chance: 0.25, minVein: 3, maxVein: 7 }\n```\n**Sonuç:** Çok gold ve copper\n\n#### Zehirli (Toxic Swamp, Toxic)\n```yaml\ntoxic_swamp:\n  ores:\n    slime: { chance: 0.40, minVein: 2, maxVein: 6 }\n    glowstone: { chance: 0.25, minVein: 2, maxVein: 5 }\n    copper: { chance: 0.20, minVein: 2, maxVein: 5 }\n```\n**Sonuç:** Slime ve glowstone ağırlıklı\n\n---\n\n## 🎯 Config Yapısı (Yeni)\n\n### Ore Sisteminin Yapısı\n```yaml\nfeatures:\n  ores:\n    enabled: true\n    densityMultiplier: 1.5          # GENEL çarpan\n    hollowPlanetSpawn: true          # İçi boş gezegenlerde kabukta spawn\n\n    planetTypes:                     # HER BİYOM İÇİN AYRI PROFIL!\n      forest:                        # Biyom adı (küçük harf)\n        enabled: true                # Bu biyomda ore var mı?\n        densityMultiplier: 1.0       # Bu biyom için özel çarpan\n        ores:                        # Bu biyomda çıkacak oreler\n          coal:\n            enabled: true            # Bu ore aktif mi?\n            chance: 0.35             # Spawn şansı (0.0-1.0)\n            minVein: 3               # Minimum damar boyutu\n            maxVein: 8               # Maximum damar boyutu\n          iron:\n            enabled: true\n            chance: 0.30\n            minVein: 2\n            maxVein: 6\n          # ... diğer oreler\n\n      lava_ocean:                    # BAŞKA BİYOM\n        enabled: true\n        densityMultiplier: 0.8       # Daha az ore\n        ores:\n          ancient_debris:\n            enabled: true\n            chance: 0.05             # ÇOK NADİR!\n            minVein: 1\n            maxVein: 3\n          # Sadece bu ore tanımlı = sadece bu çıkar!\n\n      void:                          # ÖLÜ GEZEGEN\n        enabled: false               # ORE SİSTEMİ KAPALI!\n        densityMultiplier: 0.0\n        ores: {}                     # BOŞ!\n```\n\n---\n\n## 🔍 Nasıl Test Edilir?\n\n### Test 1: Farklı Biyomlarda Ore Kontrolü\n\n1. **Forest gezegeni oluştur:**\n   ```\n   /gezegen create forest MyForestPlanet\n   ```\n   - Kazdığında: Coal, iron, gold, diamond, emerald çıkmalı\n\n2. **Lava Ocean gezegeni oluştur:**\n   ```\n   /gezegen create lava_ocean MyLavaPlanet\n   ```\n   - Kazdığında: SADECE ancient debris, gold, nether quartz çıkmalı\n   - Diamond, iron, coal vs. çıkmamalı!\n\n3. **Crystal Forest gezegeni oluştur:**\n   ```\n   /gezegen create crystal_forest MyCrystalPlanet\n   ```\n   - Kazdığında: ÇOK emerald, az diamond, çok coal, çok amethyst\n   - Gold, redstone vs. çıkmamalı!\n\n4. **Void gezegeni oluştur:**\n   ```\n   /gezegen create void MyDeadPlanet\n   ```\n   - Kazdığında: HİÇBİR ORE ÇIKMAMALI!\n\n---\n\n### Test 2: Gezegen Şekli Çeşitliliği\n\n10 gezegen oluştur ve şekillerine bak:\n```\n/gezegen create\n/gezegen create\n/gezegen create\n... (10 kez)\n```\n\n**Beklenen:**\n- En az 5-6 farklı şekil görmelisin\n- Hepsi sphere ise config yüklenmemiş demektir!\n\n**Olası Şekiller:**\n- BLOB (düzensiz)\n- ASTEROID\n- CUBE\n- PYRAMID\n- HEMISPHERE\n- TORUS\n- ... ve 22 tane daha!\n\n---\n\n### Test 3: Config Değişikliği\n\n1. `config.yml` aç\n2. `forest` biyomundaki `diamond` chance'ini değiştir:\n   ```yaml\n   diamond:\n     enabled: true\n     chance: 0.99    # %99 şans (neredeyse her blok diamond!)\n     minVein: 10\n     maxVein: 50\n   ```\n3. Kaydet ve reload et:\n   ```\n   /gezegen reload\n   ```\n4. Yeni forest gezegeni oluştur\n5. Kaz\n\n**Beklenen:** Her kazıdığında TON diamond çıkmalı!\n\n---\n\n### Test 4: Ölü Gezegen\n\n1. `config.yml` aç\n2. `forest` için ore sistemini kapat:\n   ```yaml\n   forest:\n     enabled: false      # KAPALI!\n     densityMultiplier: 0.0\n     ores: {}\n   ```\n3. Reload ve yeni forest gezegeni oluştur\n4. Kaz\n\n**Beklenen:** Hiçbir ore çıkmamalı!\n\n---\n\n## 📊 Chance (Şans) Sistemi Nasıl Çalışır?\n\n```yaml\nchance: 0.35        # 0.0 - 1.0 arası\n```\n\n- `0.01` = %1 şans → 1000 blokta 10 ore\n- `0.05` = %5 şans → 1000 blokta 50 ore\n- `0.10` = %10 şans → 1000 blokta 100 ore\n- `0.25` = %25 şans → 1000 blokta 250 ore\n- `0.35` = %35 şans → 1000 blokta 350 ore (varsayılan coal)\n- `0.50` = %50 şans → Yarı yarıya!\n- `0.99` = %99 şans → Neredeyse her blok ore!\n\n### Density Multiplier (Çarpan)\n\n```yaml\ndensityMultiplier: 2.0    # TÜM şansları 2x artırır\n```\n\n**Örnek Hesaplama:**\n```yaml\ncoal:\n  chance: 0.30\ndensityMultiplier: 2.0\n```\nGerçek chance: `0.30 × 2.0 = 0.60` (%60!)\n\n**Örnek 2:**\n```yaml\ndiamond:\n  chance: 0.04    # %4\ndensityMultiplier: 5.0\n```\nGerçek chance: `0.04 × 5.0 = 0.20` (%20!)\n\n---\n\n## 🛠️ Dosya Değişiklikleri\n\n### 1. `config.yml`\n- ✅ `planetTypes` bölümü eklendi (16+ biyom)\n- ✅ Her biyom için özel ore profilleri\n- ✅ `enabled: false` ile ore kapatma desteği\n\n### 2. `GenerationManager.java`\n- ✅ `tryGenerateOre()` metodu tamamen yeniden yazıldı\n- ✅ Biyom adından config okuma düzeltildi\n- ✅ `generateSolidPlanet()` içine ore entegrasyonu\n- ✅ `generateHollowPlanet()` içine kabuk ore desteği\n\n### 3. `ConfigManager.java`\n- ✅ `getOreConfigForPlanetType()` metodu düzeltildi\n- ✅ Biome name'den doğru path oluşturuyor\n- ✅ `features.ores.planetTypes.{biome_name}` yapısı\n\n---\n\n## 🎉 Sonuç\n\n**ÖNCEKİ DURUM:**\n❌ Config değişiklikleri etki etmiyordu\n❌ Gezegenler hep sphere şeklindeydi\n❌ Solid gezegenlerde ore oluşmuyordu\n❌ Her biyomda aynı ore dağılımı\n\n**ŞİMDİKİ DURUM:**\n✅ Config tamamen fonksiyonel\n✅ 28 farklı gezegen şekli\n✅ Solid ve hollow gezegenlerde ore oluşuyor\n✅ Her biyom kendi ore profiline sahip\n✅ Ölü gezegenler yapılabiliyor (hiç ore yok)\n✅ Config'den her şey düzenlenebilir\n\n**Test Komutu:**\n```\n/gezegen reload\n```\n\n**Artık yapabileceklerin:**\n- Nether gezegenleri (sadece nether ores)\n- Kristal gezegenleri (sadece gems)\n- Ölü gezegenler (hiç ore yok)\n- Ultra zengin gezegenler (densityMultiplier: 10.0)\n- Sadece diamond gezegeni (diğer oreler disabled)\n- Ve daha fazlası... Her şey senin elinde!\n\n🚀 İyi gezegenler!\n","size_bytes":9932},"src/main/java/com/skyorbs/shapes/impl/ConeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ConeShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        int height = radius;\n        \n        if (dy < -height || dy > height) {\n            return false;\n        }\n        \n        double factor = 1.0 - (Math.abs(dy) / (double) height);\n        return distance <= radius * factor;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CONE\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Koni\";\n    }\n}\n","size_bytes":770},"src/main/java/com/skyorbs/shapes/impl/BootShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class BootShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Bot şekli - sole, shaft, heel\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Boot shaft (üst kısım)\n        if (y > 0.0) {\n            return Math.abs(x) <= 0.3 && Math.abs(z) <= 0.2;\n        }\n\n        // Boot body (orta kısım)\n        if (y > -0.4 && y <= 0.0) {\n            double bodyWidth = 0.4 - y * 0.2; // Aşağıda genişler\n            return Math.abs(x) <= bodyWidth && Math.abs(z) <= 0.25;\n        }\n\n        // Boot sole (taban)\n        if (y <= -0.4) {\n            return Math.abs(x) <= 0.5 && Math.abs(z) <= 0.3;\n        }\n\n        // Heel (topuk)\n        if (x < -0.2 && y < -0.2 && Math.abs(z) <= 0.2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"BOOT\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Bot\";\n    }\n}","size_bytes":1389},"src/main/java/com/skyorbs/shapes/impl/SwordShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SwordShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kılıç şekli - kabza, crossguard, blade\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)dz;\n\n        // Sword parts\n        if (y < -0.6) {\n            // Handle (kabza) - kalın\n            return Math.abs(x) <= 0.15 && Math.abs(z) <= 0.15;\n        } else if (y < -0.4) {\n            // Crossguard (koruyucu) - geniş\n            return Math.abs(x) <= 0.4 && Math.abs(z) <= 0.1;\n        } else {\n            // Blade (kılıç ağzı) - uzun ve ince\n            double bladeWidth = 0.1 - (y + 0.4) * 0.05; // Uçta daha ince\n            return Math.abs(x) <= bladeWidth && Math.abs(z) <= 0.05;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"SWORD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kılıç\";\n    }\n}","size_bytes":1297},"src/main/java/com/skyorbs/listeners/GUIClickListener.java":{"content":"package com.skyorbs.listeners;\n\nimport com.skyorbs.SkyOrbs;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.inventory.InventoryClickEvent;\n\npublic class GUIClickListener implements Listener {\n\n    private final SkyOrbs plugin;\n\n    public GUIClickListener(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    @EventHandler\n    public void onInventoryClick(InventoryClickEvent event) {\n        String title = event.getView().getTitle();\n\n        if (title.contains(\"Admin Konfigürasyon\")) {\n            event.setCancelled(true); // Cancel item movement\n\n            if (event.getCurrentItem() == null) return;\n\n            // Handle clicks here\n            String itemName = event.getCurrentItem().getItemMeta().getDisplayName();\n\n            if (itemName.contains(\"Konfigürasyonu Yenile\")) {\n                plugin.reloadPluginConfig();\n                event.getWhoClicked().sendMessage(\"§aKonfigürasyon yenilendi!\");\n                event.getWhoClicked().closeInventory();\n            }\n            // ... diğer butonlar için handler'lar ekle\n        }\n    }\n}","size_bytes":1121},"PROFESSIONAL_IMPROVEMENTS.md":{"content":"# 🚀 SkyOrbs - Professional Improvement Plan\n\n## 📊 Current Status Analysis\n\n### ✅ Strengths (Güçlü Yönler)\n1. **Modular Architecture** - İyi organize edilmiş paket yapısı\n2. **Async Generation** - Performans için async işlemler\n3. **Config System** - Detaylı konfigürasyon\n4. **28 Shapes** - Çeşitli gezegen şekilleri\n5. **Biome System** - 30+ biyom tipi\n6. **Atmosphere Effects** - Atmosfer efektleri\n7. **Turkish Support** - Türkçe dil desteği\n\n### ⚠️ Areas for Improvement (İyileştirme Alanları)\n\n---\n\n## 🎯 Priority 1: Critical Improvements (Kritik İyileştirmeler)\n\n### 1. **Performance Optimization** ⚡\n**Problem**: Büyük gezegenler lag yaratabilir\n**Solution**:\n```java\n// Chunk-based generation with progressive loading\n// Memory pooling for block placements\n// Adaptive batch sizing based on TPS\n// Spatial indexing for faster lookups\n```\n\n**Implementation**:\n- [ ] Implement chunk-based generation queue\n- [ ] Add memory pool for BlockPlacement objects\n- [ ] Dynamic batch size adjustment (TPS < 18 → reduce batch size)\n- [ ] Octree spatial indexing for collision detection\n\n### 2. **Error Handling & Validation** 🛡️\n**Problem**: Bazı hata durumları handle edilmiyor\n**Solution**:\n```java\n// Comprehensive try-catch blocks\n// Input validation\n// Graceful degradation\n// Error recovery mechanisms\n```\n\n**Implementation**:\n- [ ] Add validation layer for all user inputs\n- [ ] Implement circuit breaker pattern for generation failures\n- [ ] Add retry logic with exponential backoff\n- [ ] Create error recovery system (rollback failed generations)\n\n### 3. **Database Optimization** 💾\n**Problem**: Her işlemde database I/O\n**Solution**:\n```java\n// Connection pooling\n// Batch operations\n// Caching layer\n// Prepared statements\n```\n\n**Implementation**:\n- [ ] Implement HikariCP connection pool\n- [ ] Add Redis/Caffeine cache layer\n- [ ] Batch insert/update operations\n- [ ] Use prepared statements everywhere\n\n---\n\n## 🎯 Priority 2: Feature Enhancements (Özellik Geliştirmeleri)\n\n### 4. **Advanced Planet Physics** 🌍\n**Current**: Static planets\n**Improvement**: Dynamic features\n\n```java\n// Planetary rotation (visual)\n// Orbital mechanics for satellites\n// Tidal effects\n// Gravitational zones\n// Weather systems\n```\n\n**Implementation**:\n- [ ] Add rotation metadata to Orb\n- [ ] Implement orbital path calculation\n- [ ] Create gravity zone system (low/high gravity areas)\n- [ ] Add weather events (storms, meteor showers)\n\n### 5. **Ecosystem & Life** 🌱\n**Current**: Basic trees and structures\n**Improvement**: Living worlds\n\n```java\n// Mob spawning system (custom mobs per biome)\n// Flora growth over time\n// Fauna migration patterns\n// Resource regeneration\n// Day/night cycles affecting planet\n```\n\n**Implementation**:\n- [ ] Custom mob spawner system\n- [ ] Scheduled flora growth tasks\n- [ ] Biome-specific mob types\n- [ ] Resource respawn system\n\n### 6. **Economy Integration** 💰\n**Current**: No economy\n**Improvement**: Planet economy\n\n```java\n// Planet ownership costs\n// Resource trading\n// Planet upgrades\n// Rental system\n// Tax system\n```\n\n**Implementation**:\n- [ ] Vault integration for economy\n- [ ] Planet shop GUI\n- [ ] Upgrade system (increase radius, add features)\n- [ ] Rental/lease system for planets\n\n### 7. **Advanced GUI System** 🖥️\n**Current**: Basic command interface\n**Improvement**: Rich GUI experience\n\n```java\n// Planet browser GUI (paginated)\n// Planet editor GUI\n// Statistics dashboard\n// Map view (top-down planet view)\n// Teleport hub GUI\n```\n\n**Implementation**:\n- [ ] Create PlanetBrowserGUI with pagination\n- [ ] Add PlanetEditorGUI for owners\n- [ ] Statistics GUI with charts\n- [ ] Mini-map system for planets\n\n---\n\n## 🎯 Priority 3: Professional Features (Profesyonel Özellikler)\n\n### 8. **API for Developers** 🔌\n**Current**: No public API\n**Improvement**: Developer-friendly API\n\n```java\n// Event system (PlanetCreateEvent, PlanetDeleteEvent, etc.)\n// Public API for third-party plugins\n// Webhook support\n// REST API (optional)\n```\n\n**Implementation**:\n```java\n// Example API usage:\npublic class SkyOrbsAPI {\n    // Create planet programmatically\n    public CompletableFuture<Orb> createPlanet(PlanetBuilder builder);\n    \n    // Get planet at location\n    public Optional<Orb> getPlanetAt(Location location);\n    \n    // Register custom shape\n    public void registerShape(PlanetShape shape);\n    \n    // Register custom biome\n    public void registerBiome(BiomeType biome);\n}\n\n// Events\npublic class PlanetCreateEvent extends Event implements Cancellable {\n    private final Player player;\n    private final Orb orb;\n    private boolean cancelled = false;\n    // ...\n}\n```\n\n### 9. **Multi-World Support** 🌐\n**Current**: Single world\n**Improvement**: Multiple worlds\n\n```java\n// Per-world configuration\n// World-specific planet types\n// Cross-world teleportation\n// World groups\n```\n\n**Implementation**:\n- [ ] Add world-specific configs\n- [ ] World manager system\n- [ ] Cross-world teleport with permissions\n- [ ] World group system (survival, creative, etc.)\n\n### 10. **Backup & Restore System** 💾\n**Current**: No backup\n**Improvement**: Automatic backups\n\n```java\n// Automatic planet backups\n// Restore from backup\n// Export/import planets\n// Schematic support\n```\n\n**Implementation**:\n- [ ] Scheduled backup system\n- [ ] Backup compression (ZIP)\n- [ ] Restore command with preview\n- [ ] WorldEdit schematic export/import\n\n### 11. **Analytics & Metrics** 📊\n**Current**: Basic logging\n**Improvement**: Comprehensive analytics\n\n```java\n// Player statistics\n// Planet statistics\n// Performance metrics\n// Usage patterns\n// Heat maps\n```\n\n**Implementation**:\n```java\npublic class AnalyticsManager {\n    // Track planet visits\n    public void trackVisit(Player player, Orb orb);\n    \n    // Track generation time\n    public void trackGenerationTime(Orb orb, long milliseconds);\n    \n    // Track resource usage\n    public void trackResourceUsage();\n    \n    // Generate reports\n    public Report generateReport(ReportType type, TimeRange range);\n}\n```\n\n### 12. **Permission System** 🔐\n**Current**: Basic permissions\n**Improvement**: Granular permissions\n\n```java\n// skyorbs.create.basic\n// skyorbs.create.advanced\n// skyorbs.create.size.<radius>\n// skyorbs.create.shape.<shape>\n// skyorbs.create.biome.<biome>\n// skyorbs.planet.edit.own\n// skyorbs.planet.edit.others\n// skyorbs.planet.delete.own\n// skyorbs.planet.delete.others\n// skyorbs.admin.*\n```\n\n### 13. **Localization System** 🌍\n**Current**: Turkish only\n**Improvement**: Multi-language\n\n```java\n// messages_en.yml\n// messages_tr.yml\n// messages_de.yml\n// messages_es.yml\n// Auto-detect player language\n```\n\n**Implementation**:\n- [ ] Create MessageManager\n- [ ] Add language files\n- [ ] Player language preference storage\n- [ ] Placeholder support\n\n---\n\n## 🎯 Priority 4: Advanced Features (Gelişmiş Özellikler)\n\n### 14. **Planet Challenges & Quests** 🎮\n**New Feature**: Gamification\n\n```java\n// Daily challenges\n// Achievement system\n// Quest chains\n// Leaderboards\n// Rewards\n```\n\n**Implementation**:\n```java\npublic class ChallengeSystem {\n    // \"Mine 100 ores on a lava planet\"\n    // \"Discover 5 different biomes\"\n    // \"Create a planet with rings\"\n    // \"Find a legendary treasure\"\n}\n```\n\n### 15. **Planet Wars / PvP** ⚔️\n**New Feature**: Competitive gameplay\n\n```java\n// Planet claiming\n// Territory control\n// Resource wars\n// Faction support\n// Siege mechanics\n```\n\n### 16. **Procedural Missions** 🎯\n**New Feature**: Dynamic content\n\n```java\n// Rescue missions\n// Exploration missions\n// Mining missions\n// Combat missions\n// Building missions\n```\n\n### 17. **Planet Evolution** 🌱\n**New Feature**: Living planets\n\n```java\n// Planets change over time\n// Biome transitions\n// Geological events\n// Civilization development\n// Ruins become more ruined over time\n```\n\n### 18. **Advanced Atmosphere** 🌤️\n**Current**: Basic effects\n**Improvement**: Complex atmosphere\n\n```java\n// Weather patterns\n// Cloud layers\n// Aurora borealis\n// Meteor showers\n// Solar flares\n// Eclipse events\n```\n\n### 19. **Space Stations** 🛰️\n**New Feature**: Orbital structures\n\n```java\n// Build space stations\n// Docking bays\n// Trade hubs\n// Research facilities\n// Defense platforms\n```\n\n### 20. **Wormholes & Portals** 🌀\n**New Feature**: Fast travel\n\n```java\n// Create wormholes between planets\n// Portal networks\n// Unstable portals (random destination)\n// Portal maintenance costs\n```\n\n---\n\n## 🏗️ Architecture Improvements\n\n### 21. **Design Patterns** 🎨\n\n```java\n// 1. Factory Pattern for planet creation\npublic interface PlanetFactory {\n    Orb createPlanet(PlanetType type, PlanetConfig config);\n}\n\n// 2. Builder Pattern for complex objects\npublic class OrbBuilder {\n    public OrbBuilder withRadius(int radius);\n    public OrbBuilder withBiome(BiomeType biome);\n    public OrbBuilder withShape(PlanetShape shape);\n    public Orb build();\n}\n\n// 3. Strategy Pattern for generation algorithms\npublic interface GenerationStrategy {\n    List<BlockPlacement> generate(GenerationContext context);\n}\n\n// 4. Observer Pattern for events\npublic interface PlanetObserver {\n    void onPlanetCreated(Orb orb);\n    void onPlanetDeleted(Orb orb);\n    void onPlanetModified(Orb orb);\n}\n\n// 5. Command Pattern for undo/redo\npublic interface Command {\n    void execute();\n    void undo();\n}\n```\n\n### 22. **Dependency Injection** 💉\n\n```java\n// Use Guice or manual DI\npublic class SkyOrbs extends JavaPlugin {\n    private Injector injector;\n    \n    @Override\n    public void onEnable() {\n        injector = Guice.createInjector(new SkyOrbsModule(this));\n        // All managers injected automatically\n    }\n}\n```\n\n### 23. **Testing Infrastructure** 🧪\n\n```java\n// Unit tests\n@Test\npublic void testOreGeneration() {\n    // Mock world, orb\n    // Verify ore count, distribution\n}\n\n// Integration tests\n@Test\npublic void testFullPlanetGeneration() {\n    // Create planet\n    // Verify all features present\n}\n\n// Performance tests\n@Test\npublic void testGenerationPerformance() {\n    // Measure generation time\n    // Assert < 5 seconds for radius 50\n}\n```\n\n---\n\n## 📈 Performance Benchmarks\n\n### Target Metrics:\n- **Generation Time**: < 5 seconds for radius 50 planet\n- **Memory Usage**: < 500MB for 10 active generations\n- **TPS Impact**: < 2 TPS drop during generation\n- **Database Query**: < 50ms average\n- **Cache Hit Rate**: > 80%\n\n### Monitoring:\n```java\npublic class PerformanceMonitor {\n    // Track all operations\n    public void recordOperation(String operation, long duration);\n    \n    // Generate performance report\n    public PerformanceReport getReport();\n    \n    // Alert on performance issues\n    public void checkThresholds();\n}\n```\n\n---\n\n## 🔒 Security Improvements\n\n### 1. **Input Validation**\n```java\n// Validate all user inputs\n// Prevent SQL injection\n// Prevent command injection\n// Rate limiting\n```\n\n### 2. **Permission Checks**\n```java\n// Check permissions before every action\n// Audit log for admin actions\n// IP-based rate limiting\n```\n\n### 3. **Data Encryption**\n```java\n// Encrypt sensitive data in database\n// Secure API keys\n// Hash player data\n```\n\n---\n\n## 📚 Documentation\n\n### 1. **Code Documentation**\n- [ ] JavaDoc for all public methods\n- [ ] Inline comments for complex logic\n- [ ] Architecture diagrams\n- [ ] API documentation\n\n### 2. **User Documentation**\n- [ ] Installation guide\n- [ ] Configuration guide\n- [ ] Command reference\n- [ ] FAQ\n- [ ] Troubleshooting guide\n\n### 3. **Developer Documentation**\n- [ ] API reference\n- [ ] Plugin integration guide\n- [ ] Custom shape creation guide\n- [ ] Custom biome creation guide\n\n---\n\n## 🎨 Code Quality\n\n### 1. **Code Style**\n- [ ] Consistent naming conventions\n- [ ] Proper indentation\n- [ ] Remove unused imports\n- [ ] Remove commented code\n- [ ] Add missing @Override annotations\n\n### 2. **Code Smells**\n- [ ] Remove duplicate code\n- [ ] Reduce method complexity\n- [ ] Reduce class size\n- [ ] Improve variable names\n- [ ] Remove magic numbers\n\n### 3. **Best Practices**\n- [ ] Use Optional instead of null\n- [ ] Use try-with-resources\n- [ ] Use streams where appropriate\n- [ ] Immutable objects where possible\n- [ ] Thread-safe collections\n\n---\n\n## 🚀 Deployment\n\n### 1. **CI/CD Pipeline**\n```yaml\n# GitHub Actions\nname: Build and Test\non: [push, pull_request]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Set up JDK 17\n        uses: actions/setup-java@v2\n      - name: Build with Maven\n        run: mvn clean package\n      - name: Run tests\n        run: mvn test\n      - name: Upload artifact\n        uses: actions/upload-artifact@v2\n```\n\n### 2. **Versioning**\n- Semantic versioning (MAJOR.MINOR.PATCH)\n- Changelog for each release\n- Migration guides for breaking changes\n\n### 3. **Distribution**\n- SpigotMC\n- Bukkit\n- GitHub Releases\n- Auto-updater (optional)\n\n---\n\n## 📊 Metrics & KPIs\n\n### Success Metrics:\n1. **Performance**: 95% of planets generate in < 5 seconds\n2. **Stability**: 99.9% uptime\n3. **User Satisfaction**: 4.5+ star rating\n4. **Adoption**: 1000+ downloads\n5. **Community**: Active Discord/Forum\n\n---\n\n## 🎯 Implementation Roadmap\n\n### Phase 1: Foundation (Week 1-2)\n- [ ] Performance optimization\n- [ ] Error handling\n- [ ] Database optimization\n- [ ] Testing infrastructure\n\n### Phase 2: Features (Week 3-4)\n- [ ] Advanced GUI\n- [ ] Economy integration\n- [ ] API development\n- [ ] Multi-world support\n\n### Phase 3: Polish (Week 5-6)\n- [ ] Localization\n- [ ] Documentation\n- [ ] Code quality improvements\n- [ ] Security hardening\n\n### Phase 4: Advanced (Week 7-8)\n- [ ] Planet physics\n- [ ] Ecosystem\n- [ ] Challenges & quests\n- [ ] Analytics\n\n### Phase 5: Release (Week 9-10)\n- [ ] Beta testing\n- [ ] Bug fixes\n- [ ] Performance tuning\n- [ ] Public release\n\n---\n\n## 💡 Innovation Ideas\n\n### 1. **AI-Generated Content**\n- Use AI to generate unique planet descriptions\n- AI-generated quest narratives\n- Procedural lore generation\n\n### 2. **VR Support**\n- ViveCraft compatibility\n- Immersive planet exploration\n\n### 3. **Cross-Server Planets**\n- Share planets across servers\n- Planet marketplace\n- Community planet library\n\n### 4. **Mobile Companion App**\n- View planets on mobile\n- Manage planets remotely\n- Receive notifications\n\n### 5. **Blockchain Integration** (Optional)\n- NFT planets\n- Cryptocurrency rewards\n- Decentralized planet registry\n\n---\n\n## 🎓 Learning Resources\n\n### For Contributors:\n1. **Bukkit/Spigot API**: https://hub.spigotmc.org/javadocs/spigot/\n2. **Design Patterns**: https://refactoring.guru/design-patterns\n3. **Clean Code**: \"Clean Code\" by Robert C. Martin\n4. **Performance**: \"Java Performance\" by Scott Oaks\n\n---\n\n## 📞 Support & Community\n\n### 1. **Discord Server**\n- Support channel\n- Development updates\n- Community showcase\n- Bug reports\n\n### 2. **GitHub**\n- Issue tracker\n- Feature requests\n- Pull requests\n- Discussions\n\n### 3. **Documentation Site**\n- Wiki\n- Tutorials\n- API docs\n- Video guides\n\n---\n\n## 🏆 Conclusion\n\nSkyOrbs has a **solid foundation** but can become a **world-class plugin** with these improvements:\n\n### Priority Order:\n1. ✅ **Performance & Stability** (Critical)\n2. ✅ **Error Handling** (Critical)\n3. ✅ **Database Optimization** (Critical)\n4. 🎯 **GUI System** (High value)\n5. 🎯 **API Development** (High value)\n6. 🎯 **Economy Integration** (High value)\n7. 🌟 **Advanced Features** (Nice to have)\n\n### Estimated Timeline:\n- **Minimum Viable Product**: 2 weeks\n- **Feature Complete**: 6 weeks\n- **Production Ready**: 10 weeks\n\n### Resources Needed:\n- 1-2 developers\n- 5-10 beta testers\n- Documentation writer (optional)\n- Community manager (optional)\n\n---\n\n**Current Status**: ⭐⭐⭐ (Good)\n**Potential Status**: ⭐⭐⭐⭐⭐ (Excellent)\n\nWith these improvements, SkyOrbs can become the **#1 planet generation plugin** for Minecraft!\n","size_bytes":15901},"src/main/java/com/skyorbs/shapes/impl/SpiralShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\n/**\n * SPIRAL SHAPE - Spiral gezegen\n * Creates planets with spiral patterns\n */\npublic class SpiralShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (distance > radius) return false;\n        \n        // Create spiral pattern\n        double angle = Math.atan2(dz, dx);\n        double spiralFactor = Math.sin(angle * 4 + dy * 0.3) * 0.2;\n        \n        return distance <= radius * (1 + spiralFactor);\n    }\n\n    @Override\n    public String getName() { \n        return \"SPIRAL\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.2; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Spiral\"; \n    }\n}\n","size_bytes":895},"src/main/java/com/skyorbs/shapes/impl/CometShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CometShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double headDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        if (headDistance <= radius * 0.6) {\n            return true;\n        }\n        \n        if (dx > 0) {\n            double tailLength = radius * 2;\n            double tailWidth = radius * 0.3 * (1 - dx / tailLength);\n            \n            if (dx <= tailLength) {\n                double crossDist = Math.sqrt(dy * dy + dz * dz);\n                return crossDist <= tailWidth;\n            }\n        }\n        \n        return false;\n    }\n    \n    @Override\n    public String getName() {\n        return \"COMET\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Kuyruklu Yıldız\";\n    }\n}\n","size_bytes":1013},"src/main/java/com/skyorbs/shapes/impl/WaveShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\n/**\n * WAVE SHAPE - Dalgalı gezegen\n * Creates planets with wave-like surface patterns\n */\npublic class WaveShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Create wave pattern\n        double wave1 = Math.sin(dx * 0.2) * Math.cos(dz * 0.2);\n        double wave2 = Math.sin(dy * 0.15 + dx * 0.1);\n        double waveDeform = 1 + (wave1 + wave2) * 0.15;\n        \n        return distance <= radius * waveDeform;\n    }\n\n    @Override\n    public String getName() { \n        return \"WAVE\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.15; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Dalgalı\"; \n    }\n}\n","size_bytes":905},"src/main/java/com/skyorbs/config/ConfigManager.java":{"content":"package com.skyorbs.config;\n\nimport com.skyorbs.SkyOrbs;\nimport org.bukkit.configuration.ConfigurationSection;\n\nimport java.util.*;\n\npublic class ConfigManager {\n    \n    private final SkyOrbs plugin;\n    \n    public ConfigManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    // ============================================\n    // GEZEGEN BOYUT AYARLARI\n    // ============================================\n    \n    public int getMinRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.minRadius\", 80);\n    }\n    \n    public int getMaxRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.maxRadius\", 250);\n    }\n    \n    public int getAverageRadius() {\n        return plugin.getConfig().getInt(\"generation.planetSize.averageRadius\", 150);\n    }\n    \n    // ============================================\n    // YERLEŞTİRME AYARLARI\n    // ============================================\n    \n    public int getMaxDistance() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.maxDistance\", 50000);\n    }\n    \n    public int getCenterX() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.centerX\", 0);\n    }\n    \n    public int getCenterZ() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.centerZ\", 0);\n    }\n    \n    public int getMinDistanceFromSpawn() {\n        return plugin.getConfig().getInt(\"placement.worldBounds.minDistanceFromSpawn\", 1000);\n    }\n    \n    public boolean isClusteringEnabled() {\n        return plugin.getConfig().getBoolean(\"placement.clustering.enabled\", true);\n    }\n    \n    public int getClusterMinDistance() {\n        return plugin.getConfig().getInt(\"placement.clustering.clusterMinDistance\", 800);\n    }\n    \n    public int getClusterMaxDistance() {\n        return plugin.getConfig().getInt(\"placement.clustering.clusterMaxDistance\", 2000);\n    }\n    \n    public double getCenterAttraction() {\n        return plugin.getConfig().getDouble(\"placement.attractToCenter.centerAttraction\", 0.3);\n    }\n    \n    // ============================================\n    // ŞEKİL AĞIRLIKLARI - CACHE'LENMİŞ\n    // ============================================\n\n    private Map<String, Double> shapeWeightsCache = null;\n\n    public Map<String, Double> getShapeWeights() {\n        if (shapeWeightsCache != null) {\n            return new HashMap<String, Double>(shapeWeightsCache); // Defensive copy\n        }\n\n        Map<String, Double> weights = new HashMap<String, Double>();\n\n        // DOĞRU PATH: generation.shapes.weights\n        ConfigurationSection section = plugin.getConfig().getConfigurationSection(\"generation.shapes.weights\");\n\n        if (section != null) {\n            for (String key : section.getKeys(false)) {\n                double weight = section.getDouble(key);\n                weights.put(key.toUpperCase(), weight); // Uppercase'e çevir\n                plugin.logDebug(\"shapes\", \"Loaded shape: \" + key + \" = \" + weight);\n            }\n        }\n\n        // Config boşsa defaults kullan\n        if (weights.isEmpty()) {\n            plugin.logWarning(\"No shape weights found in config! Using defaults.\");\n            weights = getDefaultShapeWeights();\n        }\n\n        shapeWeightsCache = weights;\n        plugin.logInfo(\"Loaded \" + weights.size() + \" shape weights from config\");\n        return new HashMap<String, Double>(weights);\n    }\n\n    /**\n     * Default shape weights\n     */\n    private Map<String, Double> getDefaultShapeWeights() {\n        Map<String, Double> defaults = new HashMap<String, Double>();\n        defaults.put(\"SPHERE\", 5.0);\n        defaults.put(\"HEMISPHERE\", 8.0);\n        defaults.put(\"BLOB\", 10.0);\n        defaults.put(\"ELLIPSOID\", 8.0);\n        defaults.put(\"ASTEROID\", 7.0);\n        defaults.put(\"TORUS\", 4.0);\n        defaults.put(\"RING\", 3.0);\n        defaults.put(\"CYLINDER\", 5.0);\n        defaults.put(\"CONE\", 6.0);\n        defaults.put(\"DIAMOND\", 5.0);\n        defaults.put(\"CUBE\", 4.0);\n        defaults.put(\"PYRAMID\", 4.0);\n        defaults.put(\"OCTAHEDRON\", 3.0);\n        defaults.put(\"FRACTAL\", 6.0);\n        defaults.put(\"SPIKY\", 5.0);\n        defaults.put(\"COMET\", 3.0);\n        defaults.put(\"CRESCENT\", 4.0);\n        defaults.put(\"HYBRID\", 2.0);\n        defaults.put(\"LAYERED\", 7.0);\n        defaults.put(\"CRATERED\", 8.0);\n        defaults.put(\"HONEYCOMB\", 5.0);\n        defaults.put(\"SPIRAL\", 6.0);\n        defaults.put(\"WAVE\", 7.0);\n        defaults.put(\"CRYSTAL\", 6.0);\n        defaults.put(\"ORGANIC\", 8.0);\n        defaults.put(\"GEOMETRIC\", 5.0);\n        defaults.put(\"NEBULA\", 4.0);\n        defaults.put(\"ASTEROID_FIELD\", 6.0);\n        return defaults;\n    }\n\n    /**\n     * Cache'leri temizle (reload için)\n     */\n    public void clearCaches() {\n        shapeWeightsCache = null;\n        plugin.logDebug(\"config\", \"Cleared all config caches\");\n    }\n    \n    // ============================================\n    // ASTEROID AYARLARI\n    // ============================================\n    \n    public boolean isAsteroidsEnabled() {\n        return plugin.getConfig().getBoolean(\"asteroids.enabled\", true);\n    }\n    \n    public int getMinAsteroidsPerPlanet() {\n        return plugin.getConfig().getInt(\"asteroids.perPlanet.minCount\", 1);\n    }\n    \n    public int getMaxAsteroidsPerPlanet() {\n        return plugin.getConfig().getInt(\"asteroids.perPlanet.maxCount\", 5);\n    }\n    \n    public int getMinAsteroidRadius() {\n        return plugin.getConfig().getInt(\"asteroids.size.minRadius\", 20);\n    }\n    \n    public int getMaxAsteroidRadius() {\n        return plugin.getConfig().getInt(\"asteroids.size.maxRadius\", 50);\n    }\n    \n    public int getMinAsteroidDistance() {\n        return plugin.getConfig().getInt(\"asteroids.placement.minDistanceFromPlanet\", 300);\n    }\n    \n    public int getMaxAsteroidDistance() {\n        return plugin.getConfig().getInt(\"asteroids.placement.maxDistanceFromPlanet\", 800);\n    }\n    \n    // ============================================\n    // UYDU AYARLARI\n    // ============================================\n    \n    public boolean isSatellitesEnabled() {\n        return plugin.getConfig().getBoolean(\"satellites.enabled\", true);\n    }\n    \n    public int getMinSatellitesPerPlanet() {\n        return plugin.getConfig().getInt(\"satellites.perPlanet.minCount\", 0);\n    }\n    \n    public int getMaxSatellitesPerPlanet() {\n        return plugin.getConfig().getInt(\"satellites.perPlanet.maxCount\", 3);\n    }\n    \n    public double getSatelliteProbability() {\n        return plugin.getConfig().getDouble(\"satellites.perPlanet.probability\", 0.6);\n    }\n    \n    // ============================================\n    // PERFORMANS AYARLARI\n    // ============================================\n    \n    public boolean isAsyncGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"performance.asyncGeneration\", true);\n    }\n    \n    public int getThreadPoolCoreSize() {\n        return plugin.getConfig().getInt(\"performance.threadPool.coreSize\", 4);\n    }\n    \n    public int getThreadPoolMaxSize() {\n        return plugin.getConfig().getInt(\"performance.threadPool.maxSize\", 8);\n    }\n    \n    public int getBlocksPerBatch() {\n        return plugin.getConfig().getInt(\"performance.batching.blocksPerBatch\", 250);\n    }\n    \n    public int getBatchesPerTick() {\n        return plugin.getConfig().getInt(\"performance.batching.batchesPerTick\", 1);\n    }\n    \n    public int getShellThickness() {\n        return plugin.getConfig().getInt(\"performance.generation.shellThickness\", 7);\n    }\n    \n    public boolean isChunkPreloadEnabled() {\n        return plugin.getConfig().getBoolean(\"performance.generation.chunkPreload\", true);\n    }\n    \n    // ============================================\n    // ORE SİSTEMİ AYARLARI\n    // ============================================\n\n    public boolean isOreGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.enabled\", true);\n    }\n\n    public double getOreMultiplier() {\n        return plugin.getConfig().getDouble(\"features.ores.densityMultiplier\", 1.0);\n    }\n\n    public boolean isDeepslateEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.deepslateVariants\", true);\n    }\n\n    public boolean areBiomeBonusesEnabled() {\n        return plugin.getConfig().getBoolean(\"features.ores.biomeBonuses\", true);\n    }\n\n    // ============================================\n    // PLANET TYPE ORE CONFIGURATIONS\n    // ============================================\n\n    /**\n     * Get ore configurations for a specific planet type\n     */\n    public Map<String, Object> getOreConfigForPlanetType(String planetType) {\n        String path = \"features.ores.planetTypes.\" + planetType.toLowerCase();\n        ConfigurationSection section = plugin.getConfig().getConfigurationSection(path);\n\n        if (section == null) {\n            // Return default config\n            return getDefaultOreConfig();\n        }\n\n        Map<String, Object> config = new HashMap<String, Object>();\n        config.put(\"enabled\", section.getBoolean(\"enabled\", true));\n        config.put(\"densityMultiplier\", section.getDouble(\"densityMultiplier\", 1.0));\n\n        // Ore-specific configs\n        ConfigurationSection oresSection = section.getConfigurationSection(\"ores\");\n        if (oresSection != null) {\n            Map<String, Map<String, Object>> ores = new HashMap<String, Map<String, Object>>();\n            for (String oreKey : oresSection.getKeys(false)) {\n                ConfigurationSection oreSection = oresSection.getConfigurationSection(oreKey);\n                if (oreSection != null) {\n                    Map<String, Object> oreConfig = new HashMap<String, Object>();\n                    oreConfig.put(\"chance\", oreSection.getDouble(\"chance\", 0.0));\n                    oreConfig.put(\"minVein\", oreSection.getInt(\"minVein\", 1));\n                    oreConfig.put(\"maxVein\", oreSection.getInt(\"maxVein\", 1));\n                    oreConfig.put(\"enabled\", oreSection.getBoolean(\"enabled\", true));\n                    ores.put(oreKey.toUpperCase(), oreConfig);\n                }\n            }\n            config.put(\"ores\", ores);\n        }\n\n        return config;\n    }\n\n    /**\n     * Get default ore configuration\n     */\n    private Map<String, Object> getDefaultOreConfig() {\n        Map<String, Object> config = new HashMap<String, Object>();\n        config.put(\"enabled\", true);\n        config.put(\"densityMultiplier\", 1.0);\n        return config;\n    }\n\n    /**\n     * Set ore configuration for a planet type (real-time)\n     */\n    public void setOreConfigForPlanetType(String planetType, String oreType, String property, Object value) {\n        String path = \"features.ores.planetTypes.\" + planetType.toLowerCase() + \".ores.\" + oreType.toLowerCase() + \".\" + property;\n        plugin.getConfig().set(path, value);\n        plugin.saveConfig();\n        plugin.logInfo(\"Updated ore config: \" + path + \" = \" + value);\n    }\n\n    /**\n     * Set planet type ore density multiplier\n     */\n    public void setPlanetTypeOreMultiplier(String planetType, double multiplier) {\n        String path = \"features.ores.planetTypes.\" + planetType.toLowerCase() + \".densityMultiplier\";\n        plugin.getConfig().set(path, multiplier);\n        plugin.saveConfig();\n        plugin.logInfo(\"Updated \" + planetType + \" ore density multiplier to \" + multiplier);\n    }\n\n    /**\n     * Enable/disable ore generation for planet type\n     */\n    public void setPlanetTypeOreEnabled(String planetType, boolean enabled) {\n        String path = \"features.ores.planetTypes.\" + planetType.toLowerCase() + \".enabled\";\n        plugin.getConfig().set(path, enabled);\n        plugin.saveConfig();\n        plugin.logInfo(\"Set \" + planetType + \" ore generation to \" + (enabled ? \"enabled\" : \"disabled\"));\n    }\n\n    /**\n     * Get all configured planet types\n     */\n    public Set<String> getConfiguredPlanetTypes() {\n        ConfigurationSection section = plugin.getConfig().getConfigurationSection(\"features.ores.planetTypes\");\n        return section != null ? section.getKeys(false) : new HashSet<String>();\n    }\n    \n    // ============================================\n    // AĞAÇ SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isTreeGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.trees.enabled\", true);\n    }\n    \n    public double getTreeDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.trees.densityMultiplier\", 1.0);\n    }\n    \n    public boolean areTreeSpecialFeaturesEnabled() {\n        return plugin.getConfig().getBoolean(\"features.trees.specialFeatures\", true);\n    }\n    \n    // ============================================\n    // YAPI SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isStructureGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.structures.enabled\", true);\n    }\n    \n    public double getStructureDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.structures.densityMultiplier\", 1.0);\n    }\n    \n    public boolean areStructureChestsEnabled() {\n        return plugin.getConfig().getBoolean(\"features.structures.includeChests\", true);\n    }\n    \n    // ============================================\n    // HAZİNE SİSTEMİ AYARLARI\n    // ============================================\n    \n    public boolean isTreasureGenerationEnabled() {\n        return plugin.getConfig().getBoolean(\"features.treasures.enabled\", true);\n    }\n    \n    public double getTreasureDensityMultiplier() {\n        return plugin.getConfig().getDouble(\"features.treasures.densityMultiplier\", 1.0);\n    }\n    \n    public double getLegendaryChanceMultiplier() {\n        return plugin.getConfig().getDouble(\"features.treasures.legendaryChanceMultiplier\", 1.0);\n    }\n    \n    public boolean areBiomeSpecificTreasuresEnabled() {\n        return plugin.getConfig().getBoolean(\"features.treasures.biomeSpecific\", true);\n    }\n    \n    // ============================================\n    // DEBUG AYARLARI\n    // ============================================\n    \n    public boolean isDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.enabled\", false);\n    }\n    \n    public boolean isOreDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.enabled\", false);\n    }\n    \n    public boolean showOreCoordinates() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.showCoordinates\", true);\n    }\n    \n    public boolean showVeinSize() {\n        return plugin.getConfig().getBoolean(\"debug.oreGeneration.showVeinSize\", true);\n    }\n    \n    public boolean isTreeDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.treeGeneration.enabled\", false);\n    }\n    \n    public boolean isStructureDebugEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.structureGeneration.enabled\", false);\n    }\n    \n    public boolean isPerformanceMonitorEnabled() {\n        return plugin.getConfig().getBoolean(\"debug.performanceMonitor.enabled\", false);\n    }\n    \n    public int getPerformanceLogInterval() {\n        return plugin.getConfig().getInt(\"debug.performanceMonitor.logInterval\", 100);\n    }\n    \n    // ============================================\n    // LİMİT AYARLARI\n    // ============================================\n    \n    public int getPlanetsPerPlayer() {\n        return plugin.getConfig().getInt(\"limits.planetsPerPlayer\", 2);\n    }\n    \n    public boolean canDeleteOwnPlanet() {\n        return plugin.getConfig().getBoolean(\"limits.deleteOwnPlanet\", false);\n    }\n    \n    public int getMaxPlanetsPerWorld() {\n        return plugin.getConfig().getInt(\"limits.maxPlanetsPerWorld\", 100);\n    }\n    \n    public long getGenerationCooldown() {\n        return plugin.getConfig().getLong(\"limits.generationCooldown\", 300);\n    }\n    \n    // ============================================\n    // DÜNYA YÖNETİMİ\n    // ============================================\n    \n    public boolean isAutoSaveEnabled() {\n        return plugin.getConfig().getBoolean(\"worldManagement.autoSave.enabled\", true);\n    }\n    \n    public int getAutoSaveInterval() {\n        return plugin.getConfig().getInt(\"worldManagement.autoSave.interval\", 600);\n    }\n    \n    public boolean isChunkUnloadOptimization() {\n        return plugin.getConfig().getBoolean(\"worldManagement.chunkUnload.enabled\", true);\n    }\n    \n    public int getChunkUnloadDelay() {\n        return plugin.getConfig().getInt(\"worldManagement.chunkUnload.delay\", 200);\n    }\n    \n    // ============================================\n    // ENTEGRASYONLAR\n    // ============================================\n    \n    public boolean isVaultEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.vault.enabled\", false);\n    }\n    \n    public double getPlanetCreationCost() {\n        return plugin.getConfig().getDouble(\"integrations.vault.planetCreationCost\", 1000.0);\n    }\n    \n    public boolean isWorldGuardEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.worldguard.enabled\", false);\n    }\n    \n    public boolean isPlaceholderAPIEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.placeholderapi.enabled\", false);\n    }\n    \n    public boolean isDynmapEnabled() {\n        return plugin.getConfig().getBoolean(\"integrations.dynmap.enabled\", false);\n    }\n    \n    public boolean showPlanetsOnDynmap() {\n        return plugin.getConfig().getBoolean(\"integrations.dynmap.showPlanets\", true);\n    }\n    \n    // ============================================\n    // RASTGELE İSİM OLUŞTURMA\n    // ============================================\n    \n    public String generateRandomName() {\n        List<String> prefixes = plugin.getConfig().getStringList(\"planetNames.prefixes\");\n        List<String> suffixes = plugin.getConfig().getStringList(\"planetNames.suffixes\");\n        List<String> postfixes = plugin.getConfig().getStringList(\"planetNames.postfixes\");\n        List<String> formats = plugin.getConfig().getStringList(\"planetNames.formats\");\n        \n        if (prefixes.isEmpty() || suffixes.isEmpty() || formats.isEmpty()) {\n            return \"Gezegen-\" + UUID.randomUUID().toString().substring(0, 8);\n        }\n        \n        Random random = new Random();\n        String prefix = prefixes.get(random.nextInt(prefixes.size()));\n        String suffix = suffixes.get(random.nextInt(suffixes.size()));\n        String format = formats.get(random.nextInt(formats.size()));\n        \n        String name = format.replace(\"{prefix}\", prefix).replace(\"{suffix}\", suffix);\n        \n        if (name.contains(\"{postfix}\") && !postfixes.isEmpty()) {\n            String postfix = postfixes.get(random.nextInt(postfixes.size()));\n            name = name.replace(\"{postfix}\", postfix);\n        }\n        \n        if (name.contains(\"{number}\")) {\n            int min = plugin.getConfig().getInt(\"planetNames.numberRange.min\", 1);\n            int max = plugin.getConfig().getInt(\"planetNames.numberRange.max\", 999);\n            int number = min + random.nextInt(max - min + 1);\n            name = name.replace(\"{number}\", String.valueOf(number));\n        }\n        \n        return name;\n    }\n    \n    // ============================================\n    // MESAJ SİSTEMİ\n    // ============================================\n    \n    public String getMessage(String key) {\n        String prefix = plugin.getConfig().getString(\"messages.prefix\", \"&8[&bGezegen&8]&r\");\n        String message = plugin.getConfig().getString(\"messages.\" + key, key);\n        return colorize(prefix + \" \" + message);\n    }\n    \n    public String getMessageRaw(String key) {\n        return colorize(plugin.getConfig().getString(\"messages.\" + key, key));\n    }\n    \n    private String colorize(String text) {\n        return text.replace(\"&\", \"§\");\n    }\n    \n    // ============================================\n    // YARDIMCI METODLAR\n    // ============================================\n    \n    /**\n     * Debug mesajı gönder\n     */\n    public void sendDebugMessage(String category, String message) {\n        if (!isDebugEnabled()) return;\n        \n        boolean categoryEnabled = switch (category.toLowerCase()) {\n            case \"ore\" -> isOreDebugEnabled();\n            case \"tree\" -> isTreeDebugEnabled();\n            case \"structure\" -> isStructureDebugEnabled();\n            case \"performance\" -> isPerformanceMonitorEnabled();\n            default -> false;\n        };\n        \n        if (categoryEnabled) {\n            plugin.logInfo(\"[DEBUG:\" + category.toUpperCase() + \"] \" + message);\n        }\n    }\n    \n    /**\n     * Tüm feature'ları kontrol et\n     */\n    public boolean areAllFeaturesEnabled() {\n        return isOreGenerationEnabled() && \n               isTreeGenerationEnabled() && \n               isStructureGenerationEnabled() && \n               isTreasureGenerationEnabled();\n    }\n    \n    /**\n     * Config'i validate et\n     */\n    public void validateConfig() {\n        if (getMinRadius() >= getMaxRadius()) {\n            plugin.logWarning(\"minRadius >= maxRadius! Varsayılan değerler kullanılıyor.\");\n        }\n        \n        if (getBlocksPerBatch() > 1000) {\n            plugin.logWarning(\"blocksPerBatch çok yüksek! Performans sorunları olabilir.\");\n        }\n        \n        if (getThreadPoolCoreSize() > 16) {\n            plugin.logWarning(\"threadPoolCoreSize çok yüksek! CPU kullanımı artabilir.\");\n        }\n        \n        if (getShellThickness() < 3 || getShellThickness() > 15) {\n            plugin.logWarning(\"shellThickness ideal değerlerin dışında (3-15).\");\n        }\n    }\n}","size_bytes":21701},"src/main/java/com/skyorbs/shapes/impl/SurfboardShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SurfboardShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Sörf tahtası şekli - board, nose, tail, fins\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main board (ana tahta)\n        if (Math.abs(y) <= 0.03) {\n            // Wider at nose, narrower at tail\n            double width = 0.25 - Math.abs(x) * 0.1;\n            return Math.abs(z) <= width && Math.abs(x) <= 0.7;\n        }\n\n        // Board rails (kenarlar) - slightly raised\n        if (Math.abs(y) <= 0.05) {\n            double width = 0.25 - Math.abs(x) * 0.1;\n            return Math.abs(z) <= width && Math.abs(x) <= 0.7;\n        }\n\n        // Nose rocker (burun eğimi)\n        if (x > 0.5) {\n            double noseHeight = (x - 0.5) * 0.1;\n            if (Math.abs(y) <= noseHeight + 0.03) {\n                return Math.abs(z) <= 0.2;\n            }\n        }\n\n        // Tail (kuyruk)\n        if (x < -0.5) {\n            double tailHeight = (-x - 0.5) * 0.08;\n            if (Math.abs(y) <= tailHeight + 0.03) {\n                return Math.abs(z) <= 0.15;\n            }\n        }\n\n        // Fins (yüzgeçler)\n        if (x < -0.4 && Math.abs(y + 0.05) <= 0.08) {\n            if (Math.abs(z) <= 0.03) return true; // Center fin\n            if (Math.abs(z - 0.08) <= 0.02) return true; // Side fins\n            if (Math.abs(z + 0.08) <= 0.02) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SURFBOARD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Sörf Tahtası\";\n    }\n}","size_bytes":2024},"src/main/java/com/skyorbs/generation/BiomeBlender.java":{"content":"package com.skyorbs.generation;\n\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.util.noise.SimplexOctaveGenerator;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class BiomeBlender {\n\n    /**\n     * Implement soft biome blending algorithm\n     */\n    public List<AdvancedWorldGen.BlockPlacement> blendBiomes(Orb orb, PlanetType primaryType, List<PlanetType> secondaryTypes) {\n        List<AdvancedWorldGen.BlockPlacement> blendedBlocks = new ArrayList<>();\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n        long seed = orb.getSeed();\n\n        // Create noise generators for blending\n        SimplexOctaveGenerator blendNoise = new SimplexOctaveGenerator(seed + 1000, 6);\n        blendNoise.setScale(0.005);\n\n        SimplexOctaveGenerator detailBlend = new SimplexOctaveGenerator(seed + 2000, 4);\n        detailBlend.setScale(0.02);\n\n        // Generate blended terrain\n        for (int x = -radius; x <= radius; x++) {\n            for (int z = -radius; z <= radius; z++) {\n                double distance = Math.sqrt(x * x + z * z);\n                if (distance > radius) continue;\n\n                // Calculate blend factors\n                double blendValue = blendNoise.noise(x, z, 0.5);\n                double detailValue = detailBlend.noise(x, z, 0.5);\n\n                // Determine which biomes to blend at this location\n                BiomeBlend blend = calculateBiomeBlend(primaryType, secondaryTypes, blendValue, detailValue, distance, radius);\n\n                // Generate terrain with blended materials\n                int height = calculateBlendedHeight(orb, x, z, blend, seed);\n                for (int y = -radius; y <= height; y++) {\n                    double verticalDistance = Math.sqrt(x * x + y * y + z * z);\n                    if (verticalDistance <= radius) {\n                        Material material = getBlendedMaterial(blend, y, height, seed + x * 31 + z * 37 + y);\n                        blendedBlocks.add(new AdvancedWorldGen.BlockPlacement(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        return blendedBlocks;\n    }\n\n    private BiomeBlend calculateBiomeBlend(PlanetType primary, List<PlanetType> secondary, double blendValue, double detailValue, double distance, int radius) {\n        // Calculate blend weights based on noise and distance\n        double distanceFactor = distance / radius; // 0 at center, 1 at edge\n\n        // Primary biome weight (stronger at center)\n        double primaryWeight = Math.max(0.3, 1.0 - distanceFactor * 0.7);\n\n        // Secondary biome weights based on noise\n        List<Double> secondaryWeights = new ArrayList<>();\n        double remainingWeight = 1.0 - primaryWeight;\n\n        if (!secondary.isEmpty()) {\n            double totalSecondaryWeight = 0;\n            for (int i = 0; i < secondary.size(); i++) {\n                double weight = Math.abs(blendValue + detailValue * 0.5) * (1.0 / secondary.size());\n                weight = Math.max(0.1, Math.min(0.4, weight));\n                secondaryWeights.add(weight);\n                totalSecondaryWeight += weight;\n            }\n\n            // Normalize secondary weights\n            if (totalSecondaryWeight > 0) {\n                for (int i = 0; i < secondaryWeights.size(); i++) {\n                    secondaryWeights.set(i, secondaryWeights.get(i) / totalSecondaryWeight * remainingWeight);\n                }\n            }\n        }\n\n        return new BiomeBlend(primary, secondary, primaryWeight, secondaryWeights);\n    }\n\n    private int calculateBlendedHeight(Orb orb, int x, int z, BiomeBlend blend, long seed) {\n        // Calculate height based on blended biome characteristics\n        double height = 0;\n        double totalWeight = blend.primaryWeight;\n\n        // Primary biome contribution\n        height += getBiomeBaseHeight(blend.primary) * blend.primaryWeight;\n\n        // Secondary biome contributions\n        for (int i = 0; i < blend.secondaryTypes.size(); i++) {\n            PlanetType secondary = blend.secondaryTypes.get(i);\n            double weight = blend.secondaryWeights.get(i);\n            height += getBiomeBaseHeight(secondary) * weight;\n            totalWeight += weight;\n        }\n\n        // Add noise variation\n        SimplexOctaveGenerator heightNoise = new SimplexOctaveGenerator(seed, 4);\n        heightNoise.setScale(0.01);\n        double noiseVariation = heightNoise.noise(x, z, 0.5) * 10;\n\n        return (int) Math.max(-orb.getRadius(), Math.min(orb.getRadius(), height + noiseVariation));\n    }\n\n    private double getBiomeBaseHeight(PlanetType type) {\n        return switch (type) {\n            case TERRESTRIAL -> 20.0;\n            case GAS -> 15.0;\n            case LAVA -> 25.0;\n            case ICE -> 18.0;\n            case CRYSTAL -> 22.0;\n            case SHADOW -> 12.0;\n            case TOXIC -> 16.0;\n        };\n    }\n\n    private Material getBlendedMaterial(BiomeBlend blend, int y, int surfaceHeight, long seed) {\n        Random random = new Random(seed);\n\n        // Determine material based on depth and blended biome properties\n        boolean isSurface = y == surfaceHeight;\n        boolean isNearSurface = y > surfaceHeight - 3;\n\n        // Calculate which biome's material to use\n        double rand = random.nextDouble();\n        double cumulativeWeight = blend.primaryWeight;\n\n        if (rand <= cumulativeWeight) {\n            // Use primary biome material\n            return getBiomeMaterial(blend.primary, y, surfaceHeight, isSurface, isNearSurface, random);\n        }\n\n        // Check secondary biomes\n        for (int i = 0; i < blend.secondaryTypes.size(); i++) {\n            cumulativeWeight += blend.secondaryWeights.get(i);\n            if (rand <= cumulativeWeight) {\n                return getBiomeMaterial(blend.secondaryTypes.get(i), y, surfaceHeight, isSurface, isNearSurface, random);\n            }\n        }\n\n        // Fallback to primary\n        return getBiomeMaterial(blend.primary, y, surfaceHeight, isSurface, isNearSurface, random);\n    }\n\n    private Material getBiomeMaterial(PlanetType type, int y, int surfaceHeight, boolean isSurface, boolean isNearSurface, Random random) {\n        switch (type) {\n            case TERRESTRIAL -> {\n                if (isSurface) return random.nextDouble() < 0.7 ? Material.GRASS_BLOCK : Material.DIRT;\n                if (isNearSurface) return Material.DIRT;\n                return Material.STONE;\n            }\n            case GAS -> {\n                double layer = (double) y / surfaceHeight;\n                if (layer > 0.8) return Material.BLUE_WOOL;\n                else if (layer > 0.6) return Material.LIGHT_BLUE_WOOL;\n                else if (layer > 0.4) return Material.CYAN_WOOL;\n                else return Material.BLUE_WOOL;\n            }\n            case LAVA -> {\n                if (isSurface || isNearSurface) return Material.MAGMA_BLOCK;\n                return Material.NETHERRACK;\n            }\n            case ICE -> {\n                if (isSurface) return Material.SNOW_BLOCK;\n                if (isNearSurface) return Material.ICE;\n                return Material.PACKED_ICE;\n            }\n            case CRYSTAL -> {\n                if (random.nextDouble() < 0.3) return Material.AMETHYST_BLOCK;\n                return Material.QUARTZ_BLOCK;\n            }\n            case SHADOW -> {\n                return Material.BLACK_CONCRETE;\n            }\n            case TOXIC -> {\n                if (isSurface) return Material.SLIME_BLOCK;\n                return Material.GREEN_CONCRETE;\n            }\n            default -> {\n                return Material.STONE;\n            }\n        }\n    }\n\n    private static class BiomeBlend {\n        final PlanetType primary;\n        final List<PlanetType> secondaryTypes;\n        final double primaryWeight;\n        final List<Double> secondaryWeights;\n\n        BiomeBlend(PlanetType primary, List<PlanetType> secondaryTypes, double primaryWeight, List<Double> secondaryWeights) {\n            this.primary = primary;\n            this.secondaryTypes = secondaryTypes;\n            this.primaryWeight = primaryWeight;\n            this.secondaryWeights = secondaryWeights;\n        }\n    }\n}","size_bytes":8375},"src/main/java/com/skyorbs/shapes/impl/FishShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class FishShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Balık şekli - body, tail, fins\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Fish body - oval shape\n        double bodyRadius = Math.sqrt(x*x + y*y);\n        if (bodyRadius <= 0.4 && Math.abs(z) <= 0.2) {\n            return true;\n        }\n\n        // Tail (kuyruk)\n        if (x < -0.3) {\n            double tailWidth = 0.5 + (x + 0.3) * 2; // Kuyrukta daralır\n            return Math.abs(y) <= tailWidth && Math.abs(z) <= 0.1;\n        }\n\n        // Dorsal fin (sırt yüzgeci)\n        if (Math.abs(x) <= 0.2 && y > 0.2 && y < 0.5) {\n            return Math.abs(z) <= 0.05;\n        }\n\n        // Pectoral fins (göğüs yüzgeçleri)\n        if (Math.abs(y) <= 0.1 && Math.abs(z) <= 0.3 && x > -0.1 && x < 0.2) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"FISH\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Balık\";\n    }\n}","size_bytes":1482},"src/main/java/com/skyorbs/shapes/impl/LayeredShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\n/**\n * LAYERED SHAPE - Katmanlı gezegen\n * Creates planets with visible layers like sedimentary rock\n */\npublic class LayeredShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Create layers with noise\n        double layerNoise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.05);\n        int layerIndex = (int)((distance / radius) * 5); // 5 layers\n        \n        // Add variation to layer boundaries\n        double layerVariation = 1.0 + layerNoise * 0.2;\n        \n        return distance <= radius * layerVariation;\n    }\n\n    @Override\n    public String getName() { \n        return \"LAYERED\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.2; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Katmanlı\"; \n    }\n}\n","size_bytes":1056},"src/main/java/com/skyorbs/shapes/impl/MoonShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.SkyOrbs;\n\npublic class MoonShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Ay şekli - kraterli yüzey (CONFIG KONTROLLÜ)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // CONFIG'DEN ALGORİTMA AYARLARINI OKU\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        int craterCount = plugin.getConfig().getInt(\"generation.shapes.algorithmTweaks.moon.craterCount\", 8);\n        double craterDepth = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.moon.craterDepth\", 0.3);\n        double surfaceVariation = plugin.getConfig().getDouble(\"generation.shapes.algorithmTweaks.moon.surfaceVariation\", 0.2);\n        boolean flatTop = plugin.getConfig().getBoolean(\"generation.shapes.algorithmTweaks.moon.flatTop\", true);\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Temel küre şekli\n        double sphereRadius = Math.sqrt(x * x + y * y + z * z);\n\n        // Krater etkisi - config kontrollü krater sayısı\n        double craterEffect = 0.0;\n        for (int i = 0; i < craterCount; i++) {\n            double craterX = Math.sin(seed * 0.1 + i) * 0.7;\n            double craterZ = Math.cos(seed * 0.1 + i) * 0.7;\n            double craterDist = Math.sqrt((x - craterX) * (x - craterX) + (z - craterZ) * (z - craterZ));\n            if (craterDist < 0.3) {\n                craterEffect = Math.max(craterEffect, craterDepth * (1.0 - craterDist / 0.3));\n            }\n        }\n\n        // Ay yüzeyi - config kontrollü düzleştirme\n        if (flatTop && y > surfaceVariation) {\n            return sphereRadius <= 1.0 - craterEffect;\n        } else {\n            return sphereRadius <= 1.0;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"MOON\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Ay\";\n    }\n}","size_bytes":2228},"src/main/java/com/skyorbs/ecosystem/BiosphereManager.java":{"content":"package com.skyorbs.ecosystem;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class BiosphereManager {\n\n    private final SkyOrbs plugin;\n    private final Map<UUID, BiosphereData> biosphereData = new HashMap<>();\n\n    public BiosphereManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startBiosphereUpdater();\n    }\n\n    public void initializeBiosphere(Orb orb) {\n        BiosphereData data = new BiosphereData(orb);\n        biosphereData.put(orb.getId(), data);\n    }\n\n    public void updateBiosphere(Orb orb, String activity) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data == null) return;\n\n        switch (activity) {\n            case \"mining\" -> {\n                // Mining reduces ecological balance\n                data.ecologicalBalance = Math.max(0.0, data.ecologicalBalance - 0.1);\n                // Reduce flora density\n                data.floraDensity = Math.max(0.0, data.floraDensity - 0.05);\n            }\n            case \"planting\" -> {\n                // Planting improves ecological balance\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.05);\n                // Increase flora density\n                data.floraDensity = Math.min(1.0, data.floraDensity + 0.02);\n            }\n            case \"farming\" -> {\n                // Farming has mixed effects\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.02);\n            }\n            case \"exploration\" -> {\n                // Exploration slightly improves balance through discovery\n                data.ecologicalBalance = Math.min(2.0, data.ecologicalBalance + 0.01);\n            }\n        }\n\n        // Update the orb's ecological balance\n        orb.setEcologicalBalance(data.ecologicalBalance);\n\n        // Check for biosphere level changes\n        updateBiosphereLevel(orb, data);\n    }\n\n    private void updateBiosphereLevel(Orb orb, BiosphereData data) {\n        int newLevel = calculateBiosphereLevel(data);\n        if (newLevel != orb.getBiosphereLevel()) {\n            orb.setBiosphereLevel(newLevel);\n            onBiosphereLevelChange(orb, newLevel);\n        }\n    }\n\n    private int calculateBiosphereLevel(BiosphereData data) {\n        double score = (data.floraDensity + data.faunaDensity + data.ecologicalBalance) / 3.0;\n\n        if (score >= 0.8) return 5;\n        else if (score >= 0.6) return 4;\n        else if (score >= 0.4) return 3;\n        else if (score >= 0.2) return 2;\n        else return 1;\n    }\n\n    private void onBiosphereLevelChange(Orb orb, int newLevel) {\n        // Trigger events based on biosphere level changes\n        switch (newLevel) {\n            case 2 -> {\n                // Unlock basic ecosystem features\n                spawnInitialFlora(orb);\n            }\n            case 3 -> {\n                // Unlock intermediate features\n                spawnIntermediateFlora(orb);\n                spawnInitialFauna(orb);\n            }\n            case 4 -> {\n                // Unlock advanced features\n                spawnAdvancedFlora(orb);\n                spawnIntermediateFauna(orb);\n            }\n            case 5 -> {\n                // Unlock maximum ecosystem features\n                spawnMaximumFlora(orb);\n                spawnMaximumFauna(orb);\n                triggerEcosystemEvent(orb, \"blossoming\");\n            }\n        }\n    }\n\n    private void spawnInitialFlora(Orb orb) {\n        // Spawn basic plants and trees\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 100);\n        int spawnCount = orb.getRadius() / 10; // Scale with planet size\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    // Spawn grass or flowers\n                    Material plant = random.nextDouble() < 0.7 ? Material.SHORT_GRASS : Material.DANDELION;\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnIntermediateFlora(Orb orb) {\n        // Spawn bushes, flowers, and small trees\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 200);\n        int spawnCount = orb.getRadius() / 8;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    Material[] plants = {Material.POPPY, Material.BLUE_ORCHID, Material.ALLIUM, Material.AZURE_BLUET,\n                                       Material.RED_TULIP, Material.ORANGE_TULIP, Material.WHITE_TULIP, Material.PINK_TULIP,\n                                       Material.DANDELION};\n                    Material plant = plants[random.nextInt(plants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnAdvancedFlora(Orb orb) {\n        // Spawn rare plants and large vegetation\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 300);\n        int spawnCount = orb.getRadius() / 6;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK) {\n                    Material[] rarePlants = {Material.LILAC, Material.ROSE_BUSH, Material.PEONY, Material.SUNFLOWER,\n                                           Material.LARGE_FERN, Material.TALL_GRASS};\n                    Material plant = rarePlants[random.nextInt(rarePlants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n\n                    // Some plants are 2 blocks tall\n                    if (plant == Material.LILAC || plant == Material.ROSE_BUSH || plant == Material.PEONY ||\n                        plant == Material.SUNFLOWER || plant == Material.LARGE_FERN || plant == Material.TALL_GRASS) {\n                        world.getBlockAt(x, y + 2, z).setType(plant);\n                    }\n                }\n            }\n        }\n    }\n\n    private void spawnMaximumFlora(Orb orb) {\n        // Spawn maximum variety including mushrooms and special plants\n        World world = plugin.getServer().getWorld(orb.getWorldName());\n        if (world == null) return;\n\n        Random random = new Random(orb.getSeed() + 400);\n        int spawnCount = orb.getRadius() / 4;\n\n        for (int i = 0; i < spawnCount; i++) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = findSurfaceY(world, x, z, orb);\n\n            if (y != -1) {\n                Block block = world.getBlockAt(x, y, z);\n                if (block.getType() == Material.GRASS_BLOCK || block.getType() == Material.DIRT) {\n                    Material[] maxPlants = {Material.BROWN_MUSHROOM, Material.RED_MUSHROOM, Material.CRIMSON_FUNGUS,\n                                          Material.WARPED_FUNGUS, Material.WEEPING_VINES, Material.TWISTING_VINES,\n                                          Material.GLOW_LICHEN, Material.SPORE_BLOSSOM};\n                    Material plant = maxPlants[random.nextInt(maxPlants.length)];\n                    world.getBlockAt(x, y + 1, z).setType(plant);\n                }\n            }\n        }\n    }\n\n    private void spawnInitialFauna(Orb orb) {\n        // This would integrate with Minecraft's mob spawning system\n        // For now, just mark that fauna spawning is available\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.3;\n        }\n    }\n\n    private void spawnIntermediateFauna(Orb orb) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.5;\n        }\n    }\n\n    private void spawnMaximumFauna(Orb orb) {\n        BiosphereData data = biosphereData.get(orb.getId());\n        if (data != null) {\n            data.faunaDensity = 0.8;\n        }\n    }\n\n    private void triggerEcosystemEvent(Orb orb, String eventType) {\n        // Trigger special ecosystem events\n        switch (eventType) {\n            case \"blossoming\" -> {\n                // Maximum biosphere achieved - special effects\n                plugin.getLogger().info(\"Planet \" + orb.getName() + \" has achieved maximum biosphere level!\");\n            }\n        }\n    }\n\n    private int findSurfaceY(World world, int x, int z, Orb orb) {\n        int centerY = orb.getCenterY();\n        int radius = orb.getRadius();\n\n        // Search from top to bottom within planet bounds\n        for (int y = centerY + radius; y >= centerY - radius; y--) {\n            Block block = world.getBlockAt(x, y, z);\n            Block above = world.getBlockAt(x, y + 1, z);\n\n            // Check if this is a surface block (solid below, air above)\n            if (block.getType().isSolid() && above.getType() == Material.AIR) {\n                return y;\n            }\n        }\n\n        return -1; // No surface found\n    }\n\n    private void startBiosphereUpdater() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                // Periodic biosphere updates\n                for (BiosphereData data : biosphereData.values()) {\n                    // Natural regeneration\n                    if (data.ecologicalBalance < 1.0) {\n                        data.ecologicalBalance = Math.min(1.0, data.ecologicalBalance + 0.001);\n                        data.orb.setEcologicalBalance(data.ecologicalBalance);\n                    }\n\n                    // Flora/fauna natural growth\n                    if (data.floraDensity < 0.5) {\n                        data.floraDensity = Math.min(0.5, data.floraDensity + 0.0005);\n                    }\n\n                    if (data.faunaDensity < 0.3) {\n                        data.faunaDensity = Math.min(0.3, data.faunaDensity + 0.0002);\n                    }\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 1200L); // Every minute\n    }\n\n    public BiosphereData getBiosphereData(UUID orbId) {\n        return biosphereData.get(orbId);\n    }\n\n    public static class BiosphereData {\n        public final Orb orb;\n        public double floraDensity;\n        public double faunaDensity;\n        public double ecologicalBalance;\n\n        public BiosphereData(Orb orb) {\n            this.orb = orb;\n            this.floraDensity = 0.1; // Start with minimal flora\n            this.faunaDensity = 0.0; // No fauna initially\n            this.ecologicalBalance = 1.0; // Neutral balance\n        }\n    }\n}","size_bytes":12051},"src/main/java/com/skyorbs/shapes/ShapeRegistry.java":{"content":"package com.skyorbs.shapes;\n\nimport com.skyorbs.shapes.impl.*;\n\nimport java.util.*;\n\npublic class ShapeRegistry {\n    \n    private final Map<String, PlanetShape> shapes = new HashMap<String, PlanetShape>();\n    private final Random random = new Random();\n    \n    public void registerAllShapes() {\n        // Basic shapes (10)\n        register(new SphereShape());\n        register(new HemisphereShape());\n        register(new BlobShape());\n        register(new AsteroidShape());\n        register(new EllipsoidShape());\n        register(new TorusShape());\n        register(new RingShape());\n        register(new CylinderShape());\n        register(new ConeShape());\n        register(new DiamondShape());\n\n        // Advanced shapes (8)\n        register(new CubeShape());\n        register(new PyramidShape());\n        register(new OctahedronShape());\n        register(new FractalShape());\n        register(new SpikyShape());\n        register(new CometShape());\n        register(new CrescentShape());\n        register(new HybridShape());\n        \n        // NEW: Diverse shapes (15 more) - 33 TOTAL!\n        register(new LayeredShape());\n        register(new CrateredShape());\n        register(new HoneycombShape());\n        register(new SpiralShape());\n        register(new WaveShape());\n        register(new CrystalShape());\n        register(new OrganicShape());\n        register(new GeometricShape());\n        register(new NebulaShape());\n        register(new AsteroidFieldShape());\n\n        // EXTRA NEW SHAPES for more variety!\n        register(new StarShape());\n        register(new MoonShape());\n        register(new RainbowShape());\n        register(new ButterflyShape());\n        register(new HeartShape());\n    }\n    \n    public void register(PlanetShape shape) {\n        shapes.put(shape.getName(), shape);\n    }\n    \n    public PlanetShape getShape(String name) {\n        return shapes.getOrDefault(name, shapes.get(\"SPHERE\"));\n    }\n    \n    public PlanetShape getRandomShape(Map<String, Double> weights) {\n        double total = 0.0;\n        for (double weight : weights.values()) {\n            total += weight;\n        }\n        \n        double rand = random.nextDouble() * total;\n        double current = 0.0;\n        \n        for (Map.Entry<String, Double> entry : weights.entrySet()) {\n            current += entry.getValue();\n            if (rand <= current) {\n                PlanetShape shape = shapes.get(entry.getKey());\n                if (shape != null) {\n                    return shape;\n                }\n            }\n        }\n        \n        return shapes.get(\"SPHERE\");\n    }\n    \n    public Set<String> getShapeNames() {\n        return shapes.keySet();\n    }\n    \n    public int getShapeCount() {\n        return shapes.size();\n    }\n}\n","size_bytes":2765},"src/main/java/com/skyorbs/shapes/impl/OrganicShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\n/**\n * ORGANIC SHAPE - Organik yapı\n * Creates planets with organic, natural-looking forms\n */\npublic class OrganicShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Multiple noise layers for organic feel\n        double n1 = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.1);\n        double n2 = NoiseGenerator.getNoise(dx, dy, dz, seed + 100, 0.2);\n        double n3 = NoiseGenerator.getNoise(dx, dy, dz, seed + 200, 0.4);\n        \n        double organic = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;\n        double deform = 1 + organic * 0.4;\n        \n        return distance <= radius * deform;\n    }\n\n    @Override\n    public String getName() { \n        return \"ORGANIC\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.4; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Organik\"; \n    }\n}\n","size_bytes":1119},"src/main/java/com/skyorbs/atmosphere/PlanetAtmosphereManager.java":{"content":"package com.skyorbs.atmosphere;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.*;\nimport org.bukkit.entity.Player;\nimport org.bukkit.potion.PotionEffect;\nimport org.bukkit.potion.PotionEffectType;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.*;\n\n/**\n * Manages atmospheric effects for planets\n * Applies particles, status effects, and visual effects to players on planets\n */\npublic class PlanetAtmosphereManager {\n    \n    private final SkyOrbs plugin;\n    private final Map<UUID, AtmosphereType> planetAtmospheres = new HashMap<UUID, AtmosphereType>();\n    private BukkitRunnable atmosphereTask;\n    \n    public PlanetAtmosphereManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n    \n    /**\n     * Start atmosphere effects task\n     */\n    public void start() {\n        atmosphereTask = new BukkitRunnable() {\n            @Override\n            public void run() {\n                processAtmosphereEffects();\n            }\n        };\n        atmosphereTask.runTaskTimer(plugin, 20L, 20L); // Run every second\n    }\n    \n    /**\n     * Stop atmosphere effects task\n     */\n    public void stop() {\n        if (atmosphereTask != null) {\n            atmosphereTask.cancel();\n            atmosphereTask = null;\n        }\n    }\n    \n    /**\n     * Register atmosphere for a planet\n     */\n    public void registerPlanetAtmosphere(UUID planetId, AtmosphereType atmosphere) {\n        planetAtmospheres.put(planetId, atmosphere);\n    }\n    \n    /**\n     * Get atmosphere for a planet\n     */\n    public AtmosphereType getPlanetAtmosphere(UUID planetId) {\n        return planetAtmospheres.getOrDefault(planetId, AtmosphereType.CLEAR);\n    }\n    \n    /**\n     * Process atmospheric effects for all online players\n     */\n    private void processAtmosphereEffects() {\n        for (Player player : Bukkit.getOnlinePlayers()) {\n            Orb nearestPlanet = findNearestPlanet(player);\n            \n            if (nearestPlanet != null) {\n                AtmosphereType atmosphere = planetAtmospheres.get(nearestPlanet.getId());\n                if (atmosphere != null) {\n                    applyAtmosphereEffects(player, nearestPlanet, atmosphere);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Find nearest planet to player\n     */\n    private Orb findNearestPlanet(Player player) {\n        Location playerLoc = player.getLocation();\n        List<Orb> allPlanets;\n        \n        try {\n            allPlanets = plugin.getDatabaseManager().getAllOrbs();\n        } catch (Exception e) {\n            return null; // Return null if database error\n        }\n        \n        Orb nearest = null;\n        double minDistance = Double.MAX_VALUE;\n        \n        for (Orb orb : allPlanets) {\n            if (!orb.getWorldName().equals(playerLoc.getWorld().getName())) continue;\n            \n            double distance = Math.sqrt(\n                Math.pow(playerLoc.getX() - orb.getCenterX(), 2) +\n                Math.pow(playerLoc.getY() - orb.getCenterY(), 2) +\n                Math.pow(playerLoc.getZ() - orb.getCenterZ(), 2)\n            );\n            \n            // Check if player is within planet's atmosphere radius (1.5x planet radius)\n            if (distance <= orb.getRadius() * 1.5 && distance < minDistance) {\n                minDistance = distance;\n                nearest = orb;\n            }\n        }\n        \n        return nearest;\n    }\n    \n    /**\n     * Apply atmosphere effects to player\n     */\n    private void applyAtmosphereEffects(Player player, Orb planet, AtmosphereType atmosphere) {\n        // Apply potion effects\n        if (atmosphere.hasEffects()) {\n            player.addPotionEffect(new PotionEffect(\n                atmosphere.getEffectType(),\n                100,  // 5 seconds duration (refresh every second)\n                atmosphere == AtmosphereType.CORROSIVE ? 2 : 1, // Stronger corrosive\n                true,  // Ambient\n                true,  // Particles\n                true   // Icon\n            ));\n        }\n        \n        // Spawn particles around player\n        if (atmosphere.hasParticles()) {\n            spawnAtmosphereParticles(player, atmosphere);\n        }\n        \n        // Apply glow effect\n        if (atmosphere.hasGlow()) {\n            player.addPotionEffect(new PotionEffect(\n                PotionEffectType.NIGHT_VISION,\n                200,  // 10 seconds\n                0,\n                true,\n                false,\n                false\n            ));\n        }\n    }\n    \n    /**\n     * Spawn atmospheric particles around player\n     */\n    private void spawnAtmosphereParticles(Player player, AtmosphereType atmosphere) {\n        Location loc = player.getLocation();\n        World world = loc.getWorld();\n        Random random = new Random();\n        \n        // Spawn particles in a radius around player\n        for (int i = 0; i < 5; i++) {\n            double offsetX = (random.nextDouble() - 0.5) * 4;\n            double offsetY = (random.nextDouble() - 0.5) * 3;\n            double offsetZ = (random.nextDouble() - 0.5) * 4;\n            \n            Location particleLoc = loc.clone().add(offsetX, offsetY, offsetZ);\n            \n            world.spawnParticle(\n                atmosphere.getParticleType(),\n                particleLoc,\n                1,     // Count\n                0,     // Offset X\n                0,     // Offset Y\n                0,     // Offset Z\n                0.01   // Speed\n            );\n        }\n    }\n    \n    /**\n     * Select random atmosphere based on probabilities\n     */\n    public AtmosphereType selectRandomAtmosphere(Random random) {\n        double totalWeight = 0.0;\n        for (AtmosphereType type : AtmosphereType.values()) {\n            totalWeight += type.getProbability();\n        }\n        \n        double value = random.nextDouble() * totalWeight;\n        double current = 0.0;\n        \n        for (AtmosphereType type : AtmosphereType.values()) {\n            current += type.getProbability();\n            if (value <= current) {\n                return type;\n            }\n        }\n        \n        return AtmosphereType.CLEAR;\n    }\n}\n","size_bytes":6150},"src/main/java/com/skyorbs/storage/DatabaseManager.java":{"content":"package com.skyorbs.storage;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport com.skyorbs.modifiers.PlanetModifier;\nimport com.skyorbs.atmosphere.AtmosphereType;\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\n\nimport java.io.File;\nimport java.sql.*;\nimport java.util.*;\n\npublic class DatabaseManager {\n    \n    private final SkyOrbs plugin;\n    private Connection connection;\n    private final String dbPath;\n    private final Gson gson = new Gson(); // For JSON serialization\n    \n    // Database version for migration\n    private static final int CURRENT_VERSION = 2;\n    \n    public DatabaseManager(SkyOrbs plugin) {\n        this.plugin = plugin;\n        this.dbPath = plugin.getDataFolder() + \"/data.db\";\n    }\n    \n    public void initialize() throws SQLException {\n        File dataFolder = plugin.getDataFolder();\n        if (!dataFolder.exists()) {\n            dataFolder.mkdirs();\n        }\n\n        connection = DriverManager.getConnection(\"jdbc:sqlite:\" + dbPath);\n\n        // Check database version and migrate if needed\n        int currentVersion = getDatabaseVersion();\n\n        // Special case: if version is 1 but orbs table doesn't exist, it's a new database\n        if (currentVersion == 1 && !tableExists(\"orbs\")) {\n            plugin.logInfo(\"New database detected, setting version to \" + CURRENT_VERSION);\n            setDatabaseVersion(CURRENT_VERSION);\n            currentVersion = CURRENT_VERSION;\n        }\n\n        if (currentVersion < CURRENT_VERSION) {\n            plugin.logInfo(\"Database migration needed: v\" + currentVersion + \" -> v\" + CURRENT_VERSION);\n            migrateDatabase(currentVersion);\n        }\n\n        createTables();\n    }\n    \n    /**\n     * Get current database version\n     */\n    private int getDatabaseVersion() throws SQLException {\n        // Create version table if not exists\n        String createVersionTable = \"\"\"\n            CREATE TABLE IF NOT EXISTS schema_version (\n                version INTEGER PRIMARY KEY\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(createVersionTable);\n        }\n        \n        // Get version\n        String query = \"SELECT version FROM schema_version LIMIT 1\";\n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(query)) {\n            if (rs.next()) {\n                return rs.getInt(\"version\");\n            }\n        } catch (SQLException e) {\n            // Version table exists but empty - v1\n            return 1;\n        }\n        \n        // No version table - v1\n        return 1;\n    }\n    \n    /**\n     * Update database version\n     */\n    private void setDatabaseVersion(int version) throws SQLException {\n        String sql = \"INSERT OR REPLACE INTO schema_version (version) VALUES (?)\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setInt(1, version);\n            pstmt.executeUpdate();\n        }\n    }\n    \n    /**\n     * Migrate database from old version to new\n     */\n    private void migrateDatabase(int fromVersion) throws SQLException {\n        plugin.logInfo(\"Starting database migration from version \" + fromVersion + \"...\");\n        \n        if (fromVersion == 1) {\n            migrateV1ToV2();\n        }\n        \n        setDatabaseVersion(CURRENT_VERSION);\n        plugin.logSuccess(\"✓ Database migration completed!\");\n    }\n    \n    /**\n     * Migrate from v1 to v2 (add new columns)\n     */\n    private void migrateV1ToV2() throws SQLException {\n        plugin.logInfo(\"Migrating v1 -> v2: Adding new planet features...\");\n        \n        List<String> alterStatements = Arrays.asList(\n            \"ALTER TABLE orbs ADD COLUMN palette_id TEXT DEFAULT NULL\",\n            \"ALTER TABLE orbs ADD COLUMN modifiers TEXT DEFAULT NULL\", // JSON array\n            \"ALTER TABLE orbs ADD COLUMN atmosphere TEXT DEFAULT 'CLEAR'\",\n            \"ALTER TABLE orbs ADD COLUMN planet_type TEXT DEFAULT 'TERRESTRIAL'\",\n            \"ALTER TABLE orbs ADD COLUMN core_level INTEGER DEFAULT 1\",\n            \"ALTER TABLE orbs ADD COLUMN energy_level REAL DEFAULT 100.0\",\n            \"ALTER TABLE orbs ADD COLUMN xp BIGINT DEFAULT 0\",\n            \"ALTER TABLE orbs ADD COLUMN biosphere_level INTEGER DEFAULT 1\",\n            \"ALTER TABLE orbs ADD COLUMN ecological_balance REAL DEFAULT 1.0\"\n        );\n        \n        try (Statement stmt = connection.createStatement()) {\n            for (String sql : alterStatements) {\n                try {\n                    stmt.execute(sql);\n                    plugin.logInfo(\"  ✓ \" + sql.substring(0, 50) + \"...\");\n                } catch (SQLException e) {\n                    // Column might already exist - skip\n                    if (!e.getMessage().contains(\"duplicate column\")) {\n                        throw e;\n                    }\n                }\n            }\n        }\n    }\n    \n    private void createTables() throws SQLException {\n        // Updated orbs table with all new columns\n        String orbsTable = \"\"\"\n            CREATE TABLE IF NOT EXISTS orbs (\n                id TEXT PRIMARY KEY,\n                name TEXT NOT NULL,\n                world TEXT NOT NULL,\n                centerX INTEGER NOT NULL,\n                centerY INTEGER NOT NULL,\n                centerZ INTEGER NOT NULL,\n                radius INTEGER NOT NULL,\n                shape TEXT NOT NULL,\n                biome TEXT NOT NULL,\n                seed BIGINT NOT NULL,\n                created_at BIGINT NOT NULL,\n                is_asteroid BOOLEAN DEFAULT 0,\n                parent_id TEXT,\n                \n                -- NEW COLUMNS (v2)\n                palette_id TEXT DEFAULT NULL,\n                modifiers TEXT DEFAULT NULL,\n                atmosphere TEXT DEFAULT 'CLEAR',\n                planet_type TEXT DEFAULT 'TERRESTRIAL',\n                core_level INTEGER DEFAULT 1,\n                energy_level REAL DEFAULT 100.0,\n                xp BIGINT DEFAULT 0,\n                biosphere_level INTEGER DEFAULT 1,\n                ecological_balance REAL DEFAULT 1.0,\n                \n                FOREIGN KEY (parent_id) REFERENCES orbs(id) ON DELETE CASCADE\n            )\n        \"\"\";\n        \n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(orbsTable);\n        }\n    }\n    \n    public void saveOrb(Orb orb) throws SQLException {\n        String sql = \"\"\"\n            INSERT OR REPLACE INTO orbs \n            (id, name, world, centerX, centerY, centerZ, radius, shape, biome, seed, created_at, \n             is_asteroid, parent_id, palette_id, modifiers, atmosphere, planet_type, \n             core_level, energy_level, xp, biosphere_level, ecological_balance)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, orb.getId().toString());\n            pstmt.setString(2, orb.getName());\n            pstmt.setString(3, orb.getWorldName());\n            pstmt.setInt(4, orb.getCenterX());\n            pstmt.setInt(5, orb.getCenterY());\n            pstmt.setInt(6, orb.getCenterZ());\n            pstmt.setInt(7, orb.getRadius());\n            pstmt.setString(8, orb.getShapeName());\n            pstmt.setString(9, orb.getBiomeName());\n            pstmt.setLong(10, orb.getSeed());\n            pstmt.setLong(11, orb.getCreatedAt());\n            pstmt.setBoolean(12, orb.isAsteroid());\n            pstmt.setString(13, orb.getParentId() != null ? orb.getParentId().toString() : null);\n            \n            // NEW: Save advanced features\n            pstmt.setString(14, orb.getPaletteId());\n            pstmt.setString(15, serializeModifiers(orb.getModifiers()));\n            pstmt.setString(16, orb.getAtmosphere().name());\n            pstmt.setString(17, orb.getPlanetType().name());\n            pstmt.setInt(18, orb.getCoreLevel());\n            pstmt.setDouble(19, orb.getEnergyLevel());\n            pstmt.setLong(20, orb.getXp());\n            pstmt.setInt(21, orb.getBiosphereLevel());\n            pstmt.setDouble(22, orb.getEcologicalBalance());\n            \n            pstmt.executeUpdate();\n        }\n    }\n    \n    public Orb getOrb(UUID id) throws SQLException {\n        String sql = \"SELECT * FROM orbs WHERE id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, id.toString());\n            ResultSet rs = pstmt.executeQuery();\n            \n            if (rs.next()) {\n                return mapResultSetToOrb(rs);\n            }\n        }\n        return null;\n    }\n    \n    public Orb getOrbByName(String name) throws SQLException {\n        String sql = \"SELECT * FROM orbs WHERE name = ? COLLATE NOCASE\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, name);\n            ResultSet rs = pstmt.executeQuery();\n            \n            if (rs.next()) {\n                return mapResultSetToOrb(rs);\n            }\n        }\n        return null;\n    }\n    \n    public List<Orb> getAllOrbs() throws SQLException {\n        List<Orb> orbs = new ArrayList<Orb>();\n        String sql = \"SELECT * FROM orbs WHERE is_asteroid = 0 ORDER BY created_at DESC\";\n        \n        try (Statement stmt = connection.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            \n            while (rs.next()) {\n                orbs.add(mapResultSetToOrb(rs));\n            }\n        }\n        return orbs;\n    }\n    \n    public List<Orb> getChildOrbs(UUID planetId) throws SQLException {\n        List<Orb> children = new ArrayList<Orb>();\n        String sql = \"SELECT * FROM orbs WHERE parent_id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, planetId.toString());\n            ResultSet rs = pstmt.executeQuery();\n            \n            while (rs.next()) {\n                children.add(mapResultSetToOrb(rs));\n            }\n        }\n        return children;\n    }\n    \n    public void deleteOrb(UUID id) throws SQLException {\n        String sql = \"DELETE FROM orbs WHERE id = ?\";\n        \n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, id.toString());\n            pstmt.executeUpdate();\n        }\n    }\n    \n    /**\n     * Map database row to Orb object (with new features)\n     */\n    private Orb mapResultSetToOrb(ResultSet rs) throws SQLException {\n        UUID id = UUID.fromString(rs.getString(\"id\"));\n        String name = rs.getString(\"name\");\n        String world = rs.getString(\"world\");\n        int centerX = rs.getInt(\"centerX\");\n        int centerY = rs.getInt(\"centerY\");\n        int centerZ = rs.getInt(\"centerZ\");\n        int radius = rs.getInt(\"radius\");\n        String shape = rs.getString(\"shape\");\n        String biome = rs.getString(\"biome\");\n        long seed = rs.getLong(\"seed\");\n        long createdAt = rs.getLong(\"created_at\");\n        boolean isAsteroid = rs.getBoolean(\"is_asteroid\");\n        \n        String parentIdStr = rs.getString(\"parent_id\");\n        UUID parentId = parentIdStr != null ? UUID.fromString(parentIdStr) : null;\n        \n        Orb orb = new Orb(id, name, world, centerX, centerY, centerZ, radius, \n                         shape, biome, seed, createdAt, isAsteroid, parentId);\n        \n        // Load advanced features (with null checks for backward compatibility)\n        try {\n            String paletteId = rs.getString(\"palette_id\");\n            if (paletteId != null) {\n                orb.setPaletteId(paletteId);\n            }\n            \n            String modifiersJson = rs.getString(\"modifiers\");\n            if (modifiersJson != null) {\n                orb.setModifiers(deserializeModifiers(modifiersJson));\n            }\n            \n            String atmosphereStr = rs.getString(\"atmosphere\");\n            if (atmosphereStr != null) {\n                orb.setAtmosphere(AtmosphereType.valueOf(atmosphereStr));\n            }\n            \n            String planetTypeStr = rs.getString(\"planet_type\");\n            if (planetTypeStr != null) {\n                orb.setPlanetType(PlanetType.valueOf(planetTypeStr));\n            }\n            \n            orb.setCoreLevel(rs.getInt(\"core_level\"));\n            orb.setEnergyLevel(rs.getDouble(\"energy_level\"));\n            orb.addXp(rs.getLong(\"xp\") - orb.getXp()); // Set XP correctly\n            orb.setBiosphereLevel(rs.getInt(\"biosphere_level\"));\n            orb.setEcologicalBalance(rs.getDouble(\"ecological_balance\"));\n            \n        } catch (SQLException e) {\n            // Columns don't exist (old database) - use defaults\n            plugin.logWarning(\"Old database format detected, using default values for planet: \" + name);\n        }\n        \n        return orb;\n    }\n    \n    /**\n     * Serialize modifiers to JSON\n     */\n    private String serializeModifiers(Set<PlanetModifier> modifiers) {\n        if (modifiers == null || modifiers.isEmpty()) {\n            return null;\n        }\n        \n        List<String> modifierNames = modifiers.stream()\n            .map(PlanetModifier::name)\n            .toList();\n        \n        return gson.toJson(modifierNames);\n    }\n    \n    /**\n     * Deserialize modifiers from JSON\n     */\n    private Set<PlanetModifier> deserializeModifiers(String json) {\n        if (json == null || json.isEmpty()) {\n            return new HashSet<PlanetModifier>();\n        }\n        \n        try {\n            List<String> modifierNames = gson.fromJson(json, new TypeToken<List<String>>(){}.getType());\n            Set<PlanetModifier> modifiers = new HashSet<PlanetModifier>();\n            \n            for (String name : modifierNames) {\n                try {\n                    modifiers.add(PlanetModifier.valueOf(name));\n                } catch (IllegalArgumentException e) {\n                    plugin.logWarning(\"Unknown modifier: \" + name);\n                }\n            }\n            \n            return modifiers;\n        } catch (Exception e) {\n            plugin.logError(\"Failed to deserialize modifiers\", e);\n            return new HashSet<PlanetModifier>();\n        }\n    }\n    \n    /**\n     * Check if a table exists\n     */\n    private boolean tableExists(String tableName) throws SQLException {\n        String sql = \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\";\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setString(1, tableName);\n            ResultSet rs = pstmt.executeQuery();\n            return rs.next();\n        }\n    }\n\n    public void close() {\n        try {\n            if (connection != null && !connection.isClosed()) {\n                connection.close();\n            }\n        } catch (SQLException e) {\n            plugin.logError(\"Veritabanı kapatılırken hata!\", e);\n        }\n    }\n}\n","size_bytes":15038},"src/main/java/com/skyorbs/biomes/BiomeType.java":{"content":"package com.skyorbs.biomes;\n\nimport org.bukkit.Material;\n\nimport java.util.Random;\n\npublic enum BiomeType {\n\n    // Earth-like biomes (6)\n    FOREST(\"Orman\", Material.GRASS_BLOCK, Material.OAK_LOG, Material.DIRT),\n    PLAINS(\"Düzlük\", Material.GRASS_BLOCK, Material.DIRT, Material.STONE),\n    JUNGLE(\"Orman\", Material.JUNGLE_LOG, Material.JUNGLE_LEAVES, Material.MOSS_BLOCK),\n    SAVANNA(\"Savana\", Material.GRASS_BLOCK, Material.ACACIA_LOG, Material.COARSE_DIRT),\n    TAIGA(\"Tayga\", Material.SPRUCE_LOG, Material.SNOW_BLOCK, Material.STONE),\n    MEADOW(\"Çayır\", Material.GRASS_BLOCK, Material.FLOWERING_AZALEA_LEAVES, Material.MOSS_BLOCK),\n\n    // Desert biomes (3)\n    DESERT(\"Çöl\", Material.SAND, Material.SANDSTONE, Material.RED_SAND),\n    BADLANDS(\"Kötü Toprak\", Material.RED_SAND, Material.TERRACOTTA, Material.CLAY),\n    CANYON(\"Kanyon\", Material.ORANGE_TERRACOTTA, Material.RED_SANDSTONE, Material.STONE),\n\n    // Ice biomes (3)\n    FROZEN_TUNDRA(\"Donmuş Tundra\", Material.SNOW_BLOCK, Material.ICE, Material.PACKED_ICE),\n    ICE_SPIKES(\"Buz Dikenleri\", Material.PACKED_ICE, Material.BLUE_ICE, Material.SNOW_BLOCK),\n    GLACIER(\"Buzul\", Material.BLUE_ICE, Material.ICE, Material.STONE),\n\n    // Volcanic biomes (3)\n    LAVA_OCEAN(\"Lav Okyanusu\", Material.MAGMA_BLOCK, Material.NETHERRACK, Material.BLACKSTONE),\n    OBSIDIAN_PLAINS(\"Obsidyen Düzlüğü\", Material.OBSIDIAN, Material.CRYING_OBSIDIAN, Material.BLACKSTONE),\n    MAGMA_CAVES(\"Magma Mağaraları\", Material.NETHERRACK, Material.MAGMA_BLOCK, Material.BASALT),\n\n    // Alien biomes (7)\n    CRYSTAL_FOREST(\"Kristal Ormanı\", Material.AMETHYST_BLOCK, Material.PURPUR_BLOCK, Material.QUARTZ_BLOCK),\n    VOID(\"Boşluk\", Material.END_STONE, Material.OBSIDIAN, Material.CRYING_OBSIDIAN),\n    CORRUPTED(\"Bozulmuş\", Material.WARPED_NYLIUM, Material.CRIMSON_NYLIUM, Material.SOUL_SOIL),\n    MUSHROOM_GIANT(\"Dev Mantar\", Material.RED_MUSHROOM_BLOCK, Material.BROWN_MUSHROOM_BLOCK, Material.MYCELIUM),\n    TOXIC_SWAMP(\"Zehirli Bataklık\", Material.SLIME_BLOCK, Material.MOSS_BLOCK, Material.SCULK),\n    GLOWSTONE_CAVERN(\"Parıltı Taşı Mağarası\", Material.GLOWSTONE, Material.SHROOMLIGHT, Material.SEA_LANTERN),\n    CHORUS_LAND(\"Chorus Diyarı\", Material.CHORUS_PLANT, Material.PURPUR_BLOCK, Material.END_STONE),\n\n    // Additional diverse biomes (25+ more for massive variety)\n    BASALTIC(\"Bazaltik\", Material.BASALT, Material.BLACKSTONE, Material.DEEPSLATE),\n    CRYSTALLINE(\"Kristalimsi\", Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.DIAMOND_BLOCK),\n    FUNGAL(\"Mantarlı\", Material.MYCELIUM, Material.RED_MUSHROOM_BLOCK, Material.BROWN_MUSHROOM_BLOCK),\n    CORAL(\"Mercan\", Material.BRAIN_CORAL_BLOCK, Material.TUBE_CORAL_BLOCK, Material.HORN_CORAL_BLOCK),\n    TOXIC(\"Zehirli\", Material.GREEN_CONCRETE, Material.LIME_CONCRETE, Material.SLIME_BLOCK),\n    AURORA(\"Aurora\", Material.PACKED_ICE, Material.BLUE_ICE, Material.LIGHT_BLUE_CONCRETE),\n    STORMY(\"Fırtınalı\", Material.GRAY_CONCRETE, Material.LIGHT_GRAY_CONCRETE, Material.STONE),\n    FOGGY(\"Sisli\", Material.WHITE_CONCRETE, Material.LIGHT_GRAY_CONCRETE, Material.COBBLESTONE),\n    CORROSIVE(\"Aşındırıcı\", Material.YELLOW_CONCRETE, Material.ORANGE_CONCRETE, Material.RED_CONCRETE),\n    LUMINOUS(\"Parıltılı\", Material.SEA_LANTERN, Material.GLOWSTONE, Material.SHROOMLIGHT),\n\n    // NEW: Extended biomes for 10,000+ combinations\n    NEBULOUS(\"Sisli\", Material.WHITE_CONCRETE, Material.LIGHT_GRAY_CONCRETE, Material.GRAY_CONCRETE),\n    COSMIC(\"Kozmik\", Material.END_STONE, Material.PURPUR_BLOCK, Material.OBSIDIAN),\n    ETHEREAL(\"Eterik\", Material.WHITE_WOOL, Material.LIGHT_GRAY_WOOL, Material.GRAY_WOOL),\n    PRIMAL(\"İlkel\", Material.STONE, Material.COBBLESTONE, Material.MOSSY_COBBLESTONE),\n    CELESTIAL(\"Göksel\", Material.QUARTZ_BLOCK, Material.SEA_LANTERN, Material.GLOWSTONE),\n    VOID_BORN(\"Boşluk Doğumlu\", Material.OBSIDIAN, Material.CRYING_OBSIDIAN, Material.END_STONE),\n    STAR_FORGED(\"Yıldız Dövülmüş\", Material.IRON_BLOCK, Material.GOLD_BLOCK, Material.DIAMOND_BLOCK),\n    NEBULA_INFUSED(\"Sis Enjekte\", Material.PURPLE_CONCRETE, Material.MAGENTA_CONCRETE, Material.PINK_CONCRETE),\n    GALACTIC(\"Galaktik\", Material.LAPIS_BLOCK, Material.DIAMOND_BLOCK, Material.EMERALD_BLOCK),\n    UNIVERSE_BOUND(\"Evren Bağlı\", Material.BEACON, Material.SEA_LANTERN, Material.CONDUIT),\n\n    // Elemental biomes\n    FLAME(\"Alev\", Material.NETHERRACK, Material.MAGMA_BLOCK, Material.FIRE),\n    FROST(\"Kırağı\", Material.ICE, Material.PACKED_ICE, Material.BLUE_ICE),\n    STORM(\"Fırtına\", Material.STONE, Material.COBBLESTONE, Material.GRAVEL),\n    EARTH(\"Toprak\", Material.DIRT, Material.GRASS_BLOCK, Material.STONE),\n    WATER(\"Su\", Material.WATER, Material.ICE, Material.PRISMARINE),\n    WIND(\"Rüzgar\", Material.AIR, Material.WHITE_WOOL, Material.STRING),\n\n    // Mystical biomes\n    ARCANE(\"Gizemli\", Material.PURPUR_BLOCK, Material.END_STONE, Material.OBSIDIAN),\n    DIVINE(\"İlahî\", Material.GOLD_BLOCK, Material.DIAMOND_BLOCK, Material.BEACON),\n    INFERNAL(\"Cehennemî\", Material.NETHERRACK, Material.NETHER_BRICKS, Material.MAGMA_BLOCK),\n    CELESTIAL_BLESSED(\"Göksel Bereketli\", Material.QUARTZ_BLOCK, Material.GOLD_BLOCK, Material.DIAMOND_BLOCK),\n    VOID_ENERGY(\"Boşluk Enerjisi\", Material.OBSIDIAN, Material.CRYING_OBSIDIAN, Material.RESPAWN_ANCHOR),\n\n    // Rare special biomes\n    QUANTUM(\"Kuantum\", Material.AMETHYST_BLOCK, Material.BUDDING_AMETHYST, Material.AMETHYST_CLUSTER),\n    TEMPORAL(\"Zamansal\", Material.CLOCK, Material.COMPASS, Material.RECOVERY_COMPASS),\n    DIMENSIONAL(\"Boyutsal\", Material.END_PORTAL_FRAME, Material.END_STONE, Material.OBSIDIAN),\n    MIRROR(\"Ayna\", Material.GLASS, Material.WHITE_STAINED_GLASS, Material.LIGHT_GRAY_STAINED_GLASS),\n    PHASE(\"Faz\", Material.SOUL_SAND, Material.SOUL_SOIL, Material.SOUL_CAMPFIRE),\n\n    // Exotic material biomes\n    HONEYCOMB(\"Bal Peteği\", Material.HONEY_BLOCK, Material.HONEYCOMB_BLOCK, Material.BEEHIVE),\n    SPONGE(\"Sünger\", Material.SPONGE, Material.WET_SPONGE, Material.PRISMARINE),\n    BONE(\"Kemik\", Material.BONE_BLOCK, Material.WHITE_CONCRETE, Material.LIGHT_GRAY_CONCRETE),\n    BAMBOO(\"Bambu\", Material.BAMBOO_BLOCK, Material.GREEN_CONCRETE, Material.JUNGLE_WOOD),\n    CHERRY(\"Kiraz\", Material.PINK_CONCRETE, Material.PINK_TERRACOTTA, Material.WHITE_CONCRETE),\n    CALCITE(\"Kalsit\", Material.CALCITE, Material.QUARTZ_BLOCK, Material.DRIPSTONE_BLOCK),\n    DRIPSTONE(\"Damla Taşı\", Material.DRIPSTONE_BLOCK, Material.STONE, Material.CALCITE),\n    OXIDIZED(\"Oksitlenmiş\", Material.OXIDIZED_COPPER, Material.WEATHERED_COPPER, Material.EXPOSED_COPPER),\n    COBBLED(\"Kırık Taş\", Material.COBBLESTONE, Material.MOSSY_COBBLESTONE, Material.STONE),\n    POLISHED(\"Parlatılmış\", Material.POLISHED_ANDESITE, Material.POLISHED_DIORITE, Material.POLISHED_GRANITE),\n    BRICKS(\"Tuğla\", Material.BRICKS, Material.STONE_BRICKS, Material.MOSSY_STONE_BRICKS),\n    WOOL(\"Yün\", Material.WHITE_WOOL, Material.LIGHT_GRAY_WOOL, Material.GRAY_WOOL),\n    GLASS(\"Cam\", Material.GLASS, Material.WHITE_STAINED_GLASS, Material.LIGHT_GRAY_STAINED_GLASS),\n    PACKED_MUD(\"Sıkıştırılmış Çamur\", Material.PACKED_MUD, Material.MUD_BRICKS, Material.MUD),\n    REINFORCED(\"Takviyeli\", Material.REINFORCED_DEEPSLATE, Material.DEEPSLATE, Material.DEEPSLATE_BRICKS);\n    \n    private final String displayName;\n    private final Material primary;\n    private final Material secondary;\n    private final Material tertiary;\n    \n    BiomeType(String displayName, Material primary, Material secondary, Material tertiary) {\n        this.displayName = displayName;\n        this.primary = primary;\n        this.secondary = secondary;\n        this.tertiary = tertiary;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public Material getMaterial(int depth, Random random) {\n        if (depth == 0) {\n            return primary;\n        } else if (depth < 3) {\n            return random.nextDouble() < 0.7 ? secondary : primary;\n        } else if (depth < 6) {\n            return random.nextDouble() < 0.5 ? tertiary : secondary;\n        } else {\n            return tertiary;\n        }\n    }\n    \n    public static BiomeType getRandomBiome(Random random) {\n        BiomeType[] values = values();\n        return values[random.nextInt(values.length)];\n    }\n    \n    public static BiomeType getRandomBiomeWeighted(Random random) {\n        double rand = random.nextDouble();\n\n        if (rand < 0.15) {\n            // Earth-like biomes (6) - Common\n            BiomeType[] earthLike = {FOREST, PLAINS, JUNGLE, SAVANNA, TAIGA, MEADOW};\n            return earthLike[random.nextInt(earthLike.length)];\n        } else if (rand < 0.25) {\n            // Desert biomes (3) - Common\n            BiomeType[] desertLike = {DESERT, BADLANDS, CANYON};\n            return desertLike[random.nextInt(desertLike.length)];\n        } else if (rand < 0.35) {\n            // Ice biomes (3) - Common\n            BiomeType[] ice = {FROZEN_TUNDRA, ICE_SPIKES, GLACIER};\n            return ice[random.nextInt(ice.length)];\n        } else if (rand < 0.45) {\n            // Volcanic biomes (3) - Common\n            BiomeType[] volcanic = {LAVA_OCEAN, OBSIDIAN_PLAINS, MAGMA_CAVES};\n            return volcanic[random.nextInt(volcanic.length)];\n        } else if (rand < 0.55) {\n            // Alien biomes (7) - Uncommon\n            BiomeType[] alien = {CRYSTAL_FOREST, VOID, CORRUPTED, MUSHROOM_GIANT, TOXIC_SWAMP, GLOWSTONE_CAVERN, CHORUS_LAND};\n            return alien[random.nextInt(alien.length)];\n        } else if (rand < 0.65) {\n            // Original diverse biomes (10) - Uncommon\n            BiomeType[] diverse = {BASALTIC, CRYSTALLINE, FUNGAL, CORAL, TOXIC, AURORA, STORMY, FOGGY, CORROSIVE, LUMINOUS};\n            return diverse[random.nextInt(diverse.length)];\n        } else if (rand < 0.75) {\n            // Extended biomes (10) - Rare\n            BiomeType[] extended = {NEBULOUS, COSMIC, ETHEREAL, PRIMAL, CELESTIAL, VOID_BORN, STAR_FORGED, NEBULA_INFUSED, GALACTIC, UNIVERSE_BOUND};\n            return extended[random.nextInt(extended.length)];\n        } else if (rand < 0.85) {\n            // Elemental biomes (6) - Rare\n            BiomeType[] elemental = {FLAME, FROST, STORM, EARTH, WATER, WIND};\n            return elemental[random.nextInt(elemental.length)];\n        } else if (rand < 0.92) {\n            // Mystical biomes (5) - Very Rare\n            BiomeType[] mystical = {ARCANE, DIVINE, INFERNAL, CELESTIAL_BLESSED, VOID_ENERGY};\n            return mystical[random.nextInt(mystical.length)];\n        } else if (rand < 0.96) {\n            // Special biomes (5) - Ultra Rare\n            BiomeType[] special = {QUANTUM, TEMPORAL, DIMENSIONAL, MIRROR, PHASE};\n            return special[random.nextInt(special.length)];\n        } else {\n            // Exotic material biomes (15) - Legendary\n            BiomeType[] exotic = {HONEYCOMB, SPONGE, BONE, BAMBOO, CHERRY, CALCITE, DRIPSTONE, OXIDIZED, COBBLED, POLISHED, BRICKS, WOOL, GLASS, PACKED_MUD, REINFORCED};\n            return exotic[random.nextInt(exotic.length)];\n        }\n    }\n}\n","size_bytes":11101},"src/main/java/com/skyorbs/shapes/impl/NebulaShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\n/**\n * NEBULA SHAPE - Nebula bulutu\n * Creates wispy, cloud-like celestial bodies\n */\npublic class NebulaShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        \n        // Very wispy, cloud-like\n        double n1 = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.05);\n        double n2 = NoiseGenerator.getNoise(dx, dy, dz, seed + 50, 0.1);\n        double n3 = NoiseGenerator.getNoise(dx, dy, dz, seed + 100, 0.2);\n        \n        double nebula = Math.abs(n1) * 0.5 + Math.abs(n2) * 0.3 + Math.abs(n3) * 0.2;\n        \n        // Very irregular, sparse structure\n        return distance <= radius * (0.7 + nebula * 0.8) && nebula > 0.3;\n    }\n\n    @Override\n    public String getName() { \n        return \"NEBULA\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.8; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Nebula\"; \n    }\n}\n","size_bytes":1150},"src/main/java/com/skyorbs/features/TreasureGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.block.Chest;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.enchantments.Enchantment;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class TreasureGenerator {\n    \n    public static List<TreasureLocation> generateTreasures(Orb orb, BiomeType biome, World world) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n\n        // CONFIG KONTROLLÜ - Treasure sistemi aktif mi?\n        if (!plugin.getConfig().getBoolean(\"treasures.enabled\", true)) {\n            return new ArrayList<TreasureLocation>();\n        }\n\n        List<TreasureLocation> treasures = new ArrayList<TreasureLocation>();\n        // Use deterministic seed based on biome + planet seed for consistent loot\n        Random random = new Random(orb.getSeed() + biome.name().hashCode() + 999);\n\n        int cx = orb.getCenterX();\n        int cy = orb.getCenterY();\n        int cz = orb.getCenterZ();\n        int radius = orb.getRadius();\n\n        PlanetType planetType = orb.getPlanetType();\n\n        // CONFIG'DEN PLANET TYPE AYARLARINI OKU\n        String planetTypeKey = planetType.name().toLowerCase();\n        boolean planetEnabled = plugin.getConfig().getBoolean(\"treasures.planetTypes.\" + planetTypeKey + \".enabled\", true);\n        if (!planetEnabled) return treasures;\n\n        double baseDensity = plugin.getConfig().getDouble(\"treasures.densityMultiplier\", 0.008);\n        double planetMultiplier = plugin.getConfig().getDouble(\"treasures.planetTypes.\" + planetTypeKey + \".densityMultiplier\", 1.0);\n        int treasureCount = Math.max(1, (int)(radius * baseDensity * planetMultiplier));\n\n        for (int i = 0; i < treasureCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Find actual surface level within planet bounds for treasure placement\n            int y = findSurfaceLevelWithinPlanet(cx, cy, cz, x, z, radius, random);\n            if (y == -1) continue; // No surface found, skip this treasure\n\n            // Place treasure slightly below surface (buried)\n            y = y - (1 + random.nextInt(3)); // 1-3 blocks below surface\n\n            // CONFIG'DEN TREASURE TİPİ SEÇ - Gezegen türüne göre\n            TreasureType type = getTreasureTypeFromConfig(planetType, random);\n\n            treasures.add(new TreasureLocation(x, y, z, biome, type));\n        }\n\n        return treasures;\n    }\n    \n    /**\n     * Hazine sandığını doldur\n     */\n    public static void fillTreasureChest(Block block, BiomeType biome, TreasureType type, Random random) {\n        if (!(block.getState() instanceof Chest chest)) return;\n        \n        Inventory inv = chest.getInventory();\n        inv.clear();\n        \n        // Loot tablosuna göre item ekle\n        List<ItemStack> loot = generateLoot(biome, type, random);\n        \n        for (ItemStack item : loot) {\n            int slot = random.nextInt(27);\n            while (inv.getItem(slot) != null) {\n                slot = random.nextInt(27);\n            }\n            inv.setItem(slot, item);\n        }\n        \n        chest.update();\n    }\n    \n    /**\n     * Loot oluştur\n     */\n    private static List<ItemStack> generateLoot(BiomeType biome, TreasureType type, Random random) {\n        List<ItemStack> loot = new ArrayList<ItemStack>();\n        \n        switch (type) {\n            case COMMON -> {\n                // Temel itemler - AMOUNT EN AZ 1 OLACAK\n                loot.add(new ItemStack(Material.IRON_INGOT, Math.max(1, 3 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, 1 + random.nextInt(4))));\n                loot.add(new ItemStack(Material.COAL, Math.max(1, 5 + random.nextInt(15))));\n                loot.add(new ItemStack(Material.BREAD, Math.max(1, 2 + random.nextInt(6))));\n\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.IRON_SWORD, 1));\n                }\n                if (random.nextDouble() < 0.3) {\n                    loot.add(new ItemStack(Material.IRON_PICKAXE, 1));\n                }\n            }\n            \n            case UNCOMMON -> {\n                // Daha iyi itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.GOLD_INGOT, Math.max(1, 4 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 1 + random.nextInt(3))));\n                if (random.nextInt(3) > 0) { // 66% şans\n                    loot.add(new ItemStack(Material.EMERALD, Math.max(1, random.nextInt(3))));\n                }\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n\n                if (random.nextDouble() < 0.6) {\n                    ItemStack sword = new ItemStack(Material.IRON_SWORD, 1);\n                    sword.addEnchantment(Enchantment.SHARPNESS, 1 + random.nextInt(2));\n                    loot.add(sword);\n                }\n\n                if (random.nextDouble() < 0.4) {\n                    loot.add(new ItemStack(Material.GOLDEN_APPLE, Math.max(1, 1 + random.nextInt(2))));\n                }\n            }\n            \n            case RARE -> {\n                // Nadir itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 3 + random.nextInt(5))));\n                loot.add(new ItemStack(Material.EMERALD, Math.max(1, 2 + random.nextInt(4))));\n                if (random.nextInt(2) > 0) { // 50% şans\n                    loot.add(new ItemStack(Material.NETHERITE_SCRAP, Math.max(1, random.nextInt(2))));\n                }\n\n                if (random.nextDouble() < 0.7) {\n                    ItemStack armor = new ItemStack(\n                        random.nextBoolean() ? Material.DIAMOND_CHESTPLATE : Material.DIAMOND_HELMET, 1\n                    );\n                    armor.addEnchantment(Enchantment.PROTECTION, 2 + random.nextInt(2));\n                    loot.add(armor);\n                }\n\n                if (random.nextDouble() < 0.5) {\n                    ItemStack pickaxe = new ItemStack(Material.DIAMOND_PICKAXE, 1);\n                    pickaxe.addEnchantment(Enchantment.EFFICIENCY, 2 + random.nextInt(3));\n                    pickaxe.addEnchantment(Enchantment.FORTUNE, 1 + random.nextInt(2));\n                    loot.add(pickaxe);\n                }\n\n                loot.add(new ItemStack(Material.GOLDEN_APPLE, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n            \n            case EPIC -> {\n                // Epik itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND, Math.max(1, 5 + random.nextInt(10))));\n                loot.add(new ItemStack(Material.EMERALD, Math.max(1, 4 + random.nextInt(8))));\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, 1 + random.nextInt(2))));\n                if (random.nextInt(2) > 0) { // 50% şans\n                    loot.add(new ItemStack(Material.ENCHANTED_GOLDEN_APPLE, Math.max(1, random.nextInt(2))));\n                }\n\n                // Tam set zırh\n                ItemStack helmet = new ItemStack(Material.DIAMOND_HELMET, 1);\n                helmet.addEnchantment(Enchantment.PROTECTION, 3 + random.nextInt(2));\n                helmet.addEnchantment(Enchantment.UNBREAKING, 2 + random.nextInt(2));\n                loot.add(helmet);\n\n                ItemStack chestplate = new ItemStack(Material.DIAMOND_CHESTPLATE, 1);\n                chestplate.addEnchantment(Enchantment.PROTECTION, 3 + random.nextInt(2));\n                loot.add(chestplate);\n\n                // Güçlü silah\n                ItemStack sword = new ItemStack(Material.DIAMOND_SWORD, 1);\n                sword.addEnchantment(Enchantment.SHARPNESS, 3 + random.nextInt(2));\n                sword.addEnchantment(Enchantment.LOOTING, 1 + random.nextInt(2));\n                loot.add(sword);\n\n                // Enchanted book\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n            \n            case LEGENDARY -> {\n                // Efsanevi itemler - AMOUNT EN AZ 1\n                loot.add(new ItemStack(Material.DIAMOND_BLOCK, Math.max(1, 2 + random.nextInt(4))));\n                loot.add(new ItemStack(Material.EMERALD_BLOCK, Math.max(1, 1 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.NETHERITE_INGOT, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.ENCHANTED_GOLDEN_APPLE, Math.max(1, 2 + random.nextInt(3))));\n                loot.add(new ItemStack(Material.TOTEM_OF_UNDYING, 1));\n\n                // Netherite ekipman\n                ItemStack netheriteHelmet = new ItemStack(Material.NETHERITE_HELMET, 1);\n                netheriteHelmet.addEnchantment(Enchantment.PROTECTION, 4);\n                netheriteHelmet.addEnchantment(Enchantment.UNBREAKING, 3);\n                netheriteHelmet.addEnchantment(Enchantment.MENDING, 1);\n                loot.add(netheriteHelmet);\n\n                ItemStack netheriteChest = new ItemStack(Material.NETHERITE_CHESTPLATE, 1);\n                netheriteChest.addEnchantment(Enchantment.PROTECTION, 4);\n                netheriteChest.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheriteChest);\n\n                ItemStack netheriteSword = new ItemStack(Material.NETHERITE_SWORD, 1);\n                netheriteSword.addEnchantment(Enchantment.SHARPNESS, 5);\n                netheriteSword.addEnchantment(Enchantment.LOOTING, 3);\n                netheriteSword.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheriteSword);\n\n                ItemStack netheritePickaxe = new ItemStack(Material.NETHERITE_PICKAXE, 1);\n                netheritePickaxe.addEnchantment(Enchantment.EFFICIENCY, 5);\n                netheritePickaxe.addEnchantment(Enchantment.FORTUNE, 3);\n                netheritePickaxe.addEnchantment(Enchantment.UNBREAKING, 3);\n                loot.add(netheritePickaxe);\n\n                // Özel itemler\n                loot.add(new ItemStack(Material.ELYTRA, 1));\n                loot.add(new ItemStack(Material.TRIDENT, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n                loot.add(new ItemStack(Material.ENCHANTED_BOOK, 1));\n            }\n        }\n        \n        // Biyom özel bonuslar\n        if (SkyOrbs.getInstance().getConfigManager().areBiomeSpecificTreasuresEnabled()) {\n            addBiomeSpecificLoot(loot, biome, random);\n        }\n        \n        return loot;\n    }\n    \n    /**\n     * Add biome-specific loot items deterministically\n     */\n    private static void addBiomeSpecificLoot(List<ItemStack> loot, BiomeType biome, Random random) {\n        // No changes needed here as loot is already parameterized\n        switch (biome) {\n            case DESERT, BADLANDS -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.SAND, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.CACTUS, 4 + random.nextInt(8)));\n                }\n            }\n\n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.PACKED_ICE, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.BLUE_ICE, 2 + random.nextInt(6)));\n                }\n            }\n\n            case JUNGLE -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.BAMBOO, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.COCOA_BEANS, 8 + random.nextInt(16)));\n                }\n            }\n\n            case LAVA_OCEAN, MAGMA_CAVES -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.MAGMA_BLOCK, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.FIRE_CHARGE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case CRYSTAL_FOREST -> {\n                if (random.nextDouble() < 0.8) {\n                    loot.add(new ItemStack(Material.AMETHYST_SHARD, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.AMETHYST_BLOCK, 2 + random.nextInt(4)));\n                }\n            }\n\n            case MUSHROOM_GIANT -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.RED_MUSHROOM, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.BROWN_MUSHROOM, 8 + random.nextInt(16)));\n                }\n            }\n\n            case GLOWSTONE_CAVERN -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.GLOWSTONE_DUST, 16 + random.nextInt(32)));\n                    loot.add(new ItemStack(Material.GLOWSTONE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case CHORUS_LAND -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.CHORUS_FRUIT, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.ENDER_PEARL, 2 + random.nextInt(4)));\n                }\n            }\n\n            // Additional biome-specific loot for new biomes\n            case BASALTIC -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.BASALT, 12 + random.nextInt(24)));\n                    loot.add(new ItemStack(Material.BLACKSTONE, 8 + random.nextInt(16)));\n                }\n            }\n\n            case CORAL -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.BRAIN_CORAL, 4 + random.nextInt(8)));\n                    loot.add(new ItemStack(Material.TUBE_CORAL, 4 + random.nextInt(8)));\n                }\n            }\n\n            case TOXIC -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.POISONOUS_POTATO, 6 + random.nextInt(12)));\n                    loot.add(new ItemStack(Material.SPIDER_EYE, 4 + random.nextInt(8)));\n                }\n            }\n\n            case AURORA -> {\n                if (random.nextDouble() < 0.4) {\n                    loot.add(new ItemStack(Material.PRISMARINE_CRYSTALS, 8 + random.nextInt(16)));\n                    loot.add(new ItemStack(Material.PRISMARINE_SHARD, 6 + random.nextInt(12)));\n                }\n            }\n\n            case STORMY -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.NAUTILUS_SHELL, 1));\n                    loot.add(new ItemStack(Material.HEART_OF_THE_SEA, 1));\n                }\n            }\n\n            case FOGGY -> {\n                if (random.nextDouble() < 0.5) {\n                    loot.add(new ItemStack(Material.PHANTOM_MEMBRANE, 2 + random.nextInt(4)));\n                }\n            }\n\n            case CORROSIVE -> {\n                if (random.nextDouble() < 0.6) {\n                    loot.add(new ItemStack(Material.WITHER_ROSE, 3 + random.nextInt(6)));\n                    loot.add(new ItemStack(Material.WITHER_SKELETON_SKULL, 1));\n                }\n            }\n\n            case LUMINOUS -> {\n                if (random.nextDouble() < 0.7) {\n                    loot.add(new ItemStack(Material.SEA_LANTERN, 4 + random.nextInt(8)));\n                    loot.add(new ItemStack(Material.SHROOMLIGHT, 3 + random.nextInt(6)));\n                }\n            }\n        }\n    }\n    \n    /**\n     * Get biome AND planet type specific treasure multiplier\n     */\n    private static double getBiomeTreasureMultiplier(BiomeType biome, PlanetType planetType) {\n        // Planet type base multiplier\n        double baseMultiplier = switch (planetType) {\n            case CRYSTAL -> 2.5;\n            case LAVA -> 2.0;\n            case SHADOW -> 1.8;\n            case ICE -> 1.5;\n            default -> 1.0;\n        };\n\n        // Biome specific bonus\n        return switch (biome) {\n            case CRYSTAL_FOREST, CRYSTALLINE -> baseMultiplier * 1.2;\n            case LAVA_OCEAN, MAGMA_CAVES -> baseMultiplier * 1.15;\n            case VOID, CHORUS_LAND -> baseMultiplier * 1.1;\n            default -> baseMultiplier;\n        };\n    }\n\n    /**\n     * Find surface level within planet bounds - ensures treasures are placed on solid ground\n     */\n    private static int findSurfaceLevelWithinPlanet(int cx, int cy, int cz, int x, int z, int radius, Random random) {\n        // Start from top of planet and raycast downward to find first solid block\n        int searchStartY = cy + radius + 5;\n        int searchEndY = cy - radius;\n\n        for (int y = searchStartY; y >= searchEndY; y--) {\n            // Check if position is within planet bounds\n            double distanceFromCenter = Math.sqrt(\n                (x - cx) * (x - cx) +\n                (y - cy) * (y - cy) +\n                (z - cz) * (z - cz)\n            );\n\n            // Must be on or near surface (within 3 blocks of radius)\n            if (distanceFromCenter >= radius - 3 && distanceFromCenter <= radius + 1) {\n                return y; // Found surface level\n            }\n        }\n\n        return -1; // No suitable surface found\n    }\n\n    /**\n     * CONFIG'DEN TREASURE TİPİ SEÇ - Gezegen türüne göre\n     */\n    private static TreasureType getTreasureTypeFromConfig(PlanetType planetType, Random random) {\n        SkyOrbs plugin = SkyOrbs.getInstance();\n        String planetTypeKey = planetType.name().toLowerCase();\n        String configPath = \"treasures.planetTypes.\" + planetTypeKey + \".treasureTypes\";\n\n        // Config'den olasılıkları oku\n        double commonProb = plugin.getConfig().getDouble(configPath + \".common\", 0.55);\n        double uncommonProb = plugin.getConfig().getDouble(configPath + \".uncommon\", 0.25);\n        double rareProb = plugin.getConfig().getDouble(configPath + \".rare\", 0.12);\n        double epicProb = plugin.getConfig().getDouble(configPath + \".epic\", 0.06);\n        double legendaryProb = plugin.getConfig().getDouble(configPath + \".legendary\", 0.02);\n\n        // Weighted random selection\n        double rand = random.nextDouble();\n        double total = 0;\n\n        if ((total += commonProb) > rand) return TreasureType.COMMON;\n        if ((total += uncommonProb) > rand) return TreasureType.UNCOMMON;\n        if ((total += rareProb) > rand) return TreasureType.RARE;\n        if ((total += epicProb) > rand) return TreasureType.EPIC;\n        if ((total += legendaryProb) > rand) return TreasureType.LEGENDARY;\n\n        // Fallback\n        return TreasureType.COMMON;\n    }\n\n    /**\n     * Get biome-specific legendary treasure bonus\n     */\n    private static double getBiomeLegendaryBonus(BiomeType biome) {\n        return switch (biome) {\n            case CRYSTAL_FOREST -> 3.0; // Crystal planets have best loot\n            case VOID, LAVA_OCEAN, GLOWSTONE_CAVERN -> 2.5;\n            case CORRUPTED, CHORUS_LAND -> 2.0;\n            case TOXIC_SWAMP, MAGMA_CAVES -> 1.5;\n            default -> 1.0;\n        };\n    }\n    \n    /**\n     * Hazine türleri\n     */\n    public enum TreasureType {\n        COMMON,      // %55 - Temel itemler\n        UNCOMMON,    // %25 - İyi itemler\n        RARE,        // %12 - Nadir itemler\n        EPIC,        // %6 - Epik itemler\n        LEGENDARY    // %2 - Efsanevi itemler\n    }\n    \n    /**\n     * Hazine lokasyonu\n     */\n    public static class TreasureLocation {\n        public final int x, y, z;\n        public final BiomeType biome;\n        public final TreasureType type;\n        \n        public TreasureLocation(int x, int y, int z, BiomeType biome, TreasureType type) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.biome = biome;\n            this.type = type;\n        }\n    }\n}","size_bytes":20280},"src/main/java/com/skyorbs/shapes/PlanetShape.java":{"content":"package com.skyorbs.shapes;\n\npublic interface PlanetShape {\n    \n    boolean isBlockPart(int dx, int dy, int dz, int radius, long seed);\n    \n    String getName();\n    \n    double getDeformationFactor();\n    \n    String getDisplayName();\n}\n","size_bytes":240},"src/main/java/com/skyorbs/events/CelestialEvents.java":{"content":"package com.skyorbs.events;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Location;\nimport org.bukkit.Material;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Player;\nimport org.bukkit.scheduler.BukkitRunnable;\n\nimport java.util.*;\n\npublic class CelestialEvents {\n\n    private final SkyOrbs plugin;\n    private final Random random = new Random();\n    private final Map<UUID, ActiveEvent> activeEvents = new HashMap<UUID, ActiveEvent>();\n\n    public CelestialEvents(SkyOrbs plugin) {\n        this.plugin = plugin;\n        startEventScheduler();\n    }\n\n    private void startEventScheduler() {\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                try {\n                    // Check for new events every 5 minutes\n                    List<Orb> planets = plugin.getDatabaseManager().getAllOrbs();\n                    for (Orb orb : planets) {\n                        if (random.nextDouble() < 0.05) { // 5% chance per planet per check\n                            triggerRandomEvent(orb);\n                        }\n                    }\n                } catch (Exception e) {\n                    plugin.logError(\"Event scheduler error\", e);\n                }\n            }\n        }.runTaskTimer(plugin, 0L, 6000L); // Every 5 minutes\n    }\n\n    public void triggerRandomEvent(Orb orb) {\n        if (activeEvents.containsKey(orb.getId())) {\n            return; // Already has an active event\n        }\n\n        CelestialEventType eventType = getRandomEventType(orb);\n        if (eventType != null) {\n            startEvent(orb, eventType);\n        }\n    }\n\n    public void triggerSpecificEvent(Orb orb, CelestialEventType eventType) {\n        if (!activeEvents.containsKey(orb.getId())) {\n            startEvent(orb, eventType);\n        }\n    }\n\n    private CelestialEventType getRandomEventType(Orb orb) {\n        List<CelestialEventType> availableEvents = new ArrayList<CelestialEventType>();\n\n        // Base events for all planets\n        availableEvents.add(CelestialEventType.METEOR_SHOWER);\n        availableEvents.add(CelestialEventType.SOLAR_FLARE);\n\n        // Planet-specific events\n        PlanetType type = orb.getPlanetType();\n        switch (type) {\n            case TERRESTRIAL -> {\n                availableEvents.add(CelestialEventType.RAINFALL);\n                availableEvents.add(CelestialEventType.MAGNETIC_STORM);\n                if (orb.getBiosphereLevel() >= 3) {\n                    availableEvents.add(CelestialEventType.BLOSSOMING);\n                }\n            }\n            case GAS -> {\n                availableEvents.add(CelestialEventType.GAS_STORM);\n                availableEvents.add(CelestialEventType.AURORA);\n            }\n            case LAVA -> {\n                availableEvents.add(CelestialEventType.VOLCANIC_ERUPTION);\n                availableEvents.add(CelestialEventType.LAVA_RAIN);\n            }\n            case ICE -> {\n                availableEvents.add(CelestialEventType.BLIZZARD);\n                availableEvents.add(CelestialEventType.AURORA);\n            }\n            case CRYSTAL -> {\n                availableEvents.add(CelestialEventType.CRYSTAL_STORM);\n                availableEvents.add(CelestialEventType.ENERGY_SURGE);\n            }\n            case SHADOW -> {\n                availableEvents.add(CelestialEventType.SHADOW_FOG);\n                availableEvents.add(CelestialEventType.NEBULA);\n            }\n            case TOXIC -> {\n                availableEvents.add(CelestialEventType.TOXIC_FOG);\n                availableEvents.add(CelestialEventType.ACID_RAIN);\n            }\n        }\n\n        // Core level based events\n        if (orb.getCoreLevel() >= 5) {\n            availableEvents.add(CelestialEventType.CELESTIAL_ALIGNMENT);\n        }\n\n        if (orb.getCoreLevel() >= 8) {\n            availableEvents.add(CelestialEventType.DIMENSIONAL_RIFT);\n        }\n\n        return availableEvents.get(random.nextInt(availableEvents.size()));\n    }\n\n    private void startEvent(Orb orb, CelestialEventType eventType) {\n        ActiveEvent event = new ActiveEvent(orb, eventType);\n        activeEvents.put(orb.getId(), event);\n\n        // Announce event to players on the planet\n        announceEvent(orb, eventType);\n\n        // Start event effects\n        event.start();\n\n        // Schedule event end\n        new BukkitRunnable() {\n            @Override\n            public void run() {\n                endEvent(orb.getId());\n            }\n        }.runTaskLater(plugin, eventType.getDuration() * 20L); // Convert seconds to ticks\n    }\n\n    private void announceEvent(Orb orb, CelestialEventType eventType) {\n        String message = String.format(\"§e🌟 Gezegen §b%s §eüzerinde §a%s §eolayı başladı!\",\n                                     orb.getName(), eventType.getDisplayName());\n\n        // Send to all players on the planet\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world != null) {\n            for (Player player : world.getPlayers()) {\n                Location centerLoc = new Location(world, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ());\n                double distance = player.getLocation().distance(centerLoc);\n                if (distance <= orb.getRadius() + 50) {\n                    player.sendMessage(message);\n                    player.sendMessage(\"§7\" + eventType.getDescription());\n                }\n            }\n        }\n    }\n\n    private void endEvent(UUID orbId) {\n        ActiveEvent event = activeEvents.remove(orbId);\n        if (event != null) {\n            event.end();\n            // Announce event end\n            try {\n                Orb orb = plugin.getDatabaseManager().getOrb(orbId);\n                if (orb != null) {\n                    String message = String.format(\"§e🌟 Gezegen §b%s §eüzerindeki §a%s §eolayı sona erdi!\",\n                                                  orb.getName(), event.eventType.getDisplayName());\n                    announceToPlanet(orb, message);\n                }\n            } catch (Exception e) {\n                plugin.logError(\"Event end announcement error\", e);\n            }\n        }\n    }\n\n    private void announceToPlanet(Orb orb, String message) {\n        World world = Bukkit.getWorld(orb.getWorldName());\n        if (world != null) {\n            for (Player player : world.getPlayers()) {\n                Location centerLoc = new Location(world, orb.getCenterX(), orb.getCenterY(), orb.getCenterZ());\n                double distance = player.getLocation().distance(centerLoc);\n                if (distance <= orb.getRadius() + 50) {\n                    player.sendMessage(message);\n                }\n            }\n        }\n    }\n\n    public boolean hasActiveEvent(UUID orbId) {\n        return activeEvents.containsKey(orbId);\n    }\n\n    public CelestialEventType getActiveEventType(UUID orbId) {\n        ActiveEvent event = activeEvents.get(orbId);\n        return event != null ? event.eventType : null;\n    }\n\n    public enum CelestialEventType {\n        // Universal Events\n        METEOR_SHOWER(\"Göktaşı Yağmuru\", \"Gökyüzünden göktaşları yağyor!\", 300, Material.FIREWORK_ROCKET),\n        SOLAR_FLARE(\"Güneş Patlaması\", \"Güneşten gelen radyasyon dalgası!\", 180, Material.SUNFLOWER),\n\n        // Terrestrial Events\n        RAINFALL(\"Yağmur\", \"Canlandırıcı yağmur başlıyor!\", 600, Material.WATER_BUCKET),\n        MAGNETIC_STORM(\"Manyetik Fırtına\", \"Manyetik alanlar nadir mineraller çıkarıyor!\", 480, Material.IRON_INGOT),\n        BLOSSOMING(\"Çiçek Açma\", \"Gezegen çiçeklerle kaplanıyor!\", 900, Material.POPPY),\n\n        // Gas Events\n        GAS_STORM(\"Gaz Fırtınası\", \"Şiddetli gaz fırtınaları!\", 420, Material.BLUE_WOOL),\n        AURORA(\"Aurora\", \"Kutup ışıkları dans ediyor!\", 720, Material.LIGHT_BLUE_WOOL),\n\n        // Lava Events\n        VOLCANIC_ERUPTION(\"Volkanik Patlama\", \"Volkanlar uyanıyor!\", 360, Material.LAVA_BUCKET),\n        LAVA_RAIN(\"Lav Yağmuru\", \"Gökyüzünden lav damlaları!\", 300, Material.MAGMA_BLOCK),\n\n        // Ice Events\n        BLIZZARD(\"Kar Fırtınası\", \"Şiddetli kar fırtınası!\", 480, Material.SNOW_BLOCK),\n\n        // Crystal Events\n        CRYSTAL_STORM(\"Kristal Fırtınası\", \"Kristaller gökyüzünden yağıyor!\", 540, Material.AMETHYST_SHARD),\n        ENERGY_SURGE(\"Enerji Artışı\", \"Kristal enerji seviyesi yükseliyor!\", 600, Material.AMETHYST_BLOCK),\n\n        // Shadow Events\n        SHADOW_FOG(\"Gölge Sisi\", \"Gölge sisleri her yeri kaplıyor!\", 420, Material.BLACK_WOOL),\n        NEBULA(\"Nebula\", \"Gezegen nebulaya sarılıyor!\", 780, Material.PURPLE_WOOL),\n\n        // Toxic Events\n        TOXIC_FOG(\"Zehirli Sis\", \"Zehirli sisler yayılıyor!\", 360, Material.SLIME_BLOCK),\n        ACID_RAIN(\"Asit Yağmuru\", \"Asit yağmuru başlıyor!\", 480, Material.GREEN_WOOL),\n\n        // Advanced Events\n        CELESTIAL_ALIGNMENT(\"Gök Cisimleri Hizalama\", \"Nadir kozmik olay!\", 1200, Material.NETHER_STAR),\n        DIMENSIONAL_RIFT(\"Boyutsal Yarık\", \"Başka boyutlardan enerji akıyor!\", 900, Material.END_PORTAL_FRAME);\n\n        private final String displayName;\n        private final String description;\n        private final int duration; // in seconds\n        private final Material icon;\n\n        CelestialEventType(String displayName, String description, int duration, Material icon) {\n            this.displayName = displayName;\n            this.description = description;\n            this.duration = duration;\n            this.icon = icon;\n        }\n\n        public String getDisplayName() { return displayName; }\n        public String getDescription() { return description; }\n        public int getDuration() { return duration; }\n        public Material getIcon() { return icon; }\n    }\n\n    private class ActiveEvent {\n        private final Orb orb;\n        private final CelestialEventType eventType;\n        private final long startTime;\n        private BukkitRunnable effectTask;\n\n        public ActiveEvent(Orb orb, CelestialEventType eventType) {\n            this.orb = orb;\n            this.eventType = eventType;\n            this.startTime = System.currentTimeMillis();\n        }\n\n        public void start() {\n            // Start event-specific effects\n            effectTask = new BukkitRunnable() {\n                @Override\n                public void run() {\n                    applyEventEffects();\n                }\n            };\n            effectTask.runTaskTimer(plugin, 0L, 20L); // Every second\n        }\n\n        public void end() {\n            if (effectTask != null) {\n                effectTask.cancel();\n            }\n            // Apply end effects if any\n            applyEventEndEffects();\n        }\n\n        private void applyEventEffects() {\n            World world = Bukkit.getWorld(orb.getWorldName());\n            if (world == null) return;\n\n            switch (eventType) {\n                case METEOR_SHOWER -> {\n                    // Spawn occasional firework effects\n                    if (random.nextDouble() < 0.1) {\n                        // Simulate meteor effects\n                    }\n                }\n                case RAINFALL -> {\n                    // Increase random ticks for plant growth\n                    // This would require custom tick handling\n                }\n                case MAGNETIC_STORM -> {\n                    // Occasionally spawn rare ores\n                    if (random.nextDouble() < 0.05) {\n                        spawnRareOre(orb, world);\n                    }\n                }\n                // Add more event effects...\n            }\n        }\n\n        private void applyEventEndEffects() {\n            // Apply effects when event ends\n            switch (eventType) {\n                case MAGNETIC_STORM -> {\n                    // Give bonus XP for surviving the storm\n                    // plugin.getEvolutionManager().gainXpFromActivity(orb, \"magnetic_storm_survival\", 500);\n                }\n                case BLOSSOMING -> {\n                    // Permanent flora boost\n                    // plugin.getBiosphereManager().updateBiosphere(orb, \"blossoming\");\n                }\n                // Add more end effects...\n            }\n        }\n\n        private void spawnRareOre(Orb orb, World world) {\n            int x = orb.getCenterX() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int z = orb.getCenterZ() + random.nextInt(orb.getRadius() * 2) - orb.getRadius();\n            int y = orb.getCenterY() + random.nextInt(orb.getRadius()) - orb.getRadius() / 2;\n\n            Block block = world.getBlockAt(x, y, z);\n            if (block.getType() == Material.STONE || block.getType() == Material.DEEPSLATE) {\n                Material ore = random.nextDouble() < 0.8 ? Material.DIAMOND_ORE : Material.EMERALD_ORE;\n                block.setType(ore);\n            }\n        }\n    }\n}","size_bytes":13005},"src/main/java/com/skyorbs/shapes/impl/MotorcycleShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class MotorcycleShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Motorsiklet şekli - frame, wheels, handlebars\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main frame (ana şasi)\n        if (Math.abs(y) <= 0.08) {\n            return Math.abs(x) <= 0.5 && Math.abs(z) <= 0.1;\n        }\n\n        // Seat (sele)\n        if (y > 0.08 && y < 0.2 && Math.abs(x) <= 0.3) {\n            return Math.abs(z) <= 0.15;\n        }\n\n        // Handlebars (direksiyon)\n        if (x > 0.3 && x < 0.5 && Math.abs(y - 0.1) <= 0.05) {\n            return Math.abs(z) <= 0.2;\n        }\n\n        // Front wheel (ön tekerlek)\n        if (x > 0.4 && Math.abs(y + 0.1) <= 0.12) {\n            return Math.abs(z) <= 0.12;\n        }\n\n        // Rear wheel (arka tekerlek)\n        if (x < -0.3 && Math.abs(y + 0.1) <= 0.12) {\n            return Math.abs(z) <= 0.12;\n        }\n\n        // Engine (motor)\n        if (Math.abs(x) <= 0.2 && y < -0.05 && y > -0.15) {\n            return Math.abs(z) <= 0.12;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"MOTORCYCLE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Motorsiklet\";\n    }\n}","size_bytes":1668},"src/main/java/com/skyorbs/shapes/impl/AsteroidFieldShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\nimport java.util.Random;\n\n/**\n * ASTEROID_FIELD SHAPE - Asteroid alanı (çoklu küçük kümeler)\n * Creates multiple small asteroid clusters instead of a single body\n */\npublic class AsteroidFieldShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        Random random = new Random(seed);\n        \n        // Create multiple small asteroid clusters\n        int clusterCount = 5;\n        \n        for (int i = 0; i < clusterCount; i++) {\n            Random clusterRandom = new Random(seed + i * 1000);\n            \n            // Cluster center offset\n            int offsetX = clusterRandom.nextInt(radius) - radius/2;\n            int offsetY = clusterRandom.nextInt(radius) - radius/2;\n            int offsetZ = clusterRandom.nextInt(radius) - radius/2;\n            \n            int cdx = dx - offsetX;\n            int cdy = dy - offsetY;\n            int cdz = dz - offsetZ;\n            \n            double clusterDist = Math.sqrt(cdx * cdx + cdy * cdy + cdz * cdz);\n            double clusterSize = radius * 0.3;\n            \n            // Rough asteroid surface\n            double noise = NoiseGenerator.getNoise(cdx, cdy, cdz, seed + i, 0.3);\n            double roughness = 0.6 + 0.4 * Math.abs(noise);\n            \n            if (clusterDist <= clusterSize * roughness) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    @Override\n    public String getName() { \n        return \"ASTEROID_FIELD\"; \n    }\n\n    @Override\n    public double getDeformationFactor() { \n        return 0.5; \n    }\n\n    @Override\n    public String getDisplayName() { \n        return \"Asteroid Alanı\"; \n    }\n}\n","size_bytes":1829},"src/main/java/com/skyorbs/shapes/impl/HeartShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HeartShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kalp şekli - 3D kalp formülü\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // 3D kalp formülü\n        double heart = Math.pow(x*x + 2.25*y*y + z*z - 1, 3) - x*x*z*z*z;\n        return heart <= 0;\n    }\n\n    @Override\n    public String getName() {\n        return \"HEART\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kalp\";\n    }\n}","size_bytes":904},"src/main/java/com/skyorbs/shapes/impl/RocketShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class RocketShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Roket şekli - nose cone, body, fins, engine\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Nose cone (üst kısım konik)\n        if (y > 0.5) {\n            double noseRadius = 0.8 - (y - 0.5) * 1.6; // Uçta sivri\n            return Math.sqrt(x*x + z*z) <= noseRadius;\n        }\n\n        // Main body (silindirik)\n        if (y > -0.3 && y <= 0.5) {\n            return Math.sqrt(x*x + z*z) <= 0.4;\n        }\n\n        // Engine section (alt kısım geniş)\n        if (y <= -0.3) {\n            return Math.sqrt(x*x + z*z) <= 0.5;\n        }\n\n        // Fins (kanatlar)\n        if (Math.abs(y) <= 0.2) {\n            if ((Math.abs(x) <= 0.6 && Math.abs(z) <= 0.1) ||\n                (Math.abs(x) <= 0.1 && Math.abs(z) <= 0.6)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"ROCKET\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Roket\";\n    }\n}","size_bytes":1512},"src/main/java/com/skyorbs/shapes/impl/WindsurfBoardShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class WindsurfBoardShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Rüzgar sörfü tahtası şekli - board, mast, sail\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main board (ana tahta)\n        if (Math.abs(y) <= 0.03) {\n            // Wider at back, narrower at front\n            double width = 0.25 - x * 0.1;\n            return Math.abs(z) <= width && x >= -0.6 && x <= 0.4;\n        }\n\n        // Mast (direk)\n        if (Math.abs(x + 0.2) <= 0.03 && Math.abs(z) <= 0.03 && y >= 0.03 && y <= 0.8) {\n            return true;\n        }\n\n        // Sail (yelken)\n        if (y >= 0.3 && y <= 0.7) {\n            // Main sail body\n            if (Math.abs(x + 0.1) <= 0.02 && Math.abs(z) <= 0.3) return true;\n            // Sail curve\n            double sailCurve = Math.sin((y - 0.3) * Math.PI / 0.4) * 0.1;\n            if (Math.abs(x - sailCurve) <= 0.02 && Math.abs(z) <= 0.3) return true;\n        }\n\n        // Boom (boom)\n        if (y >= 0.2 && y <= 0.25 && Math.abs(z) <= 0.35) {\n            return Math.abs(x + 0.1) <= 0.02;\n        }\n\n        // Daggerboard (sürekli)\n        if (Math.abs(x) <= 0.02 && Math.abs(z) <= 0.02 && y <= -0.05) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"WINDSURF_BOARD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Rüzgar Sörfü Tahtası\";\n    }\n}","size_bytes":1885},"src/main/java/com/skyorbs/utils/Constants.java":{"content":"package com.skyorbs.utils;\n\nimport org.bukkit.Particle;\nimport org.bukkit.Sound;\n\n/**\n * Global constants for SkyOrbs plugin\n * Prevents magic numbers and centralizes configuration\n */\npublic class Constants {\n    \n    // ============================================\n    // PLANET SIZE CONSTANTS\n    // ============================================\n    public static final int MIN_PLANET_RADIUS = 15;\n    public static final int MAX_PLANET_RADIUS = 100;\n    public static final int DEFAULT_PLANET_RADIUS = 35;\n    \n    // ============================================\n    // GENERATION CONSTANTS\n    // ============================================\n    public static final double ORE_SCALE_FACTOR = 0.001;\n    public static final int MIN_ORE_VEIN_COUNT = 5;\n    public static final double HOLLOW_INNER_RADIUS_RATIO = 0.6;\n    public static final int DEFAULT_SHELL_THICKNESS = 5;\n    \n    // ============================================\n    // PERFORMANCE CONSTANTS\n    // ============================================\n    public static final int DEFAULT_BLOCKS_PER_BATCH = 1000;\n    public static final int DEFAULT_BATCHES_PER_TICK = 4;\n    public static final int MAX_CONCURRENT_GENERATIONS = 2;\n    public static final double TPS_THRESHOLD = 18.0;\n    \n    // ============================================\n    // SOUND EFFECTS\n    // ============================================\n    public static final Sound SOUND_PLANET_CREATE = Sound.ENTITY_ENDER_DRAGON_GROWL;\n    public static final Sound SOUND_TELEPORT = Sound.ENTITY_ENDERMAN_TELEPORT;\n    public static final Sound SOUND_SUCCESS = Sound.ENTITY_PLAYER_LEVELUP;\n    public static final Sound SOUND_ERROR = Sound.ENTITY_VILLAGER_NO;\n    public static final Sound SOUND_PROGRESS = Sound.BLOCK_NOTE_BLOCK_PLING;\n    \n    // Sound volumes and pitches\n    public static final float SOUND_VOLUME_NORMAL = 1.0f;\n    public static final float SOUND_VOLUME_QUIET = 0.5f;\n    public static final float SOUND_PITCH_NORMAL = 1.0f;\n    public static final float SOUND_PITCH_HIGH = 1.5f;\n    public static final float SOUND_PITCH_LOW = 0.8f;\n    \n    // ============================================\n    // PARTICLE EFFECTS\n    // ============================================\n    public static final Particle PARTICLE_PLANET_CREATE = Particle.PORTAL;\n    public static final Particle PARTICLE_TELEPORT = Particle.DRAGON_BREATH;\n    public static final Particle PARTICLE_SUCCESS = Particle.TOTEM_OF_UNDYING;\n    public static final Particle PARTICLE_PROGRESS = Particle.END_ROD;\n    \n    // Particle counts\n    public static final int PARTICLE_COUNT_LARGE = 100;\n    public static final int PARTICLE_COUNT_MEDIUM = 50;\n    public static final int PARTICLE_COUNT_SMALL = 20;\n    \n    // ============================================\n    // MESSAGE SYMBOLS\n    // ============================================\n    public static final String SYMBOL_SUCCESS = \"✓\";\n    public static final String SYMBOL_ERROR = \"✗\";\n    public static final String SYMBOL_INFO = \"!\";\n    public static final String SYMBOL_WARNING = \"⚠\";\n    public static final String SYMBOL_ARROW = \"→\";\n    public static final String SYMBOL_BULLET = \"•\";\n    \n    // Progress bar characters\n    public static final String PROGRESS_FILLED = \"█\";\n    public static final String PROGRESS_EMPTY = \"░\";\n    public static final int PROGRESS_BAR_LENGTH = 20;\n    \n    // ============================================\n    // COLOR CODES\n    // ============================================\n    public static final String COLOR_SUCCESS = \"§a\";\n    public static final String COLOR_ERROR = \"§c\";\n    public static final String COLOR_INFO = \"§e\";\n    public static final String COLOR_WARNING = \"§6\";\n    public static final String COLOR_PRIMARY = \"§b\";\n    public static final String COLOR_SECONDARY = \"§7\";\n    public static final String COLOR_ACCENT = \"§d\";\n    public static final String COLOR_RESET = \"§r\";\n    public static final String COLOR_BOLD = \"§l\";\n    \n    // ============================================\n    // TIMING CONSTANTS\n    // ============================================\n    public static final int TICKS_PER_SECOND = 20;\n    public static final int TELEPORT_DELAY_TICKS = 5;\n    public static final int GENERATION_TIMEOUT_SECONDS = 300; // 5 minutes\n    \n    // ============================================\n    // VALIDATION CONSTANTS\n    // ============================================\n    public static final int MAX_PLANET_NAME_LENGTH = 32;\n    public static final int MIN_PLANET_NAME_LENGTH = 3;\n    public static final String PLANET_NAME_PATTERN = \"^[a-zA-Z0-9_-]+$\";\n    \n    // Private constructor to prevent instantiation\n    private Constants() {\n        throw new AssertionError(\"Cannot instantiate Constants class\");\n    }\n}\n","size_bytes":4768},"src/main/java/com/skyorbs/shapes/impl/RingShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class RingShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        int thickness = 3;\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        return Math.abs(dy) <= thickness && distance <= radius;\n    }\n    \n    @Override\n    public String getName() {\n        return \"RING\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Halka\";\n    }\n}\n","size_bytes":628},"src/main/java/com/skyorbs/shapes/impl/HandShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HandShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // El şekli - palm, fingers\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Palm (avuç içi)\n        if (y > -0.3 && y < 0.2) {\n            return Math.sqrt(x*x + z*z) <= 0.4;\n        }\n\n        // Thumb (baş parmak)\n        if (x < -0.1 && x > -0.4 && y > 0.0 && y < 0.5) {\n            return Math.abs(z) <= 0.15;\n        }\n\n        // Fingers (diğer parmaklar)\n        for (int i = 0; i < 4; i++) {\n            double fingerX = -0.3 + i * 0.2;\n            if (Math.abs(x - fingerX) <= 0.08 && y > 0.1 && y < 0.6) {\n                return Math.abs(z) <= 0.12;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"HAND\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"El\";\n    }\n}","size_bytes":1310},"src/main/java/com/skyorbs/shapes/impl/ScooterShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ScooterShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Scooter şekli - platform, handlebar, wheel\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main platform (ana platform)\n        if (Math.abs(y) <= 0.05) {\n            return Math.abs(x) <= 0.3 && Math.abs(z) <= 0.2;\n        }\n\n        // Handlebar post (direksiyon direği)\n        if (Math.abs(x - 0.25) <= 0.03 && Math.abs(z) <= 0.03 && y >= 0.05 && y <= 0.25) {\n            return true;\n        }\n\n        // Handlebars (direksiyon)\n        if (y >= 0.25 && y <= 0.3 && Math.abs(x - 0.25) <= 0.08) {\n            return Math.abs(z) <= 0.15;\n        }\n\n        // Single wheel (tek tekerlek)\n        double wheelDist = Math.sqrt(x*x + (y + 0.1)*(y + 0.1));\n        if (wheelDist <= 0.12) return true;\n\n        // Footrests (ayak dayama)\n        if (Math.abs(y + 0.02) <= 0.03 && Math.abs(z) <= 0.25 && Math.abs(x) <= 0.15) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SCOOTER\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Scooter\";\n    }\n}","size_bytes":1597},"src/main/java/com/skyorbs/shapes/impl/TelephoneShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TelephoneShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Telefon şekli - handset, cord, base\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Telephone base (taban)\n        if (y > -0.4 && y < -0.1) {\n            return Math.abs(x) <= 0.6 && Math.abs(z) <= 0.4;\n        }\n\n        // Handset body (ahize gövde)\n        if (y >= -0.1 && y < 0.3) {\n            return Math.abs(x) <= 0.2 && Math.abs(z) <= 0.1;\n        }\n\n        // Handset mouthpiece (mikrofon kısmı)\n        if (y >= 0.3 && y < 0.5) {\n            return Math.abs(x) <= 0.15 && Math.abs(z) <= 0.08;\n        }\n\n        // Cord (kablo) - spiral\n        if (Math.abs(x) <= 0.05 && Math.abs(z) <= 0.05 && y >= -0.1 && y < 0.3) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"TELEPHONE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Telefon\";\n    }\n}","size_bytes":1410},"src/main/java/com/skyorbs/shapes/impl/BlobShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\npublic class BlobShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.15);\n        double deformation = 1 + 0.3 * noise;\n        return distance <= radius * deformation;\n    }\n    \n    @Override\n    public String getName() {\n        return \"BLOB\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.3;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Ameba\";\n    }\n}\n","size_bytes":755},"src/main/java/com/skyorbs/shapes/impl/TeapotShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TeapotShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Çaydanlık şekli - body, spout, handle, lid\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Teapot body - spherical bottom, cylindrical top\n        if (y < 0.2) {\n            double bodyRadius = Math.sqrt(x*x + z*z);\n            return bodyRadius <= 0.5;\n        }\n\n        // Teapot neck (boyun)\n        if (y >= 0.2 && y < 0.6) {\n            return Math.abs(x) <= 0.15 && Math.abs(z) <= 0.15;\n        }\n\n        // Spout (hortum)\n        if (z > 0.1 && z < 0.5 && Math.abs(y - 0.3) <= 0.1) {\n            return Math.abs(x) <= 0.1;\n        }\n\n        // Handle (kulak)\n        if (z < -0.1 && z > -0.4 && Math.abs(y - 0.3) <= 0.1) {\n            return Math.abs(x) <= 0.1;\n        }\n\n        // Lid (kapak)\n        if (y >= 0.6) {\n            double lidRadius = Math.sqrt(x*x + z*z);\n            return lidRadius <= 0.2;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"TEAPOT\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Çaydanlık\";\n    }\n}","size_bytes":1570},"src/main/java/com/skyorbs/features/OreProfile.java":{"content":"// src/main/java/com/skyorbs/features/OreProfile.java\npackage com.skyorbs.features;\n\nimport com.skyorbs.biomes.BiomeType;\nimport org.bukkit.Material;\nimport java.util.*;\n\n/**\n * Biome-specific ore generation profiles\n * Each biome has unique ore composition\n */\npublic class OreProfile {\n    \n    private final BiomeType biome;\n    private final List<OreConfig> ores;\n    private final String description;\n    \n    public OreProfile(BiomeType biome, String description) {\n        this.biome = biome;\n        this.description = description;\n        this.ores = new ArrayList<>();\n    }\n    \n    public OreProfile addOre(Material type, Material deepslateVariant, \n                            double chance, int minVein, int maxVein) {\n        ores.add(new OreConfig(type, deepslateVariant, chance, new int[]{minVein, maxVein}));\n        return this;\n    }\n    \n    public List<OreConfig> getOres() {\n        return ores;\n    }\n    \n    public String getDescription() {\n        return description;\n    }\n    \n    public BiomeType getBiome() {\n        return biome;\n    }\n    \n    public boolean hasOres() {\n        return !ores.isEmpty();\n    }\n    \n    /**\n     * Get all biome-specific ore profiles\n     */\n    public static Map<BiomeType, OreProfile> getAllProfiles() {\n        Map<BiomeType, OreProfile> profiles = new HashMap<>();\n        \n        // ============================================\n        // EARTH-LIKE BIOMES - Full ore set\n        // ============================================\n        \n        // FOREST - Balanced, all vanilla ores\n        profiles.put(BiomeType.FOREST, new OreProfile(BiomeType.FOREST, \"Dengeli dünya benzeri - Tüm madenler\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.35, 3, 8)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.30, 2, 6)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.25, 3, 9)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.12, 2, 5)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.10, 3, 7)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.08, 2, 6)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.05, 1, 4)\n            .addOre(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.02, 1, 2)\n        );\n        \n        // PLAINS - Similar to forest\n        profiles.put(BiomeType.PLAINS, profiles.get(BiomeType.FOREST));\n        \n        // JUNGLE - More emeralds\n        profiles.put(BiomeType.JUNGLE, new OreProfile(BiomeType.JUNGLE, \"Orman - Daha fazla zümrüt\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.35, 3, 8)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.30, 2, 6)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.25, 3, 9)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.12, 2, 5)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.10, 3, 7)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.08, 2, 6)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.04, 1, 3)\n            .addOre(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.08, 1, 3) // 4x more emeralds!\n        );\n        \n        // SAVANNA - More gold and copper\n        profiles.put(BiomeType.SAVANNA, new OreProfile(BiomeType.SAVANNA, \"Savan - Altın ve bakır zengin\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.30, 3, 7)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.25, 2, 5)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.35, 4, 10) // More copper!\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.20, 3, 7) // More gold!\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.08, 2, 5)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.06, 2, 4)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.04, 1, 3)\n        );\n        \n        // TAIGA - Balanced\n        profiles.put(BiomeType.TAIGA, profiles.get(BiomeType.FOREST));\n        \n        // MEADOW - Balanced\n        profiles.put(BiomeType.MEADOW, profiles.get(BiomeType.FOREST));\n        \n        // ============================================\n        // DESERT BIOMES - Less coal, more gold/copper\n        // ============================================\n        \n        // DESERT\n        profiles.put(BiomeType.DESERT, new OreProfile(BiomeType.DESERT, \"Çöl - Altın ve bakır, az kömür\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.15, 2, 4) // Less coal\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.25, 2, 5)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.40, 5, 12) // Lots of copper!\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.25, 3, 8) // Lots of gold!\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.12, 3, 6)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.10, 3, 7)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.04, 1, 3)\n        );\n        \n        // BADLANDS - Gold paradise\n        profiles.put(BiomeType.BADLANDS, new OreProfile(BiomeType.BADLANDS, \"Kötü Toprak - Altın cenneti\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.20, 2, 5)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.30, 2, 6)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.35, 4, 10)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.40, 4, 12) // GOLD EVERYWHERE!\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.15, 3, 7)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.05, 1, 3)\n        );\n        \n        // CANYON - Similar to badlands\n        profiles.put(BiomeType.CANYON, profiles.get(BiomeType.BADLANDS));\n        \n        // ============================================\n        // ICE BIOMES - Diamonds and lapis\n        // ============================================\n        \n        // FROZEN_TUNDRA\n        profiles.put(BiomeType.FROZEN_TUNDRA, new OreProfile(BiomeType.FROZEN_TUNDRA, \"Donmuş Tundra - Elmas ve lapis\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.30, 3, 7)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.35, 3, 7) // More iron\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.20, 2, 6)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.20, 4, 10) // Lots of lapis!\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.10, 2, 5) // More diamonds!\n            .addOre(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.03, 1, 2)\n        );\n        \n        // ICE_SPIKES - Similar\n        profiles.put(BiomeType.ICE_SPIKES, profiles.get(BiomeType.FROZEN_TUNDRA));\n        \n        // GLACIER - Similar\n        profiles.put(BiomeType.GLACIER, profiles.get(BiomeType.FROZEN_TUNDRA));\n        \n        // ============================================\n        // VOLCANIC BIOMES - Ancient debris and gold\n        // ============================================\n        \n        // LAVA_OCEAN - Nether-like\n        profiles.put(BiomeType.LAVA_OCEAN, new OreProfile(BiomeType.LAVA_OCEAN, \"Lav Okyanusu - Ancient debris ve altın\")\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.30, 3, 8) // Lots of gold\n            .addOre(Material.ANCIENT_DEBRIS, null, 0.08, 1, 3) // Ancient debris!\n            .addOre(Material.NETHER_QUARTZ_ORE, null, 0.25, 3, 8) // Quartz\n            .addOre(Material.NETHER_GOLD_ORE, null, 0.20, 3, 7) // Nether gold\n        );\n        \n        // OBSIDIAN_PLAINS - Very rare ores\n        profiles.put(BiomeType.OBSIDIAN_PLAINS, new OreProfile(BiomeType.OBSIDIAN_PLAINS, \"Obsidyen - Çok nadir madenler\")\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.15, 2, 4)\n            .addOre(Material.ANCIENT_DEBRIS, null, 0.05, 1, 2)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.08, 1, 3)\n        );\n        \n        // MAGMA_CAVES - Similar to lava ocean\n        profiles.put(BiomeType.MAGMA_CAVES, profiles.get(BiomeType.LAVA_OCEAN));\n        \n        // ============================================\n        // ALIEN BIOMES - Unique compositions\n        // ============================================\n        \n        // CRYSTAL_FOREST - Diamonds, emeralds, amethyst\n        profiles.put(BiomeType.CRYSTAL_FOREST, new OreProfile(BiomeType.CRYSTAL_FOREST, \"Kristal Ormanı - Değerli taşlar\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.20, 2, 5)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.15, 2, 4)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.15, 3, 7)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.15, 2, 6) // Lots of diamonds!\n            .addOre(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.12, 2, 5) // Lots of emeralds!\n            .addOre(Material.AMETHYST_BLOCK, null, 0.10, 3, 8) // Amethyst clusters!\n        );\n        \n        // VOID - Almost no ores (dead planet)\n        profiles.put(BiomeType.VOID, new OreProfile(BiomeType.VOID, \"Boşluk - Ölü gezegen, çok az maden\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.05, 1, 2) // Very rare\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.03, 1, 2) // Very rare\n        );\n        \n        // CORRUPTED - Exotic ores\n        profiles.put(BiomeType.CORRUPTED, new OreProfile(BiomeType.CORRUPTED, \"Bozulmuş - Egzotik madenler\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.15, 2, 4)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.25, 4, 10) // Lots of redstone\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.20, 3, 7)\n            .addOre(Material.NETHER_QUARTZ_ORE, null, 0.15, 3, 6)\n            .addOre(Material.ANCIENT_DEBRIS, null, 0.04, 1, 2)\n        );\n        \n        // MUSHROOM_GIANT - Minimal ores\n        profiles.put(BiomeType.MUSHROOM_GIANT, new OreProfile(BiomeType.MUSHROOM_GIANT, \"Dev Mantar - Az maden\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.10, 2, 4)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.08, 1, 3)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.12, 2, 5)\n        );\n        \n        // TOXIC_SWAMP - Unusual composition\n        profiles.put(BiomeType.TOXIC_SWAMP, new OreProfile(BiomeType.TOXIC_SWAMP, \"Zehirli Bataklık - Tuhaf madenler\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.25, 3, 6)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.20, 2, 5)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.30, 4, 9)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.10, 2, 4)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.20, 3, 7)\n        );\n        \n        // GLOWSTONE_CAVERN - Glowstone and quartz\n        profiles.put(BiomeType.GLOWSTONE_CAVERN, new OreProfile(BiomeType.GLOWSTONE_CAVERN, \"Parıltı Taşı Mağarası - Quartz ve glowstone\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.15, 2, 4)\n            .addOre(Material.NETHER_QUARTZ_ORE, null, 0.35, 4, 10) // Lots of quartz\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.20, 3, 6)\n            .addOre(Material.GLOWSTONE, null, 0.25, 3, 8) // Glowstone deposits\n        );\n        \n        // CHORUS_LAND - End-like\n        profiles.put(BiomeType.CHORUS_LAND, new OreProfile(BiomeType.CHORUS_LAND, \"Chorus Diyarı - Son benzeri\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.10, 2, 3)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.08, 1, 3)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.06, 1, 2)\n        );\n        \n        // ============================================\n        // ADDITIONAL BIOMES\n        // ============================================\n        \n        // BASALTIC - Volcanic\n        profiles.put(BiomeType.BASALTIC, new OreProfile(BiomeType.BASALTIC, \"Bazaltik - Volkanik\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.20, 2, 5)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.30, 3, 7)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.18, 2, 6)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.08, 1, 3)\n        );\n        \n        // CRYSTALLINE - Like crystal forest\n        profiles.put(BiomeType.CRYSTALLINE, profiles.get(BiomeType.CRYSTAL_FOREST));\n        \n        // FUNGAL - Like mushroom\n        profiles.put(BiomeType.FUNGAL, profiles.get(BiomeType.MUSHROOM_GIANT));\n        \n        // CORAL - Underwater vibes\n        profiles.put(BiomeType.CORAL, new OreProfile(BiomeType.CORAL, \"Mercan - Su altı\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.15, 2, 4)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.20, 2, 5)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.30, 4, 9)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.25, 4, 8)\n            .addOre(Material.PRISMARINE_CRYSTALS, null, 0.20, 3, 7)\n        );\n        \n        // TOXIC - Like toxic swamp\n        profiles.put(BiomeType.TOXIC, profiles.get(BiomeType.TOXIC_SWAMP));\n        \n        // AURORA - Icy magical\n        profiles.put(BiomeType.AURORA, new OreProfile(BiomeType.AURORA, \"Aurora - Büyülü buz\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.20, 2, 5)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.25, 2, 6)\n            .addOre(Material.LAPIS_ORE, Material.DEEPSLATE_LAPIS_ORE, 0.30, 4, 10)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.12, 2, 5)\n            .addOre(Material.EMERALD_ORE, Material.DEEPSLATE_EMERALD_ORE, 0.08, 1, 3)\n        );\n        \n        // STORMY - Chaotic\n        profiles.put(BiomeType.STORMY, new OreProfile(BiomeType.STORMY, \"Fırtınalı - Kaotik\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.25, 3, 6)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.28, 3, 7)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.25, 3, 8)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.20, 3, 7)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.10, 2, 4)\n        );\n        \n        // FOGGY - Mysterious\n        profiles.put(BiomeType.FOGGY, new OreProfile(BiomeType.FOGGY, \"Sisli - Gizemli\")\n            .addOre(Material.COAL_ORE, Material.DEEPSLATE_COAL_ORE, 0.20, 2, 5)\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.22, 2, 5)\n            .addOre(Material.COPPER_ORE, Material.DEEPSLATE_COPPER_ORE, 0.20, 2, 6)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.12, 2, 4)\n            .addOre(Material.DIAMOND_ORE, Material.DEEPSLATE_DIAMOND_ORE, 0.06, 1, 3)\n        );\n        \n        // CORROSIVE - Harsh\n        profiles.put(BiomeType.CORROSIVE, new OreProfile(BiomeType.CORROSIVE, \"Aşındırıcı - Sert\")\n            .addOre(Material.IRON_ORE, Material.DEEPSLATE_IRON_ORE, 0.30, 3, 7)\n            .addOre(Material.GOLD_ORE, Material.DEEPSLATE_GOLD_ORE, 0.15, 2, 5)\n            .addOre(Material.REDSTONE_ORE, Material.DEEPSLATE_REDSTONE_ORE, 0.25, 3, 8)\n            .addOre(Material.ANCIENT_DEBRIS, null, 0.05, 1, 2)\n        );\n        \n        // LUMINOUS - Glowing\n        profiles.put(BiomeType.LUMINOUS, profiles.get(BiomeType.GLOWSTONE_CAVERN));\n        \n        return profiles;\n    }\n    \n    /**\n     * Ore configuration\n     */\n    public static class OreConfig {\n        public final Material type;\n        public final Material deepslateVariant;\n        public final double chance;\n        public final int[] veinSize;\n        \n        public OreConfig(Material type, Material deepslateVariant, double chance, int[] veinSize) {\n            this.type = type;\n            this.deepslateVariant = deepslateVariant;\n            this.chance = chance;\n            this.veinSize = veinSize;\n        }\n    }\n}","size_bytes":16609},"src/main/java/com/skyorbs/shapes/impl/ParagliderShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ParagliderShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Yamaç paraşütü şekli - wing, lines, harness\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Wing canopy (kanopi)\n        if (y > 0.2) {\n            double wingWidth = 0.8 - (y - 0.2) * 0.6;\n            double wingLength = 0.6;\n            return Math.abs(x) <= wingLength && Math.abs(z) <= wingWidth;\n        }\n\n        // Leading edge (ön kenar)\n        if (Math.abs(y - 0.25) <= 0.05) {\n            return Math.abs(x) <= 0.6 && Math.abs(z) <= 0.8;\n        }\n\n        // Lines (halatlar)\n        if (y <= 0.2 && y >= -0.3) {\n            double lineSpacing = 0.1;\n            for (int i = -3; i <= 3; i++) {\n                double lineX = i * lineSpacing;\n                if (Math.abs(x - lineX) <= 0.01 && Math.abs(z) <= 0.01) return true;\n            }\n        }\n\n        // Harness/carabiners (kask/çengeller)\n        if (y <= -0.3 && y >= -0.5) {\n            return Math.abs(x) <= 0.15 && Math.abs(z) <= 0.1;\n        }\n\n        // Speed bar (hız çubuğu)\n        if (y <= -0.1 && y >= -0.15) {\n            return Math.abs(x) <= 0.4 && Math.abs(z) <= 0.02;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"PARAGLIDER\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Yamaç Paraşütü\";\n    }\n}","size_bytes":1831},"src/main/java/com/skyorbs/shapes/impl/PyramidShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class PyramidShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        if (dy < 0 || dy > radius) {\n            return false;\n        }\n        \n        int levelSize = radius - dy;\n        return Math.abs(dx) <= levelSize && Math.abs(dz) <= levelSize;\n    }\n    \n    @Override\n    public String getName() {\n        return \"PYRAMID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Piramit\";\n    }\n}\n","size_bytes":679},"src/main/java/com/skyorbs/shapes/impl/DragonShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class DragonShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Ejderha şekli - vücut, kanatlar, kuyruk\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Dragon body - S şeklinde kıvrımlı\n        double bodyCurve = Math.sin(x * 3) * 0.2;\n        double bodyY = y + bodyCurve;\n\n        // Wings - kanatlar\n        if (Math.abs(z) > 0.3 && Math.abs(x) < 0.6) {\n            double wingShape = Math.exp(-Math.abs(z) * 2) * Math.exp(-x * x);\n            if (wingShape > 0.1) return true;\n        }\n\n        // Main body\n        return Math.abs(bodyY) <= 0.3 && Math.abs(z) <= 0.4;\n    }\n\n    @Override\n    public String getName() {\n        return \"DRAGON\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Ejderha\";\n    }\n}","size_bytes":1226},"src/main/java/com/skyorbs/shapes/impl/ShellShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ShellShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Deniz kabuğu şekli - spiral\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Spiral shell formülü\n        double angle = Math.atan2(z, x);\n        double radiusAtAngle = Math.exp(angle * 0.3) * 0.8; // Spiral genişleme\n        double radialDistance = Math.sqrt(x*x + z*z);\n\n        return radialDistance <= radiusAtAngle && Math.abs(y) <= 0.4;\n    }\n\n    @Override\n    public String getName() {\n        return \"SHELL\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.7;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kabuk\";\n    }\n}","size_bytes":1054},"src/main/java/com/skyorbs/shapes/impl/CrownShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CrownShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Taç şekli - base, spikes, jewels\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Crown base\n        if (y >= -0.2 && y <= 0.1) {\n            return Math.abs(z) <= 0.8;\n        }\n\n        // Crown spikes\n        if (y > 0.1 && y <= 0.6) {\n            // 5 spikes\n            for (int i = 0; i < 5; i++) {\n                double spikeX = -0.6 + i * 0.3;\n                double spikeWidth = 0.1;\n                if (Math.abs(x - spikeX) <= spikeWidth) {\n                    double spikeHeight = 0.6 - Math.abs(x - spikeX) * 2;\n                    if (y <= spikeHeight) return true;\n                }\n            }\n        }\n\n        // Crown jewels\n        if (y >= 0.2 && y <= 0.4) {\n            for (int i = 0; i < 5; i++) {\n                double jewelX = -0.6 + i * 0.3;\n                double jewelDistance = Math.sqrt((x - jewelX)*(x - jewelX) + (y - 0.3)*(y - 0.3));\n                if (jewelDistance <= 0.08) return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"CROWN\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Taç\";\n    }\n}","size_bytes":1681},"src/main/java/com/skyorbs/core/Orb.java":{"content":"package com.skyorbs.core;\n\nimport java.util.UUID;\nimport java.util.Set;\nimport java.util.HashSet;\nimport com.skyorbs.modifiers.PlanetModifier;\nimport com.skyorbs.atmosphere.AtmosphereType;\n\npublic class Orb {\n\n    private final UUID id;\n    private final String name;\n    private final String worldName;\n    private final int centerX;\n    private final int centerY;\n    private final int centerZ;\n    private int radius;\n    private final String shapeName;\n    private String biomeName;\n    private final long seed;\n    private final long createdAt;\n    private final boolean isAsteroid;\n    private final UUID parentId;\n\n    // Dynamic Core System\n    private int coreLevel;\n    private double energyLevel;\n    private long xp;\n    private PlanetType planetType;\n    private int biosphereLevel;\n    private double ecologicalBalance;\n    \n    // Advanced planet features\n    private String paletteId;\n    private Set<PlanetModifier> modifiers;\n    private AtmosphereType atmosphere;\n    \n    public Orb(UUID id, String name, String worldName, int centerX, int centerY, int centerZ,\n               int radius, String shapeName, String biomeName, long seed, long createdAt,\n               boolean isAsteroid, UUID parentId) {\n        this.id = id;\n        this.name = name;\n        this.worldName = worldName;\n        this.centerX = centerX;\n        this.centerY = centerY;\n        this.centerZ = centerZ;\n        this.radius = radius;\n        this.shapeName = shapeName;\n        this.biomeName = biomeName;\n        this.seed = seed;\n        this.createdAt = createdAt;\n        this.isAsteroid = isAsteroid;\n        this.parentId = parentId;\n\n        // Initialize dynamic core system\n        this.coreLevel = 1;\n        this.energyLevel = 100.0;\n        this.xp = 0;\n        this.planetType = PlanetType.TERRESTRIAL; // Default type\n        this.biosphereLevel = 1;\n        this.ecologicalBalance = 1.0;\n        \n        // Initialize advanced features\n        this.paletteId = null;\n        this.modifiers = new HashSet<PlanetModifier>();\n        this.atmosphere = AtmosphereType.CLEAR;\n    }\n    \n    public UUID getId() {\n        return id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getWorldName() {\n        return worldName;\n    }\n    \n    public int getCenterX() {\n        return centerX;\n    }\n    \n    public int getCenterY() {\n        return centerY;\n    }\n    \n    public int getCenterZ() {\n        return centerZ;\n    }\n    \n    public int getRadius() {\n        return radius;\n    }\n\n    public void setRadius(int radius) {\n        this.radius = radius;\n    }\n\n    public void setBiomeName(String biomeName) {\n        this.biomeName = biomeName;\n    }\n    \n    public String getShapeName() {\n        return shapeName;\n    }\n    \n    public String getBiomeName() {\n        return biomeName;\n    }\n    \n    public long getSeed() {\n        return seed;\n    }\n    \n    public long getCreatedTime() {\n        return createdAt;\n    }\n\n    public long getCreatedAt() {\n        return createdAt;\n    }\n    \n    public boolean isAsteroid() {\n        return isAsteroid;\n    }\n    \n    public UUID getParentId() {\n        return parentId;\n    }\n    \n    public double getDistanceFrom(int x, int z) {\n        int dx = x - centerX;\n        int dz = z - centerZ;\n        return Math.sqrt(dx * dx + dz * dz);\n    }\n    \n    public double getDistanceFromSpawn() {\n        return Math.sqrt(centerX * centerX + centerZ * centerZ);\n    }\n\n    // Dynamic Core System Getters and Setters\n    public int getCoreLevel() {\n        return coreLevel;\n    }\n\n    public void setCoreLevel(int coreLevel) {\n        this.coreLevel = Math.max(1, Math.min(10, coreLevel));\n    }\n\n    public double getEnergyLevel() {\n        return energyLevel;\n    }\n\n    public void setEnergyLevel(double energyLevel) {\n        this.energyLevel = Math.max(0.0, Math.min(100.0, energyLevel));\n    }\n\n    public long getXp() {\n        return xp;\n    }\n\n    public void addXp(long xp) {\n        this.xp += xp;\n        // Check for level up\n        int newLevel = calculateCoreLevelFromXp(this.xp);\n        if (newLevel > this.coreLevel) {\n            setCoreLevel(newLevel);\n        }\n    }\n\n    public PlanetType getPlanetType() {\n        return planetType;\n    }\n\n    public void setPlanetType(PlanetType planetType) {\n        this.planetType = planetType;\n    }\n\n    public int getBiosphereLevel() {\n        return biosphereLevel;\n    }\n\n    public void setBiosphereLevel(int biosphereLevel) {\n        this.biosphereLevel = Math.max(1, Math.min(5, biosphereLevel));\n    }\n\n    public double getEcologicalBalance() {\n        return ecologicalBalance;\n    }\n\n    public void setEcologicalBalance(double ecologicalBalance) {\n        this.ecologicalBalance = Math.max(0.0, Math.min(2.0, ecologicalBalance));\n    }\n\n    // Helper methods\n    private int calculateCoreLevelFromXp(long xp) {\n        // Level calculation: level = floor(sqrt(xp / 1000)) + 1\n        return (int) Math.floor(Math.sqrt(xp / 1000.0)) + 1;\n    }\n\n    public long getXpForNextLevel() {\n        int nextLevel = coreLevel + 1;\n        return (long) ((nextLevel - 1) * (nextLevel - 1) * 1000);\n    }\n\n    public double getEnergyRegenRate() {\n        return 0.1 * coreLevel; // Higher levels regenerate faster\n    }\n\n    public boolean canUpgrade() {\n        return xp >= getXpForNextLevel();\n    }\n    \n    // Advanced features getters and setters\n    public String getPaletteId() {\n        return paletteId;\n    }\n    \n    public void setPaletteId(String paletteId) {\n        this.paletteId = paletteId;\n    }\n    \n    public Set<PlanetModifier> getModifiers() {\n        return modifiers;\n    }\n    \n    public void setModifiers(Set<PlanetModifier> modifiers) {\n        this.modifiers = modifiers != null ? modifiers : new HashSet<PlanetModifier>();\n    }\n    \n    public void addModifier(PlanetModifier modifier) {\n        this.modifiers.add(modifier);\n    }\n    \n    public boolean hasModifier(PlanetModifier modifier) {\n        return modifiers.contains(modifier);\n    }\n    \n    public AtmosphereType getAtmosphere() {\n        return atmosphere;\n    }\n    \n    public void setAtmosphere(AtmosphereType atmosphere) {\n        this.atmosphere = atmosphere != null ? atmosphere : AtmosphereType.CLEAR;\n    }\n    \n    public boolean isHollow() {\n        return modifiers.contains(PlanetModifier.HOLLOW);\n    }\n    \n    public boolean isOreRich() {\n        return modifiers.contains(PlanetModifier.ORE_RICH);\n    }\n}\n","size_bytes":6494},"src/main/java/com/skyorbs/features/OreGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetType;\nimport com.skyorbs.biomes.BiomeType;\nimport org.bukkit.Material;\n\nimport java.util.*;\n\n/**\n * PLANET-TYPE BASED ORE GENERATOR\n * Her gezegen tipi kendi özel ore profiline sahip!\n * Derinlik sistemli - Overworld tarzı\n */\npublic class OreGenerator {\n\n    private static final SkyOrbs plugin = SkyOrbs.getInstance();\n\n    // PLANET TYPE -> ORE PROFILES\n    private static final Map<PlanetType, OreProfile> ORE_PROFILES = new HashMap<>();\n\n    static {\n        initializeOreProfiles();\n    }\n\n    /**\n     * ANA ORE GENERATION METODu\n     */\n    public static Material tryGenerateOre(int x, int y, int z, double distanceFromCenter,\n                                            int radius, BiomeType biome, Random random) {\n\n        // YÜZEY VE KABUK KATMANI - ORE YOK (sadece derin iç kısım)\n        if (distanceFromCenter > radius - 8) return null;\n\n        // CONFIG KONTROL\n        if (!plugin.getConfigManager().isOreGenerationEnabled()) return null;\n\n        // Derinlik hesapla (0 = merkez, 1 = yüzey)\n        double depth = distanceFromCenter / radius;\n\n        // Planet Type'ı bul\n        PlanetType planetType = getPlanetTypeFromBiome(biome);\n\n        // Ore Profile'ı al\n        OreProfile profile = ORE_PROFILES.get(planetType);\n        if (profile == null) {\n            profile = ORE_PROFILES.get(PlanetType.TERRESTRIAL); // Fallback\n        }\n\n        // Derinlik katmanına göre ore seç\n        return profile.getOreForDepth(depth, random);\n    }\n\n    /**\n     * GEZEGEN TİPİ PROFILLERINI BAŞLAT\n     */\n    private static void initializeOreProfiles() {\n\n        // ═══════════════════════════════════════════════\n        // 🌍 TERRESTRIAL (Dünya Benzeri) - Dengeli\n        // ═══════════════════════════════════════════════\n        OreProfile terrestrial = new OreProfile(PlanetType.TERRESTRIAL);\n        // Yüzey (0.7-1.0) - Çok nadir\n        terrestrial.addOre(0.7, 1.0, Material.COAL_ORE, 0.04);\n        terrestrial.addOre(0.7, 1.0, Material.COPPER_ORE, 0.03);\n        terrestrial.addOre(0.7, 1.0, Material.IRON_ORE, 0.02);\n        // Orta (0.4-0.7) - Nadir\n        terrestrial.addOre(0.4, 0.7, Material.IRON_ORE, 0.05);\n        terrestrial.addOre(0.4, 0.7, Material.COAL_ORE, 0.03);\n        terrestrial.addOre(0.4, 0.7, Material.GOLD_ORE, 0.02);\n        terrestrial.addOre(0.4, 0.7, Material.REDSTONE_ORE, 0.015);\n        terrestrial.addOre(0.4, 0.7, Material.LAPIS_ORE, 0.01);\n        // Derin (0.2-0.4) - Çok nadir\n        terrestrial.addOre(0.2, 0.4, Material.IRON_ORE, 0.03);\n        terrestrial.addOre(0.2, 0.4, Material.GOLD_ORE, 0.025);\n        terrestrial.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.015);\n        terrestrial.addOre(0.2, 0.4, Material.REDSTONE_ORE, 0.02);\n        terrestrial.addOre(0.2, 0.4, Material.EMERALD_ORE, 0.005);\n        // Çok Derin (0.0-0.2) - Merkez - Çok nadir\n        terrestrial.addOre(0.0, 0.2, Material.DIAMOND_ORE, 0.025);\n        terrestrial.addOre(0.0, 0.2, Material.EMERALD_ORE, 0.01);\n        terrestrial.addOre(0.0, 0.2, Material.GOLD_ORE, 0.02);\n        terrestrial.addOre(0.0, 0.2, Material.DEEPSLATE_DIAMOND_ORE, 0.015);\n        ORE_PROFILES.put(PlanetType.TERRESTRIAL, terrestrial);\n\n        // ═══════════════════════════════════════════════\n        // 🔥 LAVA (Volkanik) - Gold & Ancient Debris\n        // ═══════════════════════════════════════════════\n        OreProfile lava = new OreProfile(PlanetType.LAVA);\n        // Yüzey - Çok nadir\n        lava.addOre(0.7, 1.0, Material.NETHERRACK, 0.06);\n        lava.addOre(0.7, 1.0, Material.NETHER_GOLD_ORE, 0.04);\n        lava.addOre(0.7, 1.0, Material.BLACKSTONE, 0.03);\n        // Orta - Nadir\n        lava.addOre(0.4, 0.7, Material.NETHER_GOLD_ORE, 0.06);\n        lava.addOre(0.4, 0.7, Material.NETHER_QUARTZ_ORE, 0.05);\n        lava.addOre(0.4, 0.7, Material.MAGMA_BLOCK, 0.03);\n        lava.addOre(0.4, 0.7, Material.GOLD_ORE, 0.04);\n        // Derin - Çok nadir\n        lava.addOre(0.2, 0.4, Material.GOLD_ORE, 0.05);\n        lava.addOre(0.2, 0.4, Material.NETHER_QUARTZ_ORE, 0.04);\n        lava.addOre(0.2, 0.4, Material.ANCIENT_DEBRIS, 0.01); // Çok nadir!\n        lava.addOre(0.2, 0.4, Material.OBSIDIAN, 0.025);\n        // Çok Derin - ANCIENT DEBRIS PARADISE! - Çok nadir\n        lava.addOre(0.0, 0.2, Material.ANCIENT_DEBRIS, 0.02); // Daha nadir!\n        lava.addOre(0.0, 0.2, Material.OBSIDIAN, 0.03);\n        ORE_PROFILES.put(PlanetType.LAVA, lava);\n\n        // ═══════════════════════════════════════════════\n        // ❄️ ICE (Buzul) - Diamond & Lapis Paradise\n        // ═══════════════════════════════════════════════\n        OreProfile ice = new OreProfile(PlanetType.ICE);\n        // Yüzey - Çok nadir\n        ice.addOre(0.7, 1.0, Material.PACKED_ICE, 0.06);\n        ice.addOre(0.7, 1.0, Material.IRON_ORE, 0.03);\n        ice.addOre(0.7, 1.0, Material.COAL_ORE, 0.02);\n        // Orta - Nadir\n        ice.addOre(0.4, 0.7, Material.IRON_ORE, 0.05);\n        ice.addOre(0.4, 0.7, Material.LAPIS_ORE, 0.04); // Lapis nadir\n        ice.addOre(0.4, 0.7, Material.BLUE_ICE, 0.03);\n        ice.addOre(0.4, 0.7, Material.DIAMOND_ORE, 0.02);\n        // Derin - Çok nadir\n        ice.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.04); // Diamond nadir\n        ice.addOre(0.2, 0.4, Material.LAPIS_ORE, 0.05);\n        ice.addOre(0.2, 0.4, Material.EMERALD_ORE, 0.015);\n        ice.addOre(0.2, 0.4, Material.PACKED_ICE, 0.03);\n        // Çok Derin - Çok nadir\n        ice.addOre(0.0, 0.2, Material.DIAMOND_ORE, 0.06); // DIAMOND nadir!\n        ice.addOre(0.0, 0.2, Material.DEEPSLATE_DIAMOND_ORE, 0.03);\n        ice.addOre(0.0, 0.2, Material.BLUE_ICE, 0.02);\n        ORE_PROFILES.put(PlanetType.ICE, ice);\n\n        // ═══════════════════════════════════════════════\n        // 💎 CRYSTAL (Kristal) - Gem Paradise\n        // ═══════════════════════════════════════════════\n        OreProfile crystal = new OreProfile(PlanetType.CRYSTAL);\n        // Yüzey - Çok nadir\n        crystal.addOre(0.7, 1.0, Material.QUARTZ_BLOCK, 0.05);\n        crystal.addOre(0.7, 1.0, Material.AMETHYST_BLOCK, 0.03);\n        crystal.addOre(0.7, 1.0, Material.CALCITE, 0.02);\n        // Orta - Nadir\n        crystal.addOre(0.4, 0.7, Material.AMETHYST_BLOCK, 0.06);\n        crystal.addOre(0.4, 0.7, Material.DIAMOND_ORE, 0.03);\n        crystal.addOre(0.4, 0.7, Material.EMERALD_ORE, 0.025);\n        crystal.addOre(0.4, 0.7, Material.LAPIS_ORE, 0.04);\n        // Derin - Çok nadir\n        crystal.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.05);\n        crystal.addOre(0.2, 0.4, Material.EMERALD_ORE, 0.04);\n        crystal.addOre(0.2, 0.4, Material.AMETHYST_CLUSTER, 0.03);\n        crystal.addOre(0.2, 0.4, Material.LAPIS_BLOCK, 0.015);\n        // Çok Derin - GEM nadir!\n        crystal.addOre(0.0, 0.2, Material.AMETHYST_BLOCK, 0.04);\n        crystal.addOre(0.0, 0.2, Material.BUDDING_AMETHYST, 0.015);\n        ORE_PROFILES.put(PlanetType.CRYSTAL, crystal);\n\n        // ═══════════════════════════════════════════════\n        // 🌑 SHADOW (Gölge) - Obsidian & Dark Materials\n        // ═══════════════════════════════════════════════\n        OreProfile shadow = new OreProfile(PlanetType.SHADOW);\n        // Yüzey - Çok nadir\n        shadow.addOre(0.7, 1.0, Material.END_STONE, 0.05);\n        shadow.addOre(0.7, 1.0, Material.OBSIDIAN, 0.03);\n        shadow.addOre(0.7, 1.0, Material.COAL_ORE, 0.02);\n        // Orta - Nadir\n        shadow.addOre(0.4, 0.7, Material.OBSIDIAN, 0.05);\n        shadow.addOre(0.4, 0.7, Material.CRYING_OBSIDIAN, 0.025);\n        shadow.addOre(0.4, 0.7, Material.DIAMOND_ORE, 0.02);\n        shadow.addOre(0.4, 0.7, Material.END_STONE, 0.03);\n        // Derin - Çok nadir\n        shadow.addOre(0.2, 0.4, Material.CRYING_OBSIDIAN, 0.04);\n        shadow.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.025);\n        shadow.addOre(0.2, 0.4, Material.ANCIENT_DEBRIS, 0.01);\n        shadow.addOre(0.2, 0.4, Material.PURPUR_BLOCK, 0.025);\n        // Çok Derin - Çok nadir\n        shadow.addOre(0.0, 0.2, Material.OBSIDIAN, 0.06);\n        shadow.addOre(0.0, 0.2, Material.CRYING_OBSIDIAN, 0.03);\n        shadow.addOre(0.0, 0.2, Material.RESPAWN_ANCHOR, 0.005); // Çok nadir!\n        ORE_PROFILES.put(PlanetType.SHADOW, shadow);\n\n        // ═══════════════════════════════════════════════\n        // ☠️ TOXIC (Zehirli) - Redstone & Slime\n        // ═══════════════════════════════════════════════\n        OreProfile toxic = new OreProfile(PlanetType.TOXIC);\n        // Yüzey - Çok nadir\n        toxic.addOre(0.7, 1.0, Material.SLIME_BLOCK, 0.04);\n        toxic.addOre(0.7, 1.0, Material.MOSS_BLOCK, 0.03);\n        toxic.addOre(0.7, 1.0, Material.COPPER_ORE, 0.02);\n        // Orta - Nadir\n        toxic.addOre(0.4, 0.7, Material.REDSTONE_ORE, 0.06); // Redstone nadir\n        toxic.addOre(0.4, 0.7, Material.SLIME_BLOCK, 0.05);\n        toxic.addOre(0.4, 0.7, Material.COPPER_ORE, 0.04);\n        toxic.addOre(0.4, 0.7, Material.IRON_ORE, 0.03);\n        // Derin - Çok nadir\n        toxic.addOre(0.2, 0.4, Material.REDSTONE_ORE, 0.06); // Redstone nadir\n        toxic.addOre(0.2, 0.4, Material.GOLD_ORE, 0.025);\n        toxic.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.015);\n        toxic.addOre(0.2, 0.4, Material.SCULK, 0.02);\n        // Çok Derin - Çok nadir\n        toxic.addOre(0.0, 0.2, Material.REDSTONE_ORE, 0.05);\n        toxic.addOre(0.0, 0.2, Material.SCULK_CATALYST, 0.01);\n        toxic.addOre(0.0, 0.2, Material.DIAMOND_ORE, 0.02);\n        ORE_PROFILES.put(PlanetType.TOXIC, toxic);\n\n        // ═══════════════════════════════════════════════\n        // 🌫️ GAS (Gaz Devi) - Minimal Ores\n        // ═══════════════════════════════════════════════\n        OreProfile gas = new OreProfile(PlanetType.GAS);\n        // Çok az ore - gaz gezegeni - Çok nadir\n        gas.addOre(0.7, 1.0, Material.IRON_ORE, 0.01);\n        gas.addOre(0.4, 0.7, Material.GOLD_ORE, 0.012);\n        gas.addOre(0.2, 0.4, Material.DIAMOND_ORE, 0.006);\n        gas.addOre(0.0, 0.2, Material.NETHERITE_SCRAP, 0.003);\n        ORE_PROFILES.put(PlanetType.GAS, gas);\n    }\n\n    /**\n     * BiomeType -> PlanetType mapping\n     */\n    public static PlanetType getPlanetTypeFromBiome(BiomeType biome) {\n        return switch (biome) {\n            // TERRESTRIAL\n            case FOREST, PLAINS, JUNGLE, SAVANNA, TAIGA, MEADOW,\n                 DESERT, BADLANDS, CANYON, PRIMAL, EARTH -> PlanetType.TERRESTRIAL;\n\n            // LAVA\n            case LAVA_OCEAN, OBSIDIAN_PLAINS, MAGMA_CAVES, BASALTIC,\n                 FLAME, INFERNAL, STAR_FORGED -> PlanetType.LAVA;\n\n            // ICE\n            case FROZEN_TUNDRA, ICE_SPIKES, GLACIER, AURORA, FROST, MIRROR -> PlanetType.ICE;\n\n            // CRYSTAL\n            case CRYSTAL_FOREST, CRYSTALLINE, LUMINOUS, GLOWSTONE_CAVERN,\n                 CELESTIAL, DIVINE, QUANTUM, POLISHED, GLASS, CALCITE -> PlanetType.CRYSTAL;\n\n            // SHADOW\n            case VOID, CHORUS_LAND, CORRUPTED, VOID_BORN,\n                 NEBULOUS, COSMIC, ETHEREAL, DIMENSIONAL, PHASE,\n                 ARCANE, VOID_ENERGY, TEMPORAL -> PlanetType.SHADOW;\n\n            // TOXIC\n            case TOXIC_SWAMP, TOXIC, CORROSIVE, SPONGE -> PlanetType.TOXIC;\n\n            // GAS\n            case MUSHROOM_GIANT, FUNGAL, WIND, GALACTIC, NEBULA_INFUSED,\n                 UNIVERSE_BOUND, STORMY, FOGGY -> PlanetType.GAS;\n\n            default -> PlanetType.TERRESTRIAL;\n        };\n    }\n\n    /**\n     * TAŞ VARİANTLARI (çeşitlilik)\n     */\n    public static Material getStoneVariant(BiomeType biome, Random random) {\n        if (random.nextDouble() > 0.12) return null; // %88 normal blok\n\n        PlanetType planetType = getPlanetTypeFromBiome(biome);\n\n        return switch (planetType) {\n            case LAVA -> {\n                Material[] variants = {Material.BLACKSTONE, Material.BASALT, Material.NETHERRACK, Material.MAGMA_BLOCK};\n                yield variants[random.nextInt(variants.length)];\n            }\n            case CRYSTAL -> {\n                Material[] variants = {Material.QUARTZ_BLOCK, Material.CALCITE, Material.DRIPSTONE_BLOCK, Material.AMETHYST_BLOCK};\n                yield variants[random.nextInt(variants.length)];\n            }\n            case SHADOW -> {\n                Material[] variants = {Material.END_STONE, Material.OBSIDIAN, Material.PURPUR_BLOCK, Material.BLACKSTONE};\n                yield variants[random.nextInt(variants.length)];\n            }\n            case ICE -> {\n                Material[] variants = {Material.STONE, Material.ANDESITE, Material.DIORITE, Material.PACKED_ICE};\n                yield variants[random.nextInt(variants.length)];\n            }\n            case TOXIC -> {\n                Material[] variants = {Material.MOSS_BLOCK, Material.SCULK, Material.SLIME_BLOCK, Material.PRISMARINE};\n                yield variants[random.nextInt(variants.length)];\n            }\n            default -> {\n                Material[] variants = {Material.STONE, Material.ANDESITE, Material.DIORITE, Material.GRANITE};\n                yield variants[random.nextInt(variants.length)];\n            }\n        };\n    }\n\n    /**\n     * ORE PROFILE CLASS\n     */\n    private static class OreProfile {\n        private final PlanetType planetType;\n        private final List<OreLayer> layers = new ArrayList<>();\n\n        public OreProfile(PlanetType planetType) {\n            this.planetType = planetType;\n        }\n\n        public void addOre(double minDepth, double maxDepth, Material ore, double chance) {\n            layers.add(new OreLayer(minDepth, maxDepth, ore, chance));\n        }\n\n        public Material getOreForDepth(double depth, Random random) {\n            // Check layers in order for structured generation like Overworld\n            // Ensure ores spawn in separate veins/clusters by type - no mixing\n            List<OreLayer> availableLayers = new ArrayList<>();\n            for (OreLayer layer : layers) {\n                if (depth >= layer.minDepth && depth <= layer.maxDepth) {\n                    availableLayers.add(layer);\n                }\n            }\n\n            // If multiple ores available in this depth, pick one randomly but ensure separation\n            if (!availableLayers.isEmpty()) {\n                OreLayer selectedLayer = availableLayers.get(random.nextInt(availableLayers.size()));\n                if (random.nextDouble() < selectedLayer.chance) {\n                    // Additional check: ensure ores are not too close to each other\n                    // This creates orderly distribution - reduced to 50% for much rarer spawning\n                    if (random.nextDouble() < 0.5) { // 50% chance to place, creating natural spacing\n                        return selectedLayer.ore;\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    /**\n     * ORE LAYER CLASS\n     */\n    private static class OreLayer {\n        final double minDepth;\n        final double maxDepth;\n        final Material ore;\n        final double chance;\n\n        public OreLayer(double minDepth, double maxDepth, Material ore, double chance) {\n            this.minDepth = minDepth;\n            this.maxDepth = maxDepth;\n            this.ore = ore;\n            this.chance = chance;\n        }\n    }\n\n    /**\n     * Block data helper class\n     */\n    public static class BlockData {\n        public final int x, y, z;\n        public final Material material;\n\n        public BlockData(int x, int y, int z, Material material) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.material = material;\n        }\n    }\n}","size_bytes":16972},"src/main/java/com/skyorbs/modifiers/PlanetModifier.java":{"content":"package com.skyorbs.modifiers;\n\n/**\n * Planet modifiers that create diversity\n * Applied during generation to modify planet structure\n */\npublic enum PlanetModifier {\n    \n    HOLLOW(\"Hollow\", \"İçi Boş\", 0.1),           // Empty interior with shell\n    ORE_RICH(\"Ore Rich\", \"Maden Zengin\", 0.3),   // 2x ore density\n    MAGMA_CORE(\"Magma Core\", \"Magma Çekirdek\", 0.2),  // Hot glowing core\n    ICY_CORE(\"Icy Core\", \"Buz Çekirdek\", 0.15),       // Frozen core\n    LAYERED(\"Layered\", \"Katmanlı\", 0.25),       // Multiple material layers\n    ANTI_GRAVITY(\"Anti-Gravity\", \"Yer Çekimsiz\", 0.1), // Floating zones\n    DENSE(\"Dense\", \"Yoğun\", 0.2),               // Extra solid, more blocks\n    POROUS(\"Porous\", \"Gözenekli\", 0.15),        // Many caves and tunnels\n    RINGED(\"Ringed\", \"Halkalı\", 0.2),           // Has ring system\n    RADIOACTIVE(\"Radioactive\", \"Radyoaktif\", 0.05), // Dangerous radiation\n    CRYSTALLIZED(\"Crystallized\", \"Kristalleşmiş\", 0.25), // Crystal formations\n    VEGETATED(\"Vegetated\", \"Bitkili\", 0.3),     // Extra vegetation\n    MINERALIZED(\"Mineralized\", \"Mineralleşmiş\", 0.2), // Rich minerals\n    ERODED(\"Eroded\", \"Aşınmış\", 0.15),          // Weathered surface\n    VOLCANIC(\"Volcanic\", \"Volkanik\", 0.2),     // Active volcanoes\n    AQUATIC(\"Aquatic\", \"Su\", 0.25),            // Water features\n    STORMY(\"Stormy\", \"Fırtınalı\", 0.1),        // Storm effects\n    MAGNETIC(\"Magnetic\", \"Manyetik\", 0.15),    // Magnetic anomalies\n    BIO_LUMinescent(\"Bio-Luminescent\", \"Biyolüminesan\", 0.1), // Glowing life\n    FROZEN(\"Frozen\", \"Donmuş\", 0.2),           // Ice formations\n    SANDY(\"Sandy\", \"Kumlu\", 0.25),             // Desert-like\n    FORESTED(\"Forested\", \"Ormansız\", 0.3),     // Dense forests\n    CAVERN(\"Cavern\", \"Mağara\", 0.2),           // Cave systems\n    METEORIC(\"Meteoric\", \"Meteorik\", 0.1),     // Meteor impacts\n    GEYSER(\"Geyser\", \"Geyser\", 0.15),          // Hot springs\n    TIDAL(\"Tidal\", \"Gelgit\", 0.2),             // Ocean tides\n    WINDY(\"Windy\", \"Rüzgarlı\", 0.25),          // Wind effects\n    SHADOWY(\"Shadowy\", \"Gölgeli\", 0.1),        // Dark areas\n    MIRROR(\"Mirror\", \"Ayna\", 0.05),            // Reflective surface\n    PHASE(\"Phase\", \"Faz\", 0.1),                // Phase-shifting\n    QUANTUM(\"Quantum\", \"Kuantum\", 0.05),       // Quantum effects\n    TEMPORAL(\"Temporal\", \"Zamansal\", 0.05),    // Time anomalies\n    VOID(\"Void\", \"Boşluk\", 0.1),               // Void energies\n    CELESTIAL(\"Celestial\", \"Göksel\", 0.15),    // Star-like\n    NEBULOUS(\"Nebulous\", \"Sisli\", 0.2),        // Gas clouds\n    PLASMA(\"Plasma\", \"Plazma\", 0.1),           // Plasma storms\n    GRAVITATIONAL(\"Gravitational\", \"Yerçekimi\", 0.15), // Gravity wells\n    ELECTRIC(\"Electric\", \"Elektrik\", 0.2),     // Electric fields\n    SONIC(\"Sonic\", \"Ses\", 0.1),                // Sound waves\n    LIGHTNING(\"Lightning\", \"Yıldırım\", 0.15),  // Lightning storms\n    AURORA(\"Aurora\", \"Aurora\", 0.2),           // Aurora effects\n    COSMIC(\"Cosmic\", \"Kozmik\", 0.1),           // Cosmic energies\n    DIMENSIONAL(\"Dimensional\", \"Boyutsal\", 0.05), // Dimension rifts\n    ETHEREAL(\"Ethereal\", \"Eterik\", 0.1),       // Ethereal mists\n    PRIMAL(\"Primal\", \"İlkel\", 0.2),            // Raw elemental power\n    SYMBIOTIC(\"Symbiotic\", \"Sembiyotik\", 0.15), // Life symbiosis\n    MUTAGENIC(\"Mutagenic\", \"Mutajenik\", 0.1),  // Genetic changes\n    RESONANT(\"Resonant\", \"Rezonans\", 0.2),     // Energy resonance\n    HARMONIC(\"Harmonic\", \"Harmonik\", 0.25),   // Harmonic frequencies\n    CHAOTIC(\"Chaotic\", \"Kaotik\", 0.15),        // Chaotic energies\n    ORDERED(\"Ordered\", \"Düzenli\", 0.2),        // Ordered structures\n    ENTROPIC(\"Entropic\", \"Entropik\", 0.1),     // Entropy effects\n    SYNERGISTIC(\"Synergistic\", \"Sinerjik\", 0.2), // Synergy effects\n    CATALYTIC(\"Catalytic\", \"Katalitik\", 0.15), // Catalyst reactions\n    ALCHEMICAL(\"Alchemical\", \"Simya\", 0.1),    // Alchemical transformations\n    MYSTICAL(\"Mystical\", \"Mistik\", 0.15),      // Mystical energies\n    ARCANE(\"Arcane\", \"Gizemli\", 0.1),          // Arcane magic\n    DIVINE(\"Divine\", \"İlahî\", 0.05),           // Divine presence\n    INFERNAL(\"Infernal\", \"Cehennemî\", 0.1),   // Infernal powers\n    CELESTIAL_BLESSED(\"Celestial Blessed\", \"Göksel Bereketli\", 0.05), // Celestial blessing\n    VOID_BORN(\"Void Born\", \"Boşluk Doğumlu\", 0.1), // Born from void\n    STAR_FORGED(\"Star Forged\", \"Yıldız Dövülmüş\", 0.15), // Forged in stars\n    NEBULA_INFUSED(\"Nebula Infused\", \"Sis Enjekte\", 0.2), // Nebula energies\n    GALACTIC(\"Galactic\", \"Galaktik\", 0.1),     // Galactic powers\n    UNIVERSE_BOUND(\"Universe Bound\", \"Evren Bağlı\", 0.05); // Universe connection\n    \n    private final String name;\n    private final String displayName;\n    private final double probability;\n    \n    PlanetModifier(String name, String displayName, double probability) {\n        this.name = name;\n        this.displayName = displayName;\n        this.probability = probability;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public String getDisplayName() {\n        return displayName;\n    }\n    \n    public double getProbability() {\n        return probability;\n    }\n}\n","size_bytes":5191},"src/main/java/com/skyorbs/shapes/impl/SkiShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class SkiShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kayak şekli - ski, bindings, edges\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Main ski (ana kayak)\n        if (Math.abs(y) <= 0.02) {\n            // Tapered shape - wider at center, narrower at ends\n            double width = 0.08 + (0.12 - Math.abs(x) * 0.2);\n            return Math.abs(z) <= width && Math.abs(x) <= 0.6;\n        }\n\n        // Ski edges (kenarlar) - raised\n        if (Math.abs(y) <= 0.04) {\n            double width = 0.08 + (0.12 - Math.abs(x) * 0.2);\n            return Math.abs(z) <= width && Math.abs(x) <= 0.6;\n        }\n\n        // Ski tips (uçlar) - upturned\n        if (Math.abs(x) > 0.5) {\n            double tipAngle = (Math.abs(x) - 0.5) * 0.3;\n            if (y > tipAngle - 0.02 && y < tipAngle + 0.02) {\n                return Math.abs(z) <= 0.06;\n            }\n        }\n\n        // Bindings (bağlamalar)\n        double bindingWidth = 0.06;\n        double bindingLength = 0.04;\n        if (Math.abs(x) <= 0.1 && Math.abs(y - 0.05) <= 0.03) {\n            return Math.abs(z) <= bindingWidth;\n        }\n\n        // Binding straps (kayışlar)\n        if (Math.abs(y - 0.08) <= 0.02) {\n            if (Math.abs(x) <= 0.12 && Math.abs(z) <= 0.08) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SKI\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.9;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kayak\";\n    }\n}","size_bytes":1933},"CHANGELOG.md":{"content":"# SkyOrbs 2.0.0 - Complete Update Changelog\n\n## 🎯 Overview\nThis update transforms SkyOrbs into a comprehensive planet generation system with 2000+ unique planet combinations, improved ore generation, better tree placement, and much more.\n\n## ✅ Fixed Issues\n\n### 1️⃣ Ore Generation (FIXED)\n- ✅ Ores now generate correctly inside planets (both solid and hollow)\n- ✅ Shell-only generation for hollow planets\n- ✅ Biome-specific ore bonuses\n- ✅ Core inclusions for solid planets only\n- ✅ Deepslate variants based on depth\n- ✅ Configurable ore layers (common, rare, core)\n\n### 2️⃣ Planet Diversity (2000+ Combinations)\n- ✅ **28 Shape Types** (10 basic + 8 advanced + 10 new)\n  - New shapes: Layered, Cratered, Honeycomb, Spiral, Wave, Crystal, Organic, Geometric, Nebula, Asteroid Field\n- ✅ **20+ Biome Palettes** with depth-based material selection\n- ✅ **10 Modifier Types** (hollow, ore-rich, magma-core, icy-core, layered, etc.)\n- ✅ **8 Atmosphere Types** (clear, toxic, luminous, stormy, foggy, corrosive, aurora, radioactive)\n- ✅ **Total Combinations**: 28 × 20 × 10 × 8 = 44,800+ unique planets!\n\n### 3️⃣ Atmosphere Systems (IMPLEMENTED)\n- ✅ Particle effects for each atmosphere type\n- ✅ Player effects when entering atmosphere\n- ✅ Configurable atmosphere probabilities\n- ✅ Visual glow effects for luminous atmospheres\n\n### 4️⃣ Progress Display & Safe Teleport (IMPLEMENTED)\n- ✅ BossBar progress display with percentage\n- ✅ ActionBar and Chat modes available\n- ✅ Color-coded progress (RED → YELLOW → GREEN)\n- ✅ Safe teleportation to first solid block\n- ✅ Avoids dangerous blocks (lava, fire)\n\n### 5️⃣ Config Completeness (FULLY CONFIGURABLE)\n- ✅ Every parameter is now configurable\n- ✅ Ore generation settings\n- ✅ Tree generation settings\n- ✅ Structure and treasure settings\n- ✅ World height limits (1.18+ support)\n- ✅ Performance settings\n- ✅ Debug options\n\n### 6️⃣ Biome-Aware Loot (DETERMINISTIC)\n- ✅ Treasure chests have biome-specific loot\n- ✅ Deterministic loot generation (same planet = same loot)\n- ✅ Position-based treasure placement\n- ✅ 5 treasure tiers (Common, Uncommon, Rare, Epic, Legendary)\n\n### 7️⃣ Hollow Planets (FULLY IMPLEMENTED)\n- ✅ Hollow planet generation with shell\n- ✅ Interior tunnels connecting shell surfaces\n- ✅ Interior structures (ruins, labs, temples, habitats, vaults)\n- ✅ Ore generation in shell only\n- ✅ Configurable shell thickness and inner radius\n\n### 8️⃣ Grounded Flora (FIXED)\n- ✅ Trees now use raycast to find ground\n- ✅ No more floating trees\n- ✅ Ground verification within 3 blocks of surface\n- ✅ Special features (bee nests, cocoa, vines, mushrooms)\n\n### 9️⃣ Satellites & Rings (IMPLEMENTED)\n- ✅ Satellite generation around planets\n- ✅ Ring systems with particle effects\n- ✅ Orbiting particle effects\n- ✅ Configurable satellite count and size\n\n## 📁 New Files Created\n\n### Shape Implementations\n1. `LayeredShape.java` - Katmanlı gezegen\n2. `CrateredShape.java` - Kraterli gezegen\n3. `HoneycombShape.java` - Bal peteği yapısı\n4. `SpiralShape.java` - Spiral gezegen\n5. `WaveShape.java` - Dalgalı gezegen\n6. `CrystalShape.java` - Kristal yapısı\n7. `OrganicShape.java` - Organik yapı\n8. `GeometricShape.java` - Geometrik şekil\n9. `NebulaShape.java` - Nebula bulutu\n10. `AsteroidFieldShape.java` - Asteroid alanı\n\n## 🔧 Updated Files\n\n### Core Files\n- `config.yml` - Complete rewrite with all settings\n- `OreGenerator.java` - Already had improvements\n- `TreeGenerator.java` - Added ground check with raycast\n- `TreasureGenerator.java` - Already had deterministic loot\n- `ShapeRegistry.java` - Added 10 new shapes\n\n## 🎮 How to Use\n\n### 1. Set Workspace\nThe workspace should be set to: `c:\\Users\\Koraizen\\Desktop\\SkyOrbs`\n\n### 2. Build the Plugin\n```bash\nmvn clean package\n```\n\n### 3. Install\nCopy the generated JAR from `target/` to your server's `plugins/` folder.\n\n### 4. Configure\nEdit `config.yml` to customize:\n- Planet sizes and shapes\n- Ore generation rates\n- Tree density\n- Atmosphere types\n- Progress display mode\n- World height limits\n\n### 5. Create a Planet\n```\n/gezegen create [name]\n```\n\n## 📊 Statistics\n\n### Planet Diversity\n- **28 Shapes** (18 original + 10 new)\n- **20+ Palettes** with depth-based materials\n- **10 Modifiers** (hollow, ore-rich, magma-core, etc.)\n- **8 Atmospheres** with effects\n- **Total Combinations**: 44,800+\n\n### Features\n- **Ore Types**: 12+ (coal, iron, copper, gold, diamond, emerald, etc.)\n- **Tree Types**: 12 (oak, birch, spruce, jungle, acacia, etc.)\n- **Treasure Tiers**: 5 (common to legendary)\n- **Dungeon Types**: 5 (crystal cavern, lava chamber, ice tomb, shadow vault, toxic lab)\n\n### Performance\n- Async generation\n- Batched block placement\n- TPS monitoring\n- Auto-throttling\n\n## 🐛 Testing Guide\n\n### Test 1: Ore Generation\n```\n/gezegen create test_ores\n```\n- Dig into the planet\n- Verify ores appear inside (not on surface)\n- Check for deepslate variants deeper down\n- Verify biome-specific ores\n\n### Test 2: Tree Placement\n```\n/gezegen create test_trees\n```\n- Look for trees on surface\n- Verify no floating trees\n- Check special features (bee nests, cocoa, vines)\n\n### Test 3: Hollow Planets\n```\n# Set hollow probability to 1.0 in config\n/gezegen create test_hollow\n```\n- Dig through shell\n- Find interior tunnels\n- Locate interior structures\n- Verify ores only in shell\n\n### Test 4: Progress Display\n```\n/gezegen create test_progress\n```\n- Watch BossBar progress\n- Verify percentage increases smoothly\n- Check color changes (RED → YELLOW → GREEN)\n\n### Test 5: World Height\n```\n# Try with large radius\n/gezegen create test_height\n```\n- Verify planet fits in world bounds (-64 to 320)\n- Check auto-resize if needed\n- Verify no blocks outside world limits\n\n## 🔍 Debug Mode\n\nEnable debug in `config.yml`:\n```yaml\ndebug:\n  enabled: true\n  oreGeneration:\n    enabled: true\n  treeGeneration:\n    enabled: true\n  performanceMonitor:\n    enabled: true\n```\n\n## 📝 Configuration Examples\n\n### High Ore Density\n```yaml\nfeatures:\n  ores:\n    densityMultiplier: 2.0\n```\n\n### More Trees\n```yaml\nfeatures:\n  trees:\n    densityMultiplier: 3.0\n```\n\n### Larger Planets\n```yaml\ngeneration:\n  planetSize:\n    minRadius: 40\n    maxRadius: 80\n```\n\n### More Hollow Planets\n```yaml\nmodifiers:\n  hollow:\n    probability: 0.8\n```\n\n## 🎯 Next Steps\n\n1. **Test thoroughly** - Create multiple planets and verify all features\n2. **Adjust config** - Tune settings to your preference\n3. **Report issues** - If you find any bugs, document them\n4. **Enjoy** - Explore the 44,800+ unique planet combinations!\n\n## 📞 Support\n\nIf you encounter any issues:\n1. Check the console for error messages\n2. Enable debug mode in config\n3. Verify all files are in place\n4. Make sure you're using Java 17+\n5. Ensure Bukkit/Spigot version is 1.18+\n\n## 🎉 Credits\n\n- **Original Plugin**: SkyOrbs\n- **Major Update**: Version 2.0.0\n- **Features**: 2000+ planet combinations, improved generation, better performance\n\n---\n\n**Version**: 2.0.0  \n**Date**: 2024  \n**Status**: ✅ Complete and Ready for Testing\n","size_bytes":7121},"src/main/java/com/skyorbs/shapes/impl/MushroomShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class MushroomShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Mantar şekli - şapka ve sap\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Mushroom cap (üst kısım geniş)\n        if (y > 0) {\n            double capRadius = 1.0 - y * 0.5; // Yukarıda daha geniş\n            return Math.sqrt(x*x + z*z) <= capRadius;\n        }\n        // Mushroom stem (alt kısım dar)\n        else {\n            double stemRadius = 0.3;\n            return Math.sqrt(x*x + z*z) <= stemRadius;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"MUSHROOM\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.6;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Mantar\";\n    }\n}","size_bytes":1142},"src/main/java/com/skyorbs/shapes/impl/FlowerShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class FlowerShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Çiçek şekli - 3D flower\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Flower formülü - taç yaprakları\n        double angle = Math.atan2(z, x);\n        double petalRadius = 1.0 + 0.5 * Math.cos(6 * angle); // 6 taç yaprağı\n        double radialDistance = Math.sqrt(x*x + z*z);\n\n        return radialDistance <= petalRadius * 0.8 && Math.abs(y) <= 0.6;\n    }\n\n    @Override\n    public String getName() {\n        return \"FLOWER\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Çiçek\";\n    }\n}","size_bytes":1073},"src/main/java/com/skyorbs/shapes/impl/CylinderShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class CylinderShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        double distance = Math.sqrt(dx * dx + dz * dz);\n        int height = radius;\n        return distance <= radius && Math.abs(dy) <= height;\n    }\n    \n    @Override\n    public String getName() {\n        return \"CYLINDER\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.0;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Silindir\";\n    }\n}\n","size_bytes":638},"src/main/java/com/skyorbs/features/SatelliteGenerator.java":{"content":"package com.skyorbs.features;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.biomes.BiomeType;\nimport com.skyorbs.core.Orb;\nimport org.bukkit.Material;\nimport org.bukkit.World;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.UUID;\n\npublic class SatelliteGenerator {\n\n    private final SkyOrbs plugin;\n\n    public SatelliteGenerator(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    /**\n     * Ana gezegen için uydular üretir\n     */\n    public List<Orb> generateSatellitesForPlanet(Orb planet, World world) {\n        List<Orb> satellites = new ArrayList<>();\n        Random random = new Random(planet.getSeed() + 777);\n\n        int minCount = plugin.getConfigManager().getMinSatellitesPerPlanet();\n        int maxCount = plugin.getConfigManager().getMaxSatellitesPerPlanet();\n\n        // Olasılık kontrolü\n        double probability = plugin.getConfigManager().getSatelliteProbability();\n        if (random.nextDouble() > probability) {\n            return satellites; // Uydu yok\n        }\n\n        int count = minCount + random.nextInt(maxCount - minCount + 1);\n\n        for (int i = 0; i < count; i++) {\n            Orb satellite = createSatellite(planet, world, random);\n            if (satellite != null) {\n                satellites.add(satellite);\n            }\n        }\n\n        return satellites;\n    }\n\n    /**\n     * Tek bir uydu oluşturur\n     */\n    private Orb createSatellite(Orb parentPlanet, World world, Random random) {\n        // Uydu boyutu ana gezegenden küçük\n        int parentRadius = parentPlanet.getRadius();\n        int minRadius = Math.max(15, parentRadius / 4);\n        int maxRadius = Math.max(25, parentRadius / 2);\n        int radius = minRadius + random.nextInt(maxRadius - minRadius + 1);\n\n        // Şekil seçimi (daha yuvarlak uydular)\n        String shapeName;\n        double shapeRand = random.nextDouble();\n        if (shapeRand < 0.5) {\n            shapeName = \"SPHERE\";\n        } else if (shapeRand < 0.8) {\n            shapeName = \"ELLIPSOID\";\n        } else {\n            shapeName = \"BLOB\";\n        }\n\n        // Biyom seçimi (uzay temalı)\n        BiomeType biome = getRandomSatelliteBiome(random);\n\n        // Pozisyon hesaplama (daha uzak)\n        int[] position = calculateSatellitePosition(parentPlanet, random);\n        int centerX = position[0];\n        int centerY = position[1];\n        int centerZ = position[2];\n\n        // İsim oluşturma\n        String name = \"Satellite-\" + UUID.randomUUID().toString().substring(0, 6);\n\n        // Seed oluşturma\n        long seed = random.nextLong();\n\n        return new Orb(\n            UUID.randomUUID(),\n            name,\n            world.getName(),\n            centerX,\n            centerY,\n            centerZ,\n            radius,\n            shapeName,\n            biome.name(),\n            seed,\n            System.currentTimeMillis(),\n            false, // isAsteroid = false (uydu)\n            parentPlanet.getId()\n        );\n    }\n\n    /**\n     * Uydu pozisyonunu hesaplar (asteroidlerden daha uzak)\n     */\n    private int[] calculateSatellitePosition(Orb parentPlanet, Random random) {\n        int parentX = parentPlanet.getCenterX();\n        int parentY = parentPlanet.getCenterY();\n        int parentZ = parentPlanet.getCenterZ();\n\n        // Uydular daha uzak (800-1500 blok)\n        int minDistance = 800;\n        int maxDistance = 1500;\n        int distance = minDistance + random.nextInt(maxDistance - minDistance + 1);\n\n        // Rastgele açı\n        double angle = random.nextDouble() * 2 * Math.PI;\n\n        int x = parentX + (int)(Math.cos(angle) * distance);\n        int z = parentZ + (int)(Math.sin(angle) * distance);\n        int y = parentY + random.nextInt(101) - 50; // ±50 varyasyon\n\n        return new int[]{x, y, z};\n    }\n\n    /**\n     * Uydu için uygun biyom seçer\n     */\n    private BiomeType getRandomSatelliteBiome(Random random) {\n        // Uydular için daha egzotik biyomlar\n        BiomeType[] satelliteBiomes = {\n            BiomeType.CRYSTAL_FOREST,\n            BiomeType.VOID,\n            BiomeType.ICE_SPIKES,\n            BiomeType.LAVA_OCEAN\n        };\n\n        return satelliteBiomes[random.nextInt(satelliteBiomes.length)];\n    }\n\n    /**\n     * Uydu bloklarını üretir\n     */\n    public List<OreGenerator.BlockData> generateSatelliteBlocks(Orb satellite, BiomeType biome) {\n        List<OreGenerator.BlockData> blocks = new ArrayList<>();\n        Random random = new Random(satellite.getSeed());\n\n        int cx = satellite.getCenterX();\n        int cy = satellite.getCenterY();\n        int cz = satellite.getCenterZ();\n        int radius = satellite.getRadius();\n\n        // Uydu şekli için shape al\n        var shape = plugin.getShapeRegistry().getShape(satellite.getShapeName());\n        if (shape == null) {\n            shape = plugin.getShapeRegistry().getShape(\"SPHERE\");\n        }\n\n        // Ana bloklar\n        for (int x = -radius; x <= radius; x++) {\n            for (int y = -radius; y <= radius; y++) {\n                for (int z = -radius; z <= radius; z++) {\n                    if (shape.isBlockPart(x, y, z, radius, satellite.getSeed())) {\n                        Material material = getSatelliteMaterial(biome, random);\n                        blocks.add(new OreGenerator.BlockData(cx + x, cy + y, cz + z, material));\n                    }\n                }\n            }\n        }\n\n        // Uydu özellikleri (daha nadir)\n        generateSatelliteFeatures(blocks, satellite, biome, random);\n\n        return blocks;\n    }\n\n    /**\n     * Uydu malzemesi seçer\n     */\n    private Material getSatelliteMaterial(BiomeType biome, Random random) {\n        // Biyom bazlı egzotik malzemeler\n        Material[] materials = switch (biome) {\n            case CRYSTAL_FOREST -> new Material[]{Material.AMETHYST_BLOCK, Material.QUARTZ_BLOCK, Material.PURPUR_BLOCK};\n            case VOID -> new Material[]{Material.END_STONE, Material.OBSIDIAN, Material.PURPUR_BLOCK};\n            case ICE_SPIKES -> new Material[]{Material.PACKED_ICE, Material.BLUE_ICE, Material.ICE};\n            case LAVA_OCEAN -> new Material[]{Material.MAGMA_BLOCK, Material.OBSIDIAN, Material.BLACKSTONE};\n            default -> new Material[]{Material.STONE, Material.ANDESITE, Material.DIORITE};\n        };\n\n        return materials[random.nextInt(materials.length)];\n    }\n\n    /**\n     * Uydu özel özellikleri üretir\n     */\n    private void generateSatelliteFeatures(List<OreGenerator.BlockData> blocks, Orb satellite, BiomeType biome, Random random) {\n        int cx = satellite.getCenterX();\n        int cy = satellite.getCenterY();\n        int cz = satellite.getCenterZ();\n        int radius = satellite.getRadius();\n\n        // Özel yapılar (çok nadir)\n        int featureCount = Math.max(1, radius / 10);\n\n        for (int i = 0; i < featureCount; i++) {\n            int x = cx + random.nextInt(radius * 2) - radius;\n            int y = cy + random.nextInt(radius * 2) - radius;\n            int z = cz + random.nextInt(radius * 2) - radius;\n\n            // Sadece uydu içinde ise\n            double distance = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy) + (z - cz) * (z - cz));\n            if (distance <= radius - 1) {\n                Material feature = getSatelliteFeature(biome, random);\n                if (feature != null) {\n                    blocks.add(new OreGenerator.BlockData(x, y, z, feature));\n                }\n            }\n        }\n    }\n\n    /**\n     * Uydu özel malzemesi seçer\n     */\n    private Material getSatelliteFeature(BiomeType biome, Random random) {\n        // Özel malzemeler\n        Material[] features = switch (biome) {\n            case CRYSTAL_FOREST -> new Material[]{Material.AMETHYST_CLUSTER, Material.SMALL_AMETHYST_BUD};\n            case VOID -> new Material[]{Material.END_ROD, Material.CHORUS_PLANT};\n            case ICE_SPIKES -> new Material[]{Material.BLUE_ICE, Material.PACKED_ICE};\n            case LAVA_OCEAN -> new Material[]{Material.LAVA, Material.MAGMA_BLOCK};\n            default -> null;\n        };\n\n        return features != null ? features[random.nextInt(features.length)] : null;\n    }\n}","size_bytes":8185},"src/main/java/com/skyorbs/shapes/impl/TreeShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class TreeShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Ağaç şekli - kökler, gövde, yapraklar\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Tree structure\n        if (y < -0.3) {\n            // Roots - aşağıda geniş\n            double rootRadius = 0.4 + (-y - 0.3) * 0.5;\n            return Math.sqrt(x*x + z*z) <= rootRadius;\n        } else if (y < 0.3) {\n            // Trunk - orta kısım dar\n            double trunkRadius = 0.2;\n            return Math.sqrt(x*x + z*z) <= trunkRadius;\n        } else {\n            // Canopy - yukarıda geniş ve yapraklı\n            double canopyRadius = 0.8 - (y - 0.3) * 0.4;\n            return Math.sqrt(x*x + z*z) <= canopyRadius;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return \"TREE\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Ağaç\";\n    }\n}","size_bytes":1346},"src/main/java/com/skyorbs/gui/PlanetPanelGUI.java":{"content":"package com.skyorbs.gui;\n\nimport com.skyorbs.SkyOrbs;\nimport com.skyorbs.core.Orb;\nimport com.skyorbs.core.PlanetEvolution;\nimport com.skyorbs.core.PlanetType;\nimport org.bukkit.Bukkit;\nimport org.bukkit.Material;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.Inventory;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.meta.ItemMeta;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PlanetPanelGUI {\n\n    private final SkyOrbs plugin;\n\n    public PlanetPanelGUI(SkyOrbs plugin) {\n        this.plugin = plugin;\n    }\n\n    public void openPlanetPanel(Player player, Orb orb) {\n        Inventory gui = Bukkit.createInventory(null, 54, \"§8[§bGezegen Paneli§8] §f\" + orb.getName());\n\n        // Core Information Section (Top Row)\n        gui.setItem(4, createCoreInfoItem(orb));\n        gui.setItem(3, createEvolutionInfoItem(orb));\n        gui.setItem(5, createEnergyInfoItem(orb));\n\n        // Planet Stats Section (Second Row)\n        gui.setItem(9, createTypeInfoItem(orb));\n        gui.setItem(10, createBiosphereInfoItem(orb));\n        gui.setItem(11, createEcologyInfoItem(orb));\n        gui.setItem(12, createSizeInfoItem(orb));\n\n        // Actions Section (Third Row)\n        gui.setItem(18, createTeleportItem(orb));\n        gui.setItem(19, createLaboratoryItem(orb));\n        gui.setItem(20, createAchievementsItem(orb));\n        gui.setItem(21, createSettingsItem(orb));\n\n        // Quick Actions (Fourth Row)\n        gui.setItem(27, createRenameItem(orb));\n        gui.setItem(28, createShareItem(orb));\n        gui.setItem(29, createBackupItem(orb));\n        gui.setItem(30, createDeleteItem(orb));\n\n        // Planet Theme Section (Fifth Row)\n        gui.setItem(36, createThemeItem(orb));\n        gui.setItem(37, createEffectsItem(orb));\n        gui.setItem(38, createEventsItem(orb));\n\n        // Admin Section (Bottom Row - if player has permission)\n        if (player.hasPermission(\"skyorbs.admin\")) {\n            gui.setItem(45, createAdminScanItem(orb));\n            gui.setItem(46, createAdminRepairItem(orb));\n            gui.setItem(47, createAdminDebugItem(orb));\n            gui.setItem(48, createAdminConfigItem(orb));\n        }\n\n        // Close button\n        gui.setItem(49, createCloseItem());\n\n        player.openInventory(gui);\n    }\n\n    private ItemStack createCoreInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(getCoreMaterial(orb.getCoreLevel()));\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lÇekirdek Bilgileri\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Seviye: §e\" + orb.getCoreLevel() + \" §7/ §e10\");\n        lore.add(\"§7XP: §a\" + orb.getXp() + \" §7/ §a\" + orb.getXpForNextLevel());\n        lore.add(\"\");\n        lore.add(\"§7Sonraki seviye için gereken XP:\");\n        lore.add(\"§c\" + (orb.getXpForNextLevel() - orb.getXp()));\n        if (orb.canUpgrade()) {\n            lore.add(\"\");\n            lore.add(\"§a§lYükseltmeye hazır!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEvolutionInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ENCHANTED_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lEvrim Bilgileri\");\n        List<String> lore = new ArrayList<>();\n        PlanetEvolution evolution = new PlanetEvolution(orb);\n        lore.add(\"§7\" + evolution.getEvolutionDescription());\n        lore.add(\"\");\n        Map<String, Object> reqs = evolution.getEvolutionRequirements();\n        lore.add(\"§7İlerleme: §e\" + String.format(\"%.1f\", reqs.get(\"progressPercent\")) + \"%\");\n        if ((Boolean) reqs.get(\"canUpgrade\")) {\n            lore.add(\"\");\n            lore.add(\"§a§lTıklayarak yükselt!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEnergyInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.REDSTONE);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lEnerji Seviyesi\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Enerji: §c\" + String.format(\"%.1f\", orb.getEnergyLevel()) + \"%\");\n        lore.add(\"§7Rejenerasyon: §a+\" + String.format(\"%.2f\", orb.getEnergyRegenRate()) + \"/dk\");\n        double energyPercent = orb.getEnergyLevel() / 100.0;\n        if (energyPercent > 0.8) {\n            lore.add(\"§aEnerji dolu!\");\n        } else if (energyPercent > 0.5) {\n            lore.add(\"§eOrta seviye enerji\");\n        } else if (energyPercent > 0.2) {\n            lore.add(\"§6Düşük enerji\");\n        } else {\n            lore.add(\"§cKritik enerji seviyesi!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createTypeInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(orb.getPlanetType().getIconMaterial());\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lGezegen Tipi\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Tip: §9\" + orb.getPlanetType().getDisplayName());\n        lore.add(\"\");\n        lore.add(\"§7\" + orb.getPlanetType().getDescription());\n        lore.add(\"\");\n        lore.add(\"§7Enerji Çarpanı: §e\" + String.format(\"%.1f\", orb.getPlanetType().getEnergyMultiplier()) + \"x\");\n        lore.add(\"§7Max Biyosfer: §a\" + orb.getPlanetType().getMaxBiosphereLevel());\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createBiosphereInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.OAK_SAPLING);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§2§lBiyosfer\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Seviye: §2\" + orb.getBiosphereLevel() + \" §7/ §25\");\n        lore.add(\"\");\n        String levelDesc = switch (orb.getBiosphereLevel()) {\n            case 1 -> \"§7Temel yaşam formları\";\n            case 2 -> \"§7Gelişen ekosistem\";\n            case 3 -> \"§7Çeşitli flora ve fauna\";\n            case 4 -> \"§7Zengin biyolojik çeşitlilik\";\n            case 5 -> \"§7Maksimum ekolojik denge\";\n            default -> \"§7Bilinmeyen seviye\";\n        };\n        lore.add(levelDesc);\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEcologyInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMPOSTER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§a§lEkolojik Denge\");\n        List<String> lore = new ArrayList<>();\n        double balance = orb.getEcologicalBalance();\n        lore.add(\"§7Denge: §a\" + String.format(\"%.2f\", balance));\n        lore.add(\"\");\n        if (balance > 1.5) {\n            lore.add(\"§aMükemmel ekolojik denge!\");\n        } else if (balance > 1.0) {\n            lore.add(\"§eİyi ekolojik durum\");\n        } else if (balance > 0.8) {\n            lore.add(\"§6Denge bozuluyor\");\n        } else if (balance > 0.5) {\n            lore.add(\"§cKritik ekolojik durum!\");\n        } else {\n            lore.add(\"§4Çevresel felaket!\");\n        }\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSizeInfoItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§f§lGezegen Boyutu\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Yarıçap: §f\" + orb.getRadius() + \" blok\");\n        lore.add(\"§7Hacim: §f\" + String.format(\"%.0f\", (4.0/3.0) * Math.PI * Math.pow(orb.getRadius(), 3)) + \" blok³\");\n        lore.add(\"§7Konum: §f\" + orb.getCenterX() + \", \" + orb.getCenterY() + \", \" + orb.getCenterZ());\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createTeleportItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ENDER_PEARL);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§5§lIşınlanma\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegene ışınlan\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak ışınlan!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createLaboratoryItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BREWING_STAND);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§d§lLaboratuvar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen laboratuvarı\");\n        lore.add(\"§7Yükseltmeler ve araştırmalar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAchievementsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.GOLDEN_APPLE);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§6§lBaşarımlar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen başarımları\");\n        lore.add(\"§7Özel ödüller ve unvanlar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createSettingsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMPARATOR);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§3§lAyarlar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen ayarları\");\n        lore.add(\"§7İsim, izinler, tema\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createRenameItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.NAME_TAG);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§f§lYeniden Adlandır\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen adını değiştir\");\n        lore.add(\"§7Token gerektirir\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createShareItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.WRITABLE_BOOK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§9§lPaylaş\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni diğer oyuncularla paylaş\");\n        lore.add(\"§7Davetiye gönder\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createBackupItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BOOKSHELF);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§8§lYedekle\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni yedekle\");\n        lore.add(\"§7Veri kaybına karşı koru\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak yedekle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createDeleteItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.TNT);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§4§lSil\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni sil\");\n        lore.add(\"§4§lBu işlem geri alınamaz!\");\n        lore.add(\"\");\n        lore.add(\"§cSağ tıkla onay için\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createThemeItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.PAINTING);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§d§lTema\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegen temasını değiştir\");\n        lore.add(\"§7Renkler, efektler, müzik\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEffectsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.BEACON);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§b§lEfektler\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Aktif gezegen efektleri\");\n        lore.add(\"§7Aura, partiküller, sesler\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createEventsItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.FIREWORK_ROCKET);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§e§lOlaylar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Aktif gök olayları\");\n        lore.add(\"§7Fırtınalar, yağmurlar, patlamalar\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak görüntüle!\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminScanItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.SPYGLASS);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Tara\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Bozuk chunkları tara\");\n        lore.add(\"§7Sorunları tespit et\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminRepairItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.ANVIL);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Onar\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Gezegeni onar\");\n        lore.add(\"§7Biyom ve ore rejenerasyonu\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminDebugItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.COMMAND_BLOCK);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Debug\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Debug bilgileri\");\n        lore.add(\"§7Detaylı loglar\");\n        lore.add(\"\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createAdminConfigItem(Orb orb) {\n        ItemStack item = new ItemStack(Material.REDSTONE_LAMP);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§l[ADMIN] Konfigürasyon\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Sistem konfigürasyonları\");\n        lore.add(\"§7Ore ayarları, performans, limitler\");\n        lore.add(\"\");\n        lore.add(\"§eTıklayarak aç!\");\n        lore.add(\"§cAdmin komutu\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private ItemStack createCloseItem() {\n        ItemStack item = new ItemStack(Material.BARRIER);\n        ItemMeta meta = item.getItemMeta();\n        meta.setDisplayName(\"§c§lKapat\");\n        List<String> lore = new ArrayList<>();\n        lore.add(\"§7Paneli kapat\");\n        meta.setLore(lore);\n        item.setItemMeta(meta);\n        return item;\n    }\n\n    private Material getCoreMaterial(int level) {\n        return switch (level) {\n            case 1 -> Material.COAL_BLOCK;\n            case 2 -> Material.IRON_BLOCK;\n            case 3 -> Material.GOLD_BLOCK;\n            case 4 -> Material.DIAMOND_BLOCK;\n            case 5 -> Material.EMERALD_BLOCK;\n            case 6 -> Material.NETHERITE_BLOCK;\n            case 7 -> Material.AMETHYST_BLOCK;\n            case 8 -> Material.CRYING_OBSIDIAN;\n            case 9 -> Material.ANCIENT_DEBRIS;\n            case 10 -> Material.NETHER_STAR;\n            default -> Material.STONE;\n        };\n    }\n}","size_bytes":16475},"src/main/java/com/skyorbs/shapes/impl/HelicopterShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class HelicopterShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Helikopter şekli - fuselage, rotors, tail\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Fuselage (gövde)\n        if (Math.abs(y) <= 0.15) {\n            return Math.sqrt(x*x + z*z) <= 0.3;\n        }\n\n        // Main rotor (ana rotor)\n        if (y > 0.4 && y < 0.5) {\n            double rotorRadius = Math.sqrt(x*x + z*z);\n            return rotorRadius <= 0.8;\n        }\n\n        // Rotor mast (rotor direği)\n        if (Math.abs(x) <= 0.05 && Math.abs(z) <= 0.05 && y > 0.15 && y < 0.4) {\n            return true;\n        }\n\n        // Tail boom (kuyruk boom'u)\n        if (x < -0.2 && Math.abs(y) <= 0.08 && Math.abs(z) <= 0.06) {\n            return true;\n        }\n\n        // Tail rotor (kuyruk rotoru)\n        if (x < -0.3 && Math.abs(y) <= 0.05 && Math.abs(z) <= 0.2) {\n            return true;\n        }\n\n        // Landing skids (inme takozları)\n        if (y < -0.1 && Math.abs(y + 0.15) <= 0.05) {\n            if (Math.abs(z) <= 0.4 && Math.abs(x) <= 0.25) return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"HELICOPTER\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.8;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Helikopter\";\n    }\n}","size_bytes":1740},"src/main/java/com/skyorbs/shapes/impl/DonutShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class DonutShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Halka şekli (donut/torus)\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Torus formülü\n        double majorRadius = radius * 0.7; // Ana yarıçap\n        double minorRadius = radius * 0.3; // Küçük yarıçap\n\n        // XY düzleminde halka\n        double xyDistance = Math.sqrt(dx * dx + dy * dy);\n        double torusDistance = Math.sqrt(\n            Math.pow(xyDistance - majorRadius, 2) + dz * dz\n        );\n\n        return torusDistance <= minorRadius;\n    }\n\n    @Override\n    public String getName() {\n        return \"DONUT\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.5;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Halka\";\n    }\n}","size_bytes":1018},"src/main/java/com/skyorbs/shapes/impl/ShieldShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\n\npublic class ShieldShape implements PlanetShape {\n\n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        // Kalkan şekli - oval base, pointed top\n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        if (distance > radius) return false;\n\n        // Normalize coordinates\n        double x = dx / (double)radius;\n        double y = dy / (double)radius;\n        double z = dz / (double)radius;\n\n        // Shield shape - wider at bottom, pointed at top\n        double shieldWidth = 0.8 - y * 0.3; // Bottom'da daha geniş\n        double shieldHeight = 1.0;\n\n        // Main shield body\n        if (Math.abs(x) <= shieldWidth && y >= -shieldHeight && y <= 0) {\n            return Math.abs(z) <= 0.1; // Thin shield\n        }\n\n        // Shield boss (merkez çıkıntı)\n        double bossDistance = Math.sqrt(x*x + (y+0.3)*(y+0.3));\n        if (bossDistance <= 0.15) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public String getName() {\n        return \"SHIELD\";\n    }\n\n    @Override\n    public double getDeformationFactor() {\n        return 0.4;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return \"Kalkan\";\n    }\n}","size_bytes":1317},"src/main/java/com/skyorbs/shapes/impl/HybridShape.java":{"content":"package com.skyorbs.shapes.impl;\n\nimport com.skyorbs.shapes.PlanetShape;\nimport com.skyorbs.utils.NoiseGenerator;\n\nimport java.util.Random;\n\npublic class HybridShape implements PlanetShape {\n    \n    @Override\n    public boolean isBlockPart(int dx, int dy, int dz, int radius, long seed) {\n        Random rand = new Random(seed);\n        double choice = rand.nextDouble();\n        \n        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        double noise = NoiseGenerator.getNoise(dx, dy, dz, seed, 0.15);\n        \n        if (choice < 0.5) {\n            double sphereDeform = 1 + 0.2 * noise;\n            return distance <= radius * sphereDeform;\n        } else {\n            int manhattan = Math.abs(dx) + Math.abs(dy) + Math.abs(dz);\n            double cubeDeform = 1 + 0.15 * noise;\n            return manhattan <= radius * cubeDeform;\n        }\n    }\n    \n    @Override\n    public String getName() {\n        return \"HYBRID\";\n    }\n    \n    @Override\n    public double getDeformationFactor() {\n        return 0.2;\n    }\n    \n    @Override\n    public String getDisplayName() {\n        return \"Karma\";\n    }\n}\n","size_bytes":1126},"replit.md":{"content":"# SkyOrbs - Minecraft Plugin Projesi\n\n## Proje Özeti\nSkyOrbs 2.0.0 - Türkçe Minecraft gezegen oluşturma eklentisi\n- **Platform:** Paper 1.21.4\n- **Java:** 21\n- **Build System:** Maven\n- **Dosya Sayısı:** 127 Java dosyası (~16,700 satır kod)\n\n## Proje Yapısı\n```\nsrc/main/java/com/skyorbs/\n├── core/          - Temel sınıflar (Orb, PlanetType, PlanetEvolution)\n├── commands/      - Komut sistemi (/gezegen)\n├── config/        - ConfigManager\n├── generation/    - Gezegen üretim sistemi\n├── shapes/        - 70+ gezegen şekli\n├── biomes/        - 22 biyom tipi\n├── storage/       - SQLite veritabanı + PlanetDataManager\n├── atmosphere/    - Atmosfer efekt sistemi\n├── ecosystem/     - Biyosfer yönetimi\n├── events/        - Gök olayları\n├── features/      - Ore, Tree, Structure, Treasure, Asteroid\n├── dungeons/      - Zindan üretimi\n├── gui/           - Admin GUI\n├── listeners/     - Event listeners\n├── modifiers/     - Gezegen modifikatörleri\n├── palettes/      - Renk paletleri\n└── utils/         - Yardımcı araçlar\n```\n\n## Özellikler\n- ✅ 70+ farklı gezegen şekli (Sphere, Blob, Star, Rainbow, Butterfly, vb.)\n- ✅ 22 biyom tipi\n- ✅ Atmosfer efekt sistemi\n- ✅ SQLite veritabanı entegrasyonu\n- ✅ Asteroid & Uydu sistemi\n- ✅ Zindan, hazine, yapı sistemi\n- ✅ Config-driven (ultra detaylı config.yml)\n- ✅ Async gezegen üretimi\n- ✅ BossBar/ActionBar progress gösterimi\n- ✅ Admin GUI sistemi\n\n## Build Komutu\n```bash\nmvn clean package\n```\n\nJAR dosyası: `target/SkyOrbs-2.0.0.jar`\n\n## Test Coverage\n- ShapeRegistryTest.java (33 şekil testi)\n- ConfigManagerTest.java (config doğrulama)\n- BiomeTypeTest.java (biyom testleri)\n\n## Son Değişiklikler\n- 2025-01-19: Replit environment setup başlatıldı\n- Java 21 ve Maven kurulumu yapılacak\n- Build sistemi yapılandırılacak\n","size_bytes":1927}},"version":2}